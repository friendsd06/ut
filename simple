package com.logviewer.ui;

import javafx.scene.control.ListCell;
import javafx.scene.paint.Color;
import javafx.scene.text.Font;

public class ColoredLogCell extends ListCell<String> {

    // Static trace ID for highlighting across all cells
    private static String highlightTraceId = null;

    public static void setHighlightTraceId(String traceId) {
        highlightTraceId = traceId;
    }

    public static String getHighlightTraceId() {
        return highlightTraceId;
    }

    @Override
    protected void updateItem(String item, boolean empty) {
        super.updateItem(item, empty);

        if (empty || item == null) {
            setText(null);
            setStyle("");
        } else {
            setText(item);
            setFont(Font.font("Consolas", 11));

            // Apply color based on log level and content type
            String style = "";
            String trimmedItem = item.trim();
            String upperItem = item.toUpperCase();

            // Check for trace ID highlighting first (highest priority)
            boolean containsTraceId = highlightTraceId != null && !highlightTraceId.isEmpty() &&
                                      item.contains(highlightTraceId);

            if (containsTraceId) {
                // Bright yellow/gold highlighting for trace ID matches
                style = "-fx-background-color: #fff9c4; -fx-text-fill: #000000; -fx-font-weight: bold; -fx-border-color: #fbc02d; -fx-border-width: 0 0 0 5;";
            } // Check for stack trace lines (starts with "at " or "Caused by:")
            else if (isStackTraceLine(trimmedItem)) {
                if (trimmedItem.startsWith("Caused by:") || trimmedItem.startsWith("caused by:")) {
                    // Root cause - highlight in bold red
                    style = "-fx-background-color: #ffe0e0; -fx-text-fill: #d32f2f; -fx-font-weight: bold; -fx-border-color: #e57373; -fx-border-width: 0 0 0 3;";
                } else if (trimmedItem.startsWith("at ") || trimmedItem.startsWith("\tat ")) {
                    // Stack trace line - light red/pink background
                    style = "-fx-background-color: #fff5f5; -fx-text-fill: #c62828; -fx-border-color: #ffcdd2; -fx-border-width: 0 0 0 2;";
                } else {
                    // Exception class line (e.g., "java.lang.NullPointerException: ...")
                    style = "-fx-background-color: #ffebee; -fx-text-fill: #b71c1c; -fx-font-weight: bold; -fx-border-color: #ef5350; -fx-border-width: 0 0 0 4;";
                }
            } else if (upperItem.contains("ERROR")) {
                // Red background for errors
                style = "-fx-background-color: #ffebee; -fx-text-fill: #c62828; -fx-font-weight: bold;";
            } else if (upperItem.contains("WARN")) {
                // Orange/yellow background for warnings
                style = "-fx-background-color: #fff8e1; -fx-text-fill: #f57c00; -fx-font-weight: bold;";
            } else if (upperItem.contains("INFO")) {
                // Light blue background for info
                style = "-fx-background-color: #e3f2fd; -fx-text-fill: #1565c0;";
            } else if (upperItem.contains("DEBUG")) {
                // Gray for debug
                style = "-fx-background-color: #f5f5f5; -fx-text-fill: #757575;";
            } else if (upperItem.contains("TRACE")) {
                // Very light gray for trace
                style = "-fx-background-color: #fafafa; -fx-text-fill: #9e9e9e;";
            } else if (upperItem.contains("EXCEPTION") || upperItem.contains("FATAL")) {
                // Dark red for exceptions/fatal
                style = "-fx-background-color: #ffcdd2; -fx-text-fill: #b71c1c; -fx-font-weight: bold;";
            } else {
                // Default styling
                style = "-fx-text-fill: #333333;";
            }

            setStyle(style);
        }
    }

    /**
     * Detects if a line is part of a Java stack trace
     */
    private boolean isStackTraceLine(String line) {
        if (line == null || line.isEmpty()) {
            return false;
        }

        // Stack trace patterns:
        // - "at com.example.ClassName.methodName(FileName.java:123)"
        // - "Caused by: java.lang.Exception: message"
        // - Exception class names (e.g., "java.lang.NullPointerException: message")

        return line.startsWith("at ") ||
               line.startsWith("\tat ") ||
               line.startsWith("Caused by:") ||
               line.startsWith("caused by:") ||
               (line.contains("Exception:") && (line.contains("java.") || line.contains("org.") || line.contains("com."))) ||
               (line.contains("Exception ") && line.contains("at ")) ||
               line.matches(".*Exception.*:.*") ||
               line.contains("... ") && line.contains(" more");
    }
}
---------------------------------------------

package com.logviewer.service;

import com.logviewer.model.LogEntry;
import com.logviewer.model.SQLQueryInfo;

import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Extracts SQL queries from log entries
 */
public class SQLQueryExtractor {

    // Patterns to match SQL queries in logs
    private static final Pattern SQL_PATTERN = Pattern.compile(
        "(SELECT|INSERT|UPDATE|DELETE|CREATE|ALTER|DROP)\\s+.*?(?:FROM|INTO|TABLE|SET|WHERE|GROUP|ORDER|LIMIT|;|$)",
        Pattern.CASE_INSENSITIVE | Pattern.DOTALL
    );

    private static final Pattern DURATION_PATTERN = Pattern.compile("(\\d+)\\s*ms");
    private static final Pattern ROW_COUNT_PATTERN = Pattern.compile("(\\d+)\\s*row");
    private static final Pattern REQUEST_ID_PATTERN = Pattern.compile(
        "(?:requestId|request-id|traceId)[=:\\s]+([a-zA-Z0-9-]+)",
        Pattern.CASE_INSENSITIVE
    );

    /**
     * Extract all SQL queries from log entries
     */
    public List<SQLQueryInfo> extractQueries(List<LogEntry> logEntries) {
        List<SQLQueryInfo> queries = new ArrayList<>();

        for (int i = 0; i < logEntries.size(); i++) {
            LogEntry entry = logEntries.get(i);
            String line = entry.getFormattedLine();

            // Find SQL queries in the log line
            Matcher sqlMatcher = SQL_PATTERN.matcher(line);

            while (sqlMatcher.find()) {
                String query = sqlMatcher.group().trim();

                // Clean up query
                query = cleanQuery(query);

                if (query.length() > 10) { // Minimum query length
                    SQLQueryInfo queryInfo = new SQLQueryInfo(query);
                    queryInfo.setExecutionTime(entry.getTimestamp());
                    queryInfo.setLogLine(line);
                    queryInfo.setLineNumber(i + 1);

                    // Extract additional info
                    extractDuration(line, queryInfo);
                    extractRequestId(line, queryInfo);
                    extractStatus(line, queryInfo);
                    extractRowCount(line, queryInfo);
                    extractTableInfo(query, queryInfo);

                    queries.add(queryInfo);
                }
            }
        }

        return queries;
    }

    private String cleanQuery(String query) {
        // Remove trailing punctuation and whitespace
        query = query.replaceAll("[;,]$", "").trim();

        // Replace multiple spaces with single space
        query = query.replaceAll("\\s+", " ");

        // Remove newlines
        query = query.replace("\n", " ").replace("\r", " ");

        return query;
    }

    private void extractDuration(String line, SQLQueryInfo queryInfo) {
        Matcher matcher = DURATION_PATTERN.matcher(line);
        if (matcher.find()) {
            try {
                queryInfo.setDurationMs(Long.parseLong(matcher.group(1)));
            } catch (NumberFormatException e) {
                // Ignore
            }
        }
    }

    private void extractRequestId(String line, SQLQueryInfo queryInfo) {
        Matcher matcher = REQUEST_ID_PATTERN.matcher(line);
        if (matcher.find()) {
            queryInfo.setRequestId(matcher.group(1));
        }
    }

    private void extractStatus(String line, SQLQueryInfo queryInfo) {
        String upperLine = line.toUpperCase();
        if (upperLine.contains("ERROR") || upperLine.contains("FAILED")) {
            queryInfo.setStatus("ERROR");
        } else if (upperLine.contains("TIMEOUT")) {
            queryInfo.setStatus("TIMEOUT");
        } else if (upperLine.contains("SUCCESS") || upperLine.contains("COMPLETED")) {
            queryInfo.setStatus("SUCCESS");
        }
    }

    private void extractRowCount(String line, SQLQueryInfo queryInfo) {
        Matcher matcher = ROW_COUNT_PATTERN.matcher(line);
        if (matcher.find()) {
            try {
                queryInfo.setRowCount(Integer.parseInt(matcher.group(1)));
            } catch (NumberFormatException e) {
                // Ignore
            }
        }
    }

    private void extractTableInfo(String query, SQLQueryInfo queryInfo) {
        String upperQuery = query.toUpperCase();

        // Extract table name from FROM clause
        Pattern fromPattern = Pattern.compile("FROM\\s+([a-zA-Z0-9_]+)", Pattern.CASE_INSENSITIVE);
        Matcher fromMatcher = fromPattern.matcher(query);
        if (fromMatcher.find()) {
            queryInfo.setTable(fromMatcher.group(1));
        }

        // Extract table name from INTO clause
        Pattern intoPattern = Pattern.compile("INTO\\s+([a-zA-Z0-9_]+)", Pattern.CASE_INSENSITIVE);
        Matcher intoMatcher = intoPattern.matcher(query);
        if (intoMatcher.find()) {
            queryInfo.setTable(intoMatcher.group(1));
        }

        // Extract table name from UPDATE clause
        Pattern updatePattern = Pattern.compile("UPDATE\\s+([a-zA-Z0-9_]+)", Pattern.CASE_INSENSITIVE);
        Matcher updateMatcher = updatePattern.matcher(query);
        if (updateMatcher.find()) {
            queryInfo.setTable(updateMatcher.group(1));
        }
    }

    /**
     * Get query statistics
     */
    public Map<String, Object> getStatistics(List<SQLQueryInfo> queries) {
        Map<String, Object> stats = new HashMap<>();

        int totalQueries = queries.size();
        int selectCount = 0;
        int insertCount = 0;
        int updateCount = 0;
        int deleteCount = 0;
        long totalDuration = 0;
        int errorCount = 0;

        for (SQLQueryInfo query : queries) {
            switch (query.getQueryType()) {
                case "SELECT": selectCount++; break;
                case "INSERT": insertCount++; break;
                case "UPDATE": updateCount++; break;
                case "DELETE": deleteCount++; break;
            }

            if (query.getDurationMs() != null) {
                totalDuration += query.getDurationMs();
            }

            if ("ERROR".equals(query.getStatus()) || "TIMEOUT".equals(query.getStatus())) {
                errorCount++;
            }
        }

        stats.put("totalQueries", totalQueries);
        stats.put("selectCount", selectCount);
        stats.put("insertCount", insertCount);
        stats.put("updateCount", updateCount);
        stats.put("deleteCount", deleteCount);
        stats.put("totalDuration", totalDuration);
        stats.put("avgDuration", totalQueries > 0 ? totalDuration / totalQueries : 0);
        stats.put("errorCount", errorCount);

        return stats;
    }
}
------------------------------------------------------

package com.logviewer.service;

import com.logviewer.model.EnvironmentProfile;

import java.io.*;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;
import java.util.stream.Collectors;

/**
 * Manages multiple environment profiles
 * Profiles are stored in ~/.logviewer/profiles/ directory
 */
public class ProfileManager {

    private static final String PROFILES_DIR = System.getProperty("user.home") +
        File.separator + ".logviewer" + File.separator + "profiles";

    /**
     * Save a profile to disk
     */
    public void saveProfile(EnvironmentProfile profile) throws IOException {
        ensureProfilesDirectoryExists();

        String fileName = profile.getProfileId() + ".properties";
        File file = new File(PROFILES_DIR, fileName);

        Properties props = new Properties();
        props.setProperty("profile.name", safeGet(profile.getProfileName()));
        props.setProperty("aws.login.command", safeGet(profile.getAwsLoginCommand()));
        props.setProperty("kubectl.context", safeGet(profile.getKubectlContext()));
        props.setProperty("namespace", safeGet(profile.getNamespace()));
        props.setProperty("default.pod.name", safeGet(profile.getDefaultPodName()));
        props.setProperty("default.container.name", safeGet(profile.getDefaultContainerName()));
        props.setProperty("tail.lines", String.valueOf(profile.getTailLines()));
        props.setProperty("refresh.interval", String.valueOf(profile.getRefreshIntervalSeconds()));
        props.setProperty("session.refresh.minutes", String.valueOf(profile.getSessionRefreshMinutes()));

        try (OutputStream os = new FileOutputStream(file)) {
            props.store(os, "Environment Profile: " + profile.getProfileName());
        }
    }

    /**
     * Load a profile from disk
     */
    public EnvironmentProfile loadProfile(String profileId) throws IOException {
        String fileName = profileId + ".properties";
        File file = new File(PROFILES_DIR, fileName);

        if (!file.exists()) {
            throw new IOException("Profile not found: " + profileId);
        }

        Properties props = new Properties();
        try (InputStream is = new FileInputStream(file)) {
            props.load(is);
        }

        EnvironmentProfile profile = new EnvironmentProfile();
        profile.setProfileName(props.getProperty("profile.name", ""));
        profile.setAwsLoginCommand(props.getProperty("aws.login.command", ""));
        profile.setKubectlContext(props.getProperty("kubectl.context", ""));
        profile.setNamespace(props.getProperty("namespace", "default"));
        profile.setDefaultPodName(props.getProperty("default.pod.name", ""));
        profile.setDefaultContainerName(props.getProperty("default.container.name", ""));
        profile.setTailLines(Integer.parseInt(props.getProperty("tail.lines", "1000")));
        profile.setRefreshIntervalSeconds(Integer.parseInt(props.getProperty("refresh.interval", "30")));
        profile.setSessionRefreshMinutes(Integer.parseInt(props.getProperty("session.refresh.minutes", "20")));

        return profile;
    }

    /**
     * List all available profiles
     */
    public List<EnvironmentProfile> listProfiles() throws IOException {
        ensureProfilesDirectoryExists();

        File dir = new File(PROFILES_DIR);
        File[] files = dir.listFiles((d, name) -> name.endsWith(".properties"));

        if (files == null || files.length == 0) {
            return new ArrayList<>();
        }

        List<EnvironmentProfile> profiles = new ArrayList<>();
        for (File file : files) {
            try {
                String profileId = file.getName().replace(".properties", "");
                EnvironmentProfile profile = loadProfile(profileId);
                profiles.add(profile);
            } catch (IOException e) {
                System.err.println("Failed to load profile: " + file.getName() + " - " + e.getMessage());
            }
        }

        // Sort by profile name
        profiles.sort(Comparator.comparing(EnvironmentProfile::getProfileName));

        return profiles;
    }

    /**
     * Delete a profile
     */
    public boolean deleteProfile(String profileId) {
        String fileName = profileId + ".properties";
        File file = new File(PROFILES_DIR, fileName);
        return file.exists() && file.delete();
    }

    /**
     * Check if a profile exists
     */
    public boolean profileExists(String profileId) {
        String fileName = profileId + ".properties";
        File file = new File(PROFILES_DIR, fileName);
        return file.exists();
    }

    // Utility methods

    private void ensureProfilesDirectoryExists() throws IOException {
        Path dirPath = Paths.get(PROFILES_DIR);
        if (!Files.exists(dirPath)) {
            Files.createDirectories(dirPath);
        }
    }

    private String safeGet(String value) {
        return value != null ? value : "";
    }
}
-------------------

package com.logviewer.service;

import com.logviewer.model.LogEntry;
import javafx.concurrent.Task;

import java.time.LocalDateTime;
import java.util.List;
import java.util.stream.Collectors;

/**
 * Fast search service using parallel streams for efficient searching
 * across large log datasets
 */
public class LogSearchService extends Task<List<LogEntry>> {

    private final List<LogEntry> allEntries;
    private final String searchText;
    private final boolean caseSensitive;
    private final boolean includeError;
    private final boolean includeWarn;
    private final boolean includeInfo;
    private final boolean includeDebug;
    private final boolean includeTrace;
    private final LocalDateTime dateFrom;
    private final LocalDateTime dateTo;
    private final String serviceFilter;

    public LogSearchService(
            List<LogEntry> allEntries,
            String searchText,
            boolean caseSensitive,
            boolean includeError,
            boolean includeWarn,
            boolean includeInfo,
            boolean includeDebug,
            boolean includeTrace,
            LocalDateTime dateFrom,
            LocalDateTime dateTo,
            String serviceFilter) {
        this.allEntries = allEntries;
        this.searchText = searchText;
        this.caseSensitive = caseSensitive;
        this.includeError = includeError;
        this.includeWarn = includeWarn;
        this.includeInfo = includeInfo;
        this.includeDebug = includeDebug;
        this.includeTrace = includeTrace;
        this.dateFrom = dateFrom;
        this.dateTo = dateTo;
        this.serviceFilter = serviceFilter;
    }

    @Override
    protected List<LogEntry> call() throws Exception {
        updateMessage("Searching...");
        updateProgress(-1, 1); // Indeterminate progress

        // Use parallel stream for fast searching
        List<LogEntry> results = allEntries.parallelStream()
                .filter(entry -> {
                    if (isCancelled()) {
                        return false;
                    }

                    // Apply search text filter
                    if (!entry.matches(searchText, caseSensitive)) {
                        return false;
                    }

                    // Apply level and date filters
                    return entry.matchesFilters(
                            includeError, includeWarn, includeInfo, includeDebug, includeTrace,
                            dateFrom, dateTo, serviceFilter
                    );
                })
                .collect(Collectors.toList());

        updateMessage(String.format("Found %,d matches", results.size()));
        updateProgress(1, 1);

        return results;
    }

    /**
     * Builder class for easier construction of search queries
     */
    public static class Builder {
        private List<LogEntry> allEntries;
        private String searchText = "";
        private boolean caseSensitive = false;
        private boolean includeError = true;
        private boolean includeWarn = true;
        private boolean includeInfo = true;
        private boolean includeDebug = true;
        private boolean includeTrace = true;
        private LocalDateTime dateFrom = null;
        private LocalDateTime dateTo = null;
        private String serviceFilter = "";

        public Builder allEntries(List<LogEntry> allEntries) {
            this.allEntries = allEntries;
            return this;
        }

        public Builder searchText(String searchText) {
            this.searchText = searchText;
            return this;
        }

        public Builder caseSensitive(boolean caseSensitive) {
            this.caseSensitive = caseSensitive;
            return this;
        }

        public Builder includeError(boolean includeError) {
            this.includeError = includeError;
            return this;
        }

        public Builder includeWarn(boolean includeWarn) {
            this.includeWarn = includeWarn;
            return this;
        }

        public Builder includeInfo(boolean includeInfo) {
            this.includeInfo = includeInfo;
            return this;
        }

        public Builder includeDebug(boolean includeDebug) {
            this.includeDebug = includeDebug;
            return this;
        }

        public Builder includeTrace(boolean includeTrace) {
            this.includeTrace = includeTrace;
            return this;
        }

        public Builder dateFrom(LocalDateTime dateFrom) {
            this.dateFrom = dateFrom;
            return this;
        }

        public Builder dateTo(LocalDateTime dateTo) {
            this.dateTo = dateTo;
            return this;
        }

        public Builder serviceFilter(String serviceFilter) {
            this.serviceFilter = serviceFilter;
            return this;
        }

        public LogSearchService build() {
            return new LogSearchService(
                    allEntries, searchText, caseSensitive,
                    includeError, includeWarn, includeInfo, includeDebug, includeTrace,
                    dateFrom, dateTo, serviceFilter
            );
        }
    }
}
-------------------