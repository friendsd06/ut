package com.logviewer.model;

import java.util.ArrayList;
import java.util.List;

/**
 * Represents correlated log entries across multiple panes
 * Tracks request IDs, transaction IDs, session IDs, etc.
 */
public class CorrelationMatch {

    private final String correlationId;
    private final CorrelationType type;
    private final List<LogEntry> pane1Entries;
    private final List<LogEntry> pane2Entries;
    private final long startTime;
    private final long endTime;

    public enum CorrelationType {
        REQUEST_ID("Request ID"),
        TRANSACTION_ID("Transaction ID"),
        SESSION_ID("Session ID"),
        USER_ID("User ID"),
        ORDER_ID("Order ID"),
        CUSTOM("Custom ID");

        private final String displayName;

        CorrelationType(String displayName) {
            this.displayName = displayName;
        }

        public String getDisplayName() {
            return displayName;
        }
    }

    public CorrelationMatch(String correlationId, CorrelationType type) {
        this.correlationId = correlationId;
        this.type = type;
        this.pane1Entries = new ArrayList<>();
        this.pane2Entries = new ArrayList<>();
        this.startTime = System.currentTimeMillis();
        this.endTime = System.currentTimeMillis();
    }

    public void addPane1Entry(LogEntry entry) {
        pane1Entries.add(entry);
    }

    public void addPane2Entry(LogEntry entry) {
        pane2Entries.add(entry);
    }

    public String getCorrelationId() {
        return correlationId;
    }

    public CorrelationType getType() {
        return type;
    }

    public List<LogEntry> getPane1Entries() {
        return pane1Entries;
    }

    public List<LogEntry> getPane2Entries() {
        return pane2Entries;
    }

    public int getTotalEntries() {
        return pane1Entries.size() + pane2Entries.size();
    }

    public boolean hasEntriesInBothPanes() {
        return !pane1Entries.isEmpty() && !pane2Entries.isEmpty();
    }

    public String getSummary() {
        return String.format("%s: %s (Pane1: %d, Pane2: %d)",
            type.getDisplayName(),
            correlationId,
            pane1Entries.size(),
            pane2Entries.size());
    }

    @Override
    public String toString() {
        return getSummary();
    }
}
----------------------------------------------------------------------

package com.logviewer.model;

/**
 * Represents a monitored environment
 */
public class Environment {
    private String name;
    private String color;
    private String logFilePath;
    private boolean autoRefresh;
    private int refreshInterval; // seconds
    private String status; // CONNECTED, DISCONNECTED, ERROR
    private int errorCount;
    private int warnCount;
    private int totalLines;

    public Environment(String name, String color) {
        this.name = name;
        this.color = color;
        this.status = "DISCONNECTED";
        this.autoRefresh = false;
        this.refreshInterval = 5;
        this.errorCount = 0;
        this.warnCount = 0;
        this.totalLines = 0;
    }

    // Getters and setters
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }

    public String getColor() { return color; }
    public void setColor(String color) { this.color = color; }

    public String getLogFilePath() { return logFilePath; }
    public void setLogFilePath(String logFilePath) { this.logFilePath = logFilePath; }

    public boolean isAutoRefresh() { return autoRefresh; }
    public void setAutoRefresh(boolean autoRefresh) { this.autoRefresh = autoRefresh; }

    public int getRefreshInterval() { return refreshInterval; }
    public void setRefreshInterval(int refreshInterval) { this.refreshInterval = refreshInterval; }

    public String getStatus() { return status; }
    public void setStatus(String status) { this.status = status; }

    public int getErrorCount() { return errorCount; }
    public void setErrorCount(int errorCount) { this.errorCount = errorCount; }

    public int getWarnCount() { return warnCount; }
    public void setWarnCount(int warnCount) { this.warnCount = warnCount; }

    public int getTotalLines() { return totalLines; }
    public void setTotalLines(int totalLines) { this.totalLines = totalLines; }
}
------------------------
package com.logviewer.model;

/**
 * Represents a configuration profile for a specific environment
 * Each profile contains AWS login details, kubectl config, and pod information
 */
public class EnvironmentProfile {

    private String profileName;           // e.g., "DEV", "STAGING", "PROD"
    private String awsLoginCommand;       // e.g., "pcl aws login --profile dev"
    private String kubectlContext;        // kubectl context for this env (fixed per environment)
    private String namespace;             // Default namespace
    private String defaultPodName;        // Optional default pod name
    private String defaultContainerName;  // Optional default container
    private int tailLines;                // Default tail lines
    private int refreshIntervalSeconds;   // Default log refresh interval (for downloading logs)
    private int sessionRefreshMinutes;    // AWS session refresh interval (default 20 mins)

    // Constructor
    public EnvironmentProfile() {
        this.tailLines = 1000;
        this.refreshIntervalSeconds = 30;
        this.sessionRefreshMinutes = 20;
        this.namespace = "default";
    }

    // Full constructor
    public EnvironmentProfile(String profileName) {
        this();
        this.profileName = profileName;
    }

    // Getters and Setters
    public String getProfileName() {
        return profileName;
    }

    public void setProfileName(String profileName) {
        this.profileName = profileName;
    }

    public String getAwsLoginCommand() {
        return awsLoginCommand;
    }

    public void setAwsLoginCommand(String awsLoginCommand) {
        this.awsLoginCommand = awsLoginCommand;
    }

    public String getKubectlContext() {
        return kubectlContext;
    }

    public void setKubectlContext(String kubectlContext) {
        this.kubectlContext = kubectlContext;
    }

    public String getNamespace() {
        return namespace;
    }

    public void setNamespace(String namespace) {
        this.namespace = namespace;
    }

    public String getDefaultPodName() {
        return defaultPodName;
    }

    public void setDefaultPodName(String defaultPodName) {
        this.defaultPodName = defaultPodName;
    }

    public String getDefaultContainerName() {
        return defaultContainerName;
    }

    public void setDefaultContainerName(String defaultContainerName) {
        this.defaultContainerName = defaultContainerName;
    }

    public int getTailLines() {
        return tailLines;
    }

    public void setTailLines(int tailLines) {
        this.tailLines = tailLines;
    }

    public int getRefreshIntervalSeconds() {
        return refreshIntervalSeconds;
    }

    public void setRefreshIntervalSeconds(int refreshIntervalSeconds) {
        this.refreshIntervalSeconds = refreshIntervalSeconds;
    }

    public int getSessionRefreshMinutes() {
        return sessionRefreshMinutes;
    }

    public void setSessionRefreshMinutes(int sessionRefreshMinutes) {
        this.sessionRefreshMinutes = sessionRefreshMinutes;
    }

    /**
     * Get a unique identifier for this profile
     */
    public String getProfileId() {
        return profileName.replaceAll("[^a-zA-Z0-9_-]", "_");
    }

    @Override
    public String toString() {
        return profileName;
    }

    /**
     * Create a copy of this profile
     */
    public EnvironmentProfile copy() {
        EnvironmentProfile copy = new EnvironmentProfile();
        copy.profileName = this.profileName;
        copy.awsLoginCommand = this.awsLoginCommand;
        copy.kubectlContext = this.kubectlContext;
        copy.namespace = this.namespace;
        copy.defaultPodName = this.defaultPodName;
        copy.defaultContainerName = this.defaultContainerName;
        copy.tailLines = this.tailLines;
        copy.refreshIntervalSeconds = this.refreshIntervalSeconds;
        copy.sessionRefreshMinutes = this.sessionRefreshMinutes;
        return copy;
    }
}
----------------------------
package com.logviewer.model;

import java.time.LocalDateTime;

/**
 * Encapsulates all filter criteria for log entries
 */
public class FilterCriteria {

    private String searchText;
    private boolean caseSensitive;
    private boolean includeError;
    private boolean includeWarn;
    private boolean includeInfo;
    private boolean includeDebug;
    private boolean includeTrace;
    private LocalDateTime dateFrom;
    private LocalDateTime dateTo;
    private String serviceFilter;

    public FilterCriteria() {
        this.searchText = "";
        this.caseSensitive = false;
        this.includeError = true;
        this.includeWarn = true;
        this.includeInfo = true;
        this.includeDebug = true;
        this.includeTrace = true;
        this.dateFrom = null;
        this.dateTo = null;
        this.serviceFilter = "";
    }

    // Getters and Setters
    public String getSearchText() {
        return searchText;
    }

    public void setSearchText(String searchText) {
        this.searchText = searchText;
    }

    public boolean isCaseSensitive() {
        return caseSensitive;
    }

    public void setCaseSensitive(boolean caseSensitive) {
        this.caseSensitive = caseSensitive;
    }

    public boolean isIncludeError() {
        return includeError;
    }

    public void setIncludeError(boolean includeError) {
        this.includeError = includeError;
    }

    public boolean isIncludeWarn() {
        return includeWarn;
    }

    public void setIncludeWarn(boolean includeWarn) {
        this.includeWarn = includeWarn;
    }

    public boolean isIncludeInfo() {
        return includeInfo;
    }

    public void setIncludeInfo(boolean includeInfo) {
        this.includeInfo = includeInfo;
    }

    public boolean isIncludeDebug() {
        return includeDebug;
    }

    public void setIncludeDebug(boolean includeDebug) {
        this.includeDebug = includeDebug;
    }

    public boolean isIncludeTrace() {
        return includeTrace;
    }

    public void setIncludeTrace(boolean includeTrace) {
        this.includeTrace = includeTrace;
    }

    public LocalDateTime getDateFrom() {
        return dateFrom;
    }

    public void setDateFrom(LocalDateTime dateFrom) {
        this.dateFrom = dateFrom;
    }

    public LocalDateTime getDateTo() {
        return dateTo;
    }

    public void setDateTo(LocalDateTime dateTo) {
        this.dateTo = dateTo;
    }

    public String getServiceFilter() {
        return serviceFilter;
    }

    public void setServiceFilter(String serviceFilter) {
        this.serviceFilter = serviceFilter;
    }

    public void reset() {
        this.searchText = "";
        this.caseSensitive = false;
        this.includeError = true;
        this.includeWarn = true;
        this.includeInfo = true;
        this.includeDebug = true;
        this.includeTrace = true;
        this.dateFrom = null;
        this.dateTo = null;
        this.serviceFilter = "";
    }
}
-----------------------------------------------------
package com.logviewer.model;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeParseException;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Represents a single log entry with parsed fields for efficient filtering and searching
 */
public class LogEntry {

    // Multiple patterns for different log formats
    private static final Pattern[] LOG_PATTERNS = {
        // Standard: 2024-01-15 10:30:45.123 ERROR [Service] Message
        Pattern.compile(
            "(\\d{4}-\\d{2}-\\d{2}[T\\s]\\d{2}:\\d{2}:\\d{2}[.,]\\d{3})\\s*" +
            "(?:\\[([^\\]]+)\\])?\\s*" +
            "(ERROR|WARN|WARNING|INFO|DEBUG|TRACE|FATAL)?\\s*" +
            "(?:\\[([^\\]]+)\\])?\\s*(.*)$"
        ),

        // Syslog: Jan 15 10:30:45 hostname service[123]: message
        Pattern.compile(
            "(\\w{3}\\s+\\d{1,2}\\s+\\d{2}:\\d{2}:\\d{2})\\s+" +
            "\\S+\\s+" +  // hostname
            "([^\\s\\[]+)(?:\\[\\d+\\])?:\\s+" +  // service
            "(ERROR|WARN|WARNING|INFO|DEBUG|TRACE)?\\s*(.*)$"
        ),

        // Apache/Nginx: 192.168.1.1 - - [15/Jan/2024:10:30:45 +0000] "GET /api" 200
        Pattern.compile(
            "^([\\d.]+)\\s+-\\s+-\\s+" +  // IP
            "\\[(\\d{2}/\\w{3}/\\d{4}:\\d{2}:\\d{2}:\\d{2}[^\\]]+)\\]\\s+" +  // timestamp
            "\"([^\"]+)\"\\s+" +  // request
            "(\\d{3})\\s*(.*)$"  // status code + rest
        ),

        // JSON-like: {"timestamp":"2024-01-15T10:30:45", "level":"ERROR", "message":"..."}
        Pattern.compile(
            ".*\"timestamp\"\\s*:\\s*\"([^\"]+)\".*" +
            "\"level\"\\s*:\\s*\"(ERROR|WARN|WARNING|INFO|DEBUG|TRACE)\".*" +
            "\"message\"\\s*:\\s*\"([^\"]+)\".*"
        ),

        // Log4j/Logback: [2024-01-15 10:30:45,123] ERROR com.example.Service - Message
        Pattern.compile(
            "\\[(\\d{4}-\\d{2}-\\d{2}\\s+\\d{2}:\\d{2}:\\d{2}[.,]\\d{3})\\]\\s+" +
            "(ERROR|WARN|WARNING|INFO|DEBUG|TRACE|FATAL)?\\s+" +
            "([\\w.]+)\\s+-\\s+(.*)$"
        ),

        // Simple: ERROR: Message or [ERROR] Message
        Pattern.compile(
            "(?:\\[)?(ERROR|WARN|WARNING|INFO|DEBUG|TRACE|FATAL)(?:\\])?:?\\s+(.*)$"
        ),

        // Docker: 2024-01-15T10:30:45.123456789Z [container-name] message
        Pattern.compile(
            "(\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d+Z)\\s+" +
            "(?:\\[([^\\]]+)\\])?\\s*(.*)$"
        ),

        // Kubernetes: I0115 10:30:45.123456 service.go:123] message
        Pattern.compile(
            "([IWEF])(\\d{4})\\s+(\\d{2}:\\d{2}:\\d{2}\\.\\d+)\\s+" +
            "([^\\s]+):\\d+\\]\\s+(.*)$"
        )
    };

    private static final DateTimeFormatter[] FORMATTERS = {
        // ISO formats
        DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss.SSS"),
        DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss,SSS"),
        DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm:ss.SSS"),
        DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm:ss,SSS"),
        DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm:ss.SSSSSS'Z'"),
        DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm:ss.SSSSSSSSS'Z'"),

        // Syslog format
        DateTimeFormatter.ofPattern("MMM d HH:mm:ss"),
        DateTimeFormatter.ofPattern("MMM dd HH:mm:ss"),

        // Apache/Nginx format
        DateTimeFormatter.ofPattern("dd/MMM/yyyy:HH:mm:ss Z"),

        // Alternative formats
        DateTimeFormatter.ofPattern("yyyy/MM/dd HH:mm:ss"),
        DateTimeFormatter.ofPattern("dd-MMM-yyyy HH:mm:ss.SSS")
    };

    private final long lineNumber;
    private final String rawLine;
    private LocalDateTime timestamp;
    private String level;
    private String service;
    private String thread;
    private String message;

    public LogEntry(long lineNumber, String rawLine) {
        this.lineNumber = lineNumber;
        this.rawLine = rawLine;
        parse();
    }

    private void parse() {
        boolean parsed = false;

        // Try each pattern until one matches
        for (Pattern pattern : LOG_PATTERNS) {
            Matcher matcher = pattern.matcher(rawLine);
            if (matcher.find()) {
                parsed = parseWithPattern(matcher, pattern);
                if (parsed) {
                    break;
                }
            }
        }

        // Fallback: treat entire line as INFO message
        if (!parsed) {
            this.level = "INFO";
            this.message = rawLine;
        }
    }

    private boolean parseWithPattern(Matcher matcher, Pattern pattern) {
        try {
            int groupCount = matcher.groupCount();

            // Try to extract timestamp (usually first group)
            if (groupCount >= 1 && matcher.group(1) != null) {
                String timestampStr = matcher.group(1);

                // Special handling for Kubernetes format (I0115)
                if (timestampStr.length() == 1 && "IWEF".contains(timestampStr)) {
                    // Kubernetes level: I=INFO, W=WARN, E=ERROR, F=FATAL
                    this.level = switch (timestampStr) {
                        case "I" -> "INFO";
                        case "W" -> "WARN";
                        case "E" -> "ERROR";
                        case "F" -> "FATAL";
                        default -> "INFO";
                    };
                    // For K8s, timestamp is in groups 2-3, combine them
                    if (groupCount >= 3 && matcher.group(2) != null && matcher.group(3) != null) {
                        timestampStr = matcher.group(2) + " " + matcher.group(3);
                        this.timestamp = parseTimestamp(timestampStr);
                    }
                } else {
                    this.timestamp = parseTimestamp(timestampStr);
                }
            }

            // Extract level (try different group positions)
            for (int i = 2; i <= Math.min(groupCount, 4); i++) {
                String levelCandidate = matcher.group(i);
                if (levelCandidate != null && isLogLevel(levelCandidate)) {
                    this.level = normalizeLevel(levelCandidate);
                    break;
                }
            }

            // Extract service/logger name
            for (int i = 2; i <= Math.min(groupCount, 4); i++) {
                String serviceCandidate = matcher.group(i);
                if (serviceCandidate != null && !isLogLevel(serviceCandidate)) {
                    this.service = serviceCandidate;
                    break;
                }
            }

            // Extract message (usually last group)
            if (groupCount >= 2) {
                String msg = matcher.group(groupCount);
                if (msg != null && !msg.trim().isEmpty()) {
                    this.message = msg;
                }
            }

            // Default level if not found
            if (this.level == null) {
                this.level = "INFO";
            }

            // Default message if not found
            if (this.message == null) {
                this.message = rawLine;
            }

            return true;
        } catch (Exception e) {
            return false;
        }
    }

    private boolean isLogLevel(String str) {
        return str != null && str.matches("(?i)(ERROR|WARN|WARNING|INFO|DEBUG|TRACE|FATAL|\\d{3})");
    }

    private String normalizeLevel(String level) {
        if (level == null) return "INFO";
        String upper = level.toUpperCase();

        // Normalize variants
        if (upper.equals("WARNING")) return "WARN";
        if (upper.matches("\\d{3}")) { // HTTP status code
            int code = Integer.parseInt(upper);
            if (code >= 500) return "ERROR";
            if (code >= 400) return "WARN";
            return "INFO";
        }

        return upper;
    }

    private LocalDateTime parseTimestamp(String timestampStr) {
        for (DateTimeFormatter formatter : FORMATTERS) {
            try {
                return LocalDateTime.parse(timestampStr, formatter);
            } catch (DateTimeParseException e) {
                // Try next formatter
            }
        }
        return null;
    }

    public boolean matches(String searchText, boolean caseSensitive) {
        if (searchText == null || searchText.isEmpty()) {
            return true;
        }

        String searchIn = caseSensitive ? rawLine : rawLine.toLowerCase();
        String searchFor = caseSensitive ? searchText : searchText.toLowerCase();

        return searchIn.contains(searchFor);
    }

    public boolean matchesFilters(
        boolean includeError, boolean includeWarn, boolean includeInfo,
        boolean includeDebug, boolean includeTrace,
        LocalDateTime dateFrom, LocalDateTime dateTo,
        String serviceFilter
    ) {
        // Level filter
        boolean levelMatch = switch (level) {
            case "ERROR", "FATAL" -> includeError;  // Treat FATAL as ERROR
            case "WARN", "WARNING" -> includeWarn;
            case "INFO" -> includeInfo;
            case "DEBUG" -> includeDebug;
            case "TRACE" -> includeTrace;
            default -> true;  // Unknown levels pass through
        };

        if (!levelMatch) {
            return false;
        }

        // Date range filter
        if (timestamp != null) {
            if (dateFrom != null && timestamp.isBefore(dateFrom)) {
                return false;
            }
            if (dateTo != null && timestamp.isAfter(dateTo.plusDays(1))) { // Include entire end date
                return false;
            }
        }

        // Service filter
        if (serviceFilter != null && !serviceFilter.isEmpty()) {
            if (service == null) {
                return false;
            }
            if (!service.toLowerCase().contains(serviceFilter.toLowerCase())) {
                return false;
            }
        }

        return true;
    }

    public String getFormattedLine() {
        return String.format("[%d] %s", lineNumber, rawLine);
    }

    public String getColorStyleClass() {
        return switch (level) {
            case "ERROR" -> "log-error";
            case "WARN" -> "log-warn";
            case "DEBUG" -> "log-debug";
            case "TRACE" -> "log-trace";
            default -> "log-info";
        };
    }

    // Getters
    public long getLineNumber() { return lineNumber; }
    public String getRawLine() { return rawLine; }
    public LocalDateTime getTimestamp() { return timestamp; }
    public String getLevel() { return level; }
    public String getService() { return service; }
    public String getThread() { return thread; }
    public String getMessage() { return message; }

    @Override
    public String toString() {
        return getFormattedLine();
    }
}
----------------------------------------
package com.logviewer.model;

import java.time.LocalDateTime;

/**
 * Represents a single event in a sequence diagram (service call, DB query, API call, etc.)
 */
public class SequenceEvent {
    private String requestId;
    private String fromService;
    private String toService;
    private String operation;
    private LocalDateTime startTime;
    private LocalDateTime endTime;
    private long durationMs;
    private String status; // SUCCESS, ERROR, TIMEOUT, etc.
    private String errorMessage;
    private String logLine;
    private int logLineNumber;

    public SequenceEvent() {
    }

    public SequenceEvent(String requestId, String fromService, String toService,
                        String operation, LocalDateTime startTime) {
        this.requestId = requestId;
        this.fromService = fromService;
        this.toService = toService;
        this.operation = operation;
        this.startTime = startTime;
        this.status = "SUCCESS";
    }

    // Getters and setters
    public String getRequestId() { return requestId; }
    public void setRequestId(String requestId) { this.requestId = requestId; }

    public String getFromService() { return fromService; }
    public void setFromService(String fromService) { this.fromService = fromService; }

    public String getToService() { return toService; }
    public void setToService(String toService) { this.toService = toService; }

    public String getOperation() { return operation; }
    public void setOperation(String operation) { this.operation = operation; }

    public LocalDateTime getStartTime() { return startTime; }
    public void setStartTime(LocalDateTime startTime) { this.startTime = startTime; }

    public LocalDateTime getEndTime() { return endTime; }
    public void setEndTime(LocalDateTime endTime) {
        this.endTime = endTime;
        if (startTime != null && endTime != null) {
            this.durationMs = java.time.Duration.between(startTime, endTime).toMillis();
        }
    }

    public long getDurationMs() { return durationMs; }
    public void setDurationMs(long durationMs) { this.durationMs = durationMs; }

    public String getStatus() { return status; }
    public void setStatus(String status) { this.status = status; }

    public String getErrorMessage() { return errorMessage; }
    public void setErrorMessage(String errorMessage) { this.errorMessage = errorMessage; }

    public String getLogLine() { return logLine; }
    public void setLogLine(String logLine) { this.logLine = logLine; }

    public int getLogLineNumber() { return logLineNumber; }
    public void setLogLineNumber(int logLineNumber) { this.logLineNumber = logLineNumber; }

    @Override
    public String toString() {
        return String.format("%s -> %s: %s (%dms) [%s]",
            fromService, toService, operation, durationMs, status);
    }
}
----------------------------------
package com.logviewer.model;

import java.time.LocalDateTime;

/**
 * Represents an extracted SQL query from logs
 */
public class SQLQueryInfo {
    private String query;
    private String queryType; // SELECT, INSERT, UPDATE, DELETE
    private LocalDateTime executionTime;
    private Long durationMs;
    private String requestId;
    private String threadId;
    private String logLine;
    private int lineNumber;
    private String status; // SUCCESS, ERROR, TIMEOUT
    private Integer rowCount;
    private String database;
    private String table;

    public SQLQueryInfo(String query) {
        this.query = query;
        this.queryType = determineQueryType(query);
        this.status = "UNKNOWN";
    }

    private String determineQueryType(String query) {
        String upperQuery = query.trim().toUpperCase();
        if (upperQuery.startsWith("SELECT")) return "SELECT";
        if (upperQuery.startsWith("INSERT")) return "INSERT";
        if (upperQuery.startsWith("UPDATE")) return "UPDATE";
        if (upperQuery.startsWith("DELETE")) return "DELETE";
        if (upperQuery.startsWith("CREATE")) return "CREATE";
        if (upperQuery.startsWith("ALTER")) return "ALTER";
        if (upperQuery.startsWith("DROP")) return "DROP";
        return "OTHER";
    }

    // Getters and setters
    public String getQuery() { return query; }
    public void setQuery(String query) { this.query = query; }

    public String getQueryType() { return queryType; }
    public void setQueryType(String queryType) { this.queryType = queryType; }

    public LocalDateTime getExecutionTime() { return executionTime; }
    public void setExecutionTime(LocalDateTime executionTime) { this.executionTime = executionTime; }

    public Long getDurationMs() { return durationMs; }
    public void setDurationMs(Long durationMs) { this.durationMs = durationMs; }

    public String getRequestId() { return requestId; }
    public void setRequestId(String requestId) { this.requestId = requestId; }

    public String getThreadId() { return threadId; }
    public void setThreadId(String threadId) { this.threadId = threadId; }

    public String getLogLine() { return logLine; }
    public void setLogLine(String logLine) { this.logLine = logLine; }

    public int getLineNumber() { return lineNumber; }
    public void setLineNumber(int lineNumber) { this.lineNumber = lineNumber; }

    public String getStatus() { return status; }
    public void setStatus(String status) { this.status = status; }

    public Integer getRowCount() { return rowCount; }
    public void setRowCount(Integer rowCount) { this.rowCount = rowCount; }

    public String getDatabase() { return database; }
    public void setDatabase(String database) { this.database = database; }

    public String getTable() { return table; }
    public void setTable(String table) { this.table = table; }

    public String getShortQuery() {
        if (query.length() > 80) {
            return query.substring(0, 80) + "...";
        }
        return query;
    }

    @Override
    public String toString() {
        return String.format("[%s] %s (%dms) - %s",
            queryType, getShortQuery(), durationMs != null ? durationMs : 0, status);
    }
}
---------------------------
package com.logviewer.service;

import javafx.concurrent.ScheduledService;
import javafx.concurrent.Task;
import javafx.util.Duration;

import java.io.File;
import java.util.function.Consumer;

/**
 * Scheduled service that periodically downloads logs from Kubernetes pods
 * and notifies listeners of new log files
 */
public class AutoRefreshLogService extends ScheduledService<File> {

    private final String awsLoginCommand;
    private final String password;
    private final String kubectlContext;
    private final String namespace;
    private final String podName;
    private final String containerName;
    private final String logPath;
    private final int tailLines;
    private final File downloadDirectory;
    private Consumer<File> onNewLogFile;

    private AutoRefreshLogService(Builder builder) {
        this.awsLoginCommand = builder.awsLoginCommand;
        this.password = builder.password;
        this.kubectlContext = builder.kubectlContext;
        this.namespace = builder.namespace;
        this.podName = builder.podName;
        this.containerName = builder.containerName;
        this.logPath = builder.logPath;
        this.tailLines = builder.tailLines;
        this.downloadDirectory = builder.downloadDirectory;
        this.onNewLogFile = builder.onNewLogFile;

        // Set refresh period (default 30 seconds)
        setPeriod(Duration.seconds(builder.refreshIntervalSeconds));
    }

    @Override
    protected Task<File> createTask() {
        LogDownloadService downloadTask = new LogDownloadService.Builder()
                .awsLoginCommand(awsLoginCommand)
                .password(password)
                .kubectlContext(kubectlContext)
                .namespace(namespace)
                .podName(podName)
                .containerName(containerName)
                .logPath(logPath)
                .tailLines(tailLines)
                .downloadDirectory(downloadDirectory)
                .build();

        // Notify on success
        downloadTask.setOnSucceeded(event -> {
            File logFile = downloadTask.getValue();
            if (onNewLogFile != null && logFile != null) {
                onNewLogFile.accept(logFile);
            }
        });

        return downloadTask;
    }

    public void setOnNewLogFile(Consumer<File> handler) {
        this.onNewLogFile = handler;
    }

    public static class Builder {
        private String awsLoginCommand;
        private String password;
        private String kubectlContext;
        private String namespace = "default";
        private String podName;
        private String containerName;
        private String logPath;
        private int tailLines = 1000;
        private int refreshIntervalSeconds = 30;
        private File downloadDirectory = new File(System.getProperty("user.home"), ".logviewer/downloads");
        private Consumer<File> onNewLogFile;

        public Builder awsLoginCommand(String awsLoginCommand) {
            this.awsLoginCommand = awsLoginCommand;
            return this;
        }

        public Builder password(String password) {
            this.password = password;
            return this;
        }

        public Builder kubectlContext(String kubectlContext) {
            this.kubectlContext = kubectlContext;
            return this;
        }

        public Builder namespace(String namespace) {
            this.namespace = namespace;
            return this;
        }

        public Builder podName(String podName) {
            this.podName = podName;
            return this;
        }

        public Builder containerName(String containerName) {
            this.containerName = containerName;
            return this;
        }

        public Builder logPath(String logPath) {
            this.logPath = logPath;
            return this;
        }

        public Builder tailLines(int tailLines) {
            this.tailLines = tailLines;
            return this;
        }

        public Builder refreshIntervalSeconds(int refreshIntervalSeconds) {
            this.refreshIntervalSeconds = refreshIntervalSeconds;
            return this;
        }

        public Builder downloadDirectory(File downloadDirectory) {
            this.downloadDirectory = downloadDirectory;
            return this;
        }

        public Builder onNewLogFile(Consumer<File> onNewLogFile) {
            this.onNewLogFile = onNewLogFile;
            return this;
        }

        public AutoRefreshLogService build() {
            if (podName == null || podName.isEmpty()) {
                throw new IllegalArgumentException("Pod name is required");
            }
            return new AutoRefreshLogService(this);
        }
    }
}
-------------------------------------------------------
package com.logviewer.service;

import com.logviewer.model.CorrelationMatch;
import com.logviewer.model.LogEntry;
import javafx.concurrent.Task;

import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Service to find correlated log entries across multiple log sources
 * Extracts and matches Request IDs, Transaction IDs, Session IDs, etc.
 */
public class CorrelationService extends Task<List<CorrelationMatch>> {

    private final List<LogEntry> pane1Entries;
    private final List<LogEntry> pane2Entries;

    // Common patterns for correlation IDs
    private static final Map<CorrelationMatch.CorrelationType, Pattern> ID_PATTERNS = Map.of(
        CorrelationMatch.CorrelationType.REQUEST_ID,
            Pattern.compile("(?:request[_-]?id|req[_-]?id|requestId)[:=\\s]+([a-zA-Z0-9\\-]+)", Pattern.CASE_INSENSITIVE),

        CorrelationMatch.CorrelationType.TRANSACTION_ID,
            Pattern.compile("(?:transaction[_-]?id|txn[_-]?id|transactionId|TXN)[:=\\s]+([a-zA-Z0-9\\-]+)", Pattern.CASE_INSENSITIVE),

        CorrelationMatch.CorrelationType.SESSION_ID,
            Pattern.compile("(?:session[_-]?id|sessionId)[:=\\s]+([a-zA-Z0-9\\-]+)", Pattern.CASE_INSENSITIVE),

        CorrelationMatch.CorrelationType.USER_ID,
            Pattern.compile("(?:user[_-]?id|userId|user)[:=\\s]+([a-zA-Z0-9@\\.\\-]+)", Pattern.CASE_INSENSITIVE),

        CorrelationMatch.CorrelationType.ORDER_ID,
            Pattern.compile("(?:order[_-]?id|orderId|ORDER)[:=\\s-]+([a-zA-Z0-9\\-]+)", Pattern.CASE_INSENSITIVE)
    );

    public CorrelationService(List<LogEntry> pane1Entries, List<LogEntry> pane2Entries) {
        this.pane1Entries = pane1Entries;
        this.pane2Entries = pane2Entries;
    }

    @Override
    protected List<CorrelationMatch> call() throws Exception {
        updateMessage("Analyzing correlation patterns...");
        updateProgress(0, 100);

        // Extract all IDs from both panes
        Map<String, CorrelationMatch> correlationMap = new HashMap<>();

        // Extract IDs from Pane 1
        updateMessage("Extracting IDs from Pane 1...");
        updateProgress(10, 100);
        extractIds(pane1Entries, correlationMap, true);

        // Extract IDs from Pane 2
        updateMessage("Extracting IDs from Pane 2...");
        updateProgress(50, 100);
        extractIds(pane2Entries, correlationMap, false);

        // Filter to only matches that appear in both panes
        updateMessage("Finding correlated entries...");
        updateProgress(80, 100);
        List<CorrelationMatch> results = correlationMap.values().stream()
            .filter(CorrelationMatch::hasEntriesInBothPanes)
            .sorted((a, b) -> Integer.compare(b.getTotalEntries(), a.getTotalEntries()))
            .toList();

        updateMessage(String.format("Found %d correlations", results.size()));
        updateProgress(100, 100);

        return results;
    }

    private void extractIds(List<LogEntry> entries, Map<String, CorrelationMatch> correlationMap, boolean isPane1) {
        int processed = 0;
        int total = entries.size();

        for (LogEntry entry : entries) {
            if (isCancelled()) {
                break;
            }

            String rawLine = entry.getRawLine();

            // Try each ID pattern
            for (Map.Entry<CorrelationMatch.CorrelationType, Pattern> patternEntry : ID_PATTERNS.entrySet()) {
                CorrelationMatch.CorrelationType type = patternEntry.getKey();
                Pattern pattern = patternEntry.getValue();

                Matcher matcher = pattern.matcher(rawLine);
                while (matcher.find()) {
                    String id = matcher.group(1);
                    if (id != null && !id.isEmpty()) {
                        String key = type.name() + ":" + id;

                        CorrelationMatch match = correlationMap.computeIfAbsent(
                            key,
                            k -> new CorrelationMatch(id, type)
                        );

                        if (isPane1) {
                            match.addPane1Entry(entry);
                        } else {
                            match.addPane2Entry(entry);
                        }
                    }
                }
            }

            processed++;
            if (processed % 1000 == 0) {
                double progress = isPane1 ? (processed * 40.0 / total) + 10 : (processed * 30.0 / total) + 50;
                updateProgress(progress, 100);
            }
        }
    }

    /**
     * Find correlation by specific ID value
     */
    public static CorrelationMatch findById(String id, List<LogEntry> pane1Entries, List<LogEntry> pane2Entries) {
        CorrelationMatch match = new CorrelationMatch(id, CorrelationMatch.CorrelationType.CUSTOM);

        for (LogEntry entry : pane1Entries) {
            if (entry.getRawLine().contains(id)) {
                match.addPane1Entry(entry);
            }
        }

        for (LogEntry entry : pane2Entries) {
            if (entry.getRawLine().contains(id)) {
                match.addPane2Entry(entry);
            }
        }

        return match;
    }

    /**
     * Extract all unique IDs of a specific type
     */
    public static Set<String> extractIdsOfType(List<LogEntry> entries, CorrelationMatch.CorrelationType type) {
        Set<String> ids = new HashSet<>();
        Pattern pattern = ID_PATTERNS.get(type);

        if (pattern == null) {
            return ids;
        }

        for (LogEntry entry : entries) {
            Matcher matcher = pattern.matcher(entry.getRawLine());
            while (matcher.find()) {
                String id = matcher.group(1);
                if (id != null && !id.isEmpty()) {
                    ids.add(id);
                }
            }
        }

        return ids;
    }
}
------------------------------
package com.logviewer.service;

import com.logviewer.model.LogEntry;

import java.time.LocalDateTime;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

/**
 * Extracts relevant context around a selected log entry
 */
public class LogContextExtractor {

    private static final Pattern REQUEST_ID_PATTERN = Pattern.compile(
        "(?:requestId|request-id|traceId|trace-id|correlationId|txnId|transaction-id)[=:\\s]+([a-zA-Z0-9-]+)",
        Pattern.CASE_INSENSITIVE);

    private static final Pattern THREAD_ID_PATTERN = Pattern.compile(
        "\\[([a-zA-Z0-9_-]+)\\]|Thread-\\d+|pool-\\d+-thread-\\d+");

    private static final Pattern USER_ID_PATTERN = Pattern.compile(
        "(?:userId|user-id|username)[=:\\s]+([a-zA-Z0-9@._-]+)",
        Pattern.CASE_INSENSITIVE);

    private static final Pattern ENDPOINT_PATTERN = Pattern.compile(
        "(?:GET|POST|PUT|DELETE|PATCH)\\s+(/[^\\s]+)",
        Pattern.CASE_INSENSITIVE);

    /**
     * Extract all context related to a specific log entry
     */
    public Map<String, Object> extractContext(LogEntry selectedEntry, List<LogEntry> allEntries, int selectedIndex) {
        Map<String, Object> context = new HashMap<>();

        // Extract identifiers from selected log
        String requestId = extractRequestId(selectedEntry.getFormattedLine());
        String threadId = extractThreadId(selectedEntry.getFormattedLine());
        String userId = extractUserId(selectedEntry.getFormattedLine());
        String endpoint = extractEndpoint(selectedEntry.getFormattedLine());

        context.put("selectedEntry", selectedEntry);
        context.put("selectedIndex", selectedIndex);
        context.put("requestId", requestId);
        context.put("threadId", threadId);
        context.put("userId", userId);
        context.put("endpoint", endpoint);

        // Find related entries by request ID
        List<LogEntry> relatedByRequestId = new ArrayList<>();
        if (requestId != null) {
            relatedByRequestId = findEntriesByRequestId(allEntries, requestId);
        }
        context.put("relatedByRequestId", relatedByRequestId);

        // Find related entries by thread
        List<LogEntry> relatedByThread = new ArrayList<>();
        if (threadId != null) {
            relatedByThread = findEntriesByThread(allEntries, threadId);
        }
        context.put("relatedByThread", relatedByThread);

        // Find entries within time window (Â±30 seconds)
        List<LogEntry> relatedByTime = findEntriesInTimeWindow(
            allEntries, selectedEntry.getTimestamp(), 30);
        context.put("relatedByTime", relatedByTime);

        // Find related errors and warnings
        List<LogEntry> relatedErrors = findRelatedErrors(allEntries, selectedEntry, requestId, threadId);
        context.put("relatedErrors", relatedErrors);

        // Find impact (what failed because of this)
        List<LogEntry> impactedEntries = findImpact(allEntries, selectedEntry, requestId);
        context.put("impactedEntries", impactedEntries);

        // Extract key data
        Map<String, String> keyData = extractKeyData(selectedEntry.getFormattedLine());
        context.put("keyData", keyData);

        // Statistics
        context.put("stats", generateStats(context));

        return context;
    }

    private String extractRequestId(String line) {
        Matcher matcher = REQUEST_ID_PATTERN.matcher(line);
        if (matcher.find()) {
            return matcher.group(1);
        }
        return null;
    }

    private String extractThreadId(String line) {
        Matcher matcher = THREAD_ID_PATTERN.matcher(line);
        if (matcher.find()) {
            return matcher.group(1) != null ? matcher.group(1) : matcher.group(0);
        }
        return null;
    }

    private String extractUserId(String line) {
        Matcher matcher = USER_ID_PATTERN.matcher(line);
        if (matcher.find()) {
            return matcher.group(1);
        }
        return null;
    }

    private String extractEndpoint(String line) {
        Matcher matcher = ENDPOINT_PATTERN.matcher(line);
        if (matcher.find()) {
            return matcher.group(1);
        }
        return null;
    }

    private List<LogEntry> findEntriesByRequestId(List<LogEntry> allEntries, String requestId) {
        return allEntries.stream()
            .filter(entry -> entry.getFormattedLine().contains(requestId))
            .collect(Collectors.toList());
    }

    private List<LogEntry> findEntriesByThread(List<LogEntry> allEntries, String threadId) {
        return allEntries.stream()
            .filter(entry -> entry.getFormattedLine().contains(threadId))
            .limit(1000) // Limit to avoid too many results
            .collect(Collectors.toList());
    }

    private List<LogEntry> findEntriesInTimeWindow(List<LogEntry> allEntries,
                                                   LocalDateTime centerTime,
                                                   int windowSeconds) {
        if (centerTime == null) {
            return new ArrayList<>();
        }

        LocalDateTime startTime = centerTime.minusSeconds(windowSeconds);
        LocalDateTime endTime = centerTime.plusSeconds(windowSeconds);

        return allEntries.stream()
            .filter(entry -> entry.getTimestamp() != null &&
                           entry.getTimestamp().isAfter(startTime) &&
                           entry.getTimestamp().isBefore(endTime))
            .collect(Collectors.toList());
    }

    private List<LogEntry> findRelatedErrors(List<LogEntry> allEntries, LogEntry selectedEntry,
                                            String requestId, String threadId) {
        List<LogEntry> errors = new ArrayList<>();

        for (LogEntry entry : allEntries) {
            String line = entry.getFormattedLine().toUpperCase();
            if (line.contains("ERROR") || line.contains("EXCEPTION") || line.contains("FATAL")) {
                // Check if it's related
                if (requestId != null && entry.getFormattedLine().contains(requestId)) {
                    errors.add(entry);
                } else if (threadId != null && entry.getFormattedLine().contains(threadId)) {
                    errors.add(entry);
                } else if (entry.getTimestamp() != null && selectedEntry.getTimestamp() != null) {
                    long diff = Math.abs(java.time.Duration.between(
                        selectedEntry.getTimestamp(), entry.getTimestamp()).toSeconds());
                    if (diff < 10) {
                        errors.add(entry);
                    }
                }
            }
        }

        return errors.stream()
            .distinct()
            .limit(50)
            .collect(Collectors.toList());
    }

    private List<LogEntry> findImpact(List<LogEntry> allEntries, LogEntry selectedEntry, String requestId) {
        if (requestId == null) {
            return new ArrayList<>();
        }

        LocalDateTime selectedTime = selectedEntry.getTimestamp();
        if (selectedTime == null) {
            return new ArrayList<>();
        }

        // Find subsequent failures in the same request
        return allEntries.stream()
            .filter(entry -> entry.getFormattedLine().contains(requestId))
            .filter(entry -> entry.getTimestamp() != null &&
                           entry.getTimestamp().isAfter(selectedTime))
            .filter(entry -> {
                String line = entry.getFormattedLine().toUpperCase();
                return line.contains("FAILED") || line.contains("ERROR") ||
                       line.contains("TIMEOUT") || line.contains("EXCEPTION");
            })
            .limit(20)
            .collect(Collectors.toList());
    }

    private Map<String, String> extractKeyData(String line) {
        Map<String, String> keyData = new LinkedHashMap<>();

        // Extract duration
        Pattern durationPattern = Pattern.compile("(\\d+)\\s*ms");
        Matcher durationMatcher = durationPattern.matcher(line);
        if (durationMatcher.find()) {
            keyData.put("Duration", durationMatcher.group(1) + " ms");
        }

        // Extract HTTP status
        Pattern statusPattern = Pattern.compile("\\b(\\d{3})\\b");
        Matcher statusMatcher = statusPattern.matcher(line);
        if (statusMatcher.find()) {
            String status = statusMatcher.group(1);
            if (status.matches("[2-5]\\d{2}")) {
                keyData.put("HTTP Status", status);
            }
        }

        // Extract service name
        Pattern servicePattern = Pattern.compile("\\[([A-Za-z0-9_-]+Service)\\]");
        Matcher serviceMatcher = servicePattern.matcher(line);
        if (serviceMatcher.find()) {
            keyData.put("Service", serviceMatcher.group(1));
        }

        return keyData;
    }

    private Map<String, Object> generateStats(Map<String, Object> context) {
        Map<String, Object> stats = new HashMap<>();

        @SuppressWarnings("unchecked")
        List<LogEntry> relatedByRequestId = (List<LogEntry>) context.get("relatedByRequestId");
        @SuppressWarnings("unchecked")
        List<LogEntry> relatedByThread = (List<LogEntry>) context.get("relatedByThread");
        @SuppressWarnings("unchecked")
        List<LogEntry> relatedByTime = (List<LogEntry>) context.get("relatedByTime");
        @SuppressWarnings("unchecked")
        List<LogEntry> relatedErrors = (List<LogEntry>) context.get("relatedErrors");
        @SuppressWarnings("unchecked")
        List<LogEntry> impactedEntries = (List<LogEntry>) context.get("impactedEntries");

        stats.put("totalRelatedByRequestId", relatedByRequestId.size());
        stats.put("totalRelatedByThread", relatedByThread.size());
        stats.put("totalInTimeWindow", relatedByTime.size());
        stats.put("totalRelatedErrors", relatedErrors.size());
        stats.put("totalImpacted", impactedEntries.size());

        return stats;
    }
}
-----------------------------------------
package com.logviewer.service;

import javafx.concurrent.Task;

import java.io.*;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.TimeUnit;

/**
 * Service for downloading logs from Kubernetes pods via AWS authentication
 * Executes: AWS PCL login -> kubectl commands -> log download
 */
public class LogDownloadService extends Task<File> {

    private final String awsLoginCommand;
    private final String password;
    private final String kubectlContext;
    private final String namespace;
    private final String podName;
    private final String containerName;
    private final String logPath; // Path inside container, or empty for stdout logs
    private final int tailLines;
    private final File downloadDirectory;

    private LogDownloadService(Builder builder) {
        this.awsLoginCommand = builder.awsLoginCommand;
        this.password = builder.password;
        this.kubectlContext = builder.kubectlContext;
        this.namespace = builder.namespace;
        this.podName = builder.podName;
        this.containerName = builder.containerName;
        this.logPath = builder.logPath;
        this.tailLines = builder.tailLines;
        this.downloadDirectory = builder.downloadDirectory;
    }

    @Override
    protected File call() throws Exception {
        updateMessage("Starting AWS authentication...");
        updateProgress(0, 4);

        // Step 1: Execute AWS PCL login
        if (awsLoginCommand != null && !awsLoginCommand.isEmpty()) {
            executeAwsLogin();
        }
        updateProgress(1, 4);

        // Step 2: Set kubectl context (if specified)
        if (kubectlContext != null && !kubectlContext.isEmpty()) {
            updateMessage("Setting kubectl context...");
            setKubectlContext();
        }
        updateProgress(2, 4);

        // Step 3: Download logs
        updateMessage("Downloading logs from pod...");
        File logFile = downloadLogs();
        updateProgress(3, 4);

        updateMessage("Log download completed");
        updateProgress(4, 4);

        return logFile;
    }

    private void executeAwsLogin() throws IOException, InterruptedException {
        updateMessage("Executing AWS login: " + awsLoginCommand);

        ProcessBuilder pb = new ProcessBuilder();

        // Split command into parts
        List<String> commandParts = parseCommand(awsLoginCommand);
        pb.command(commandParts);

        pb.redirectErrorStream(true);
        Process process = pb.start();

        StringBuilder output = new StringBuilder();
        boolean passwordSent = false;
        boolean mfaTokenSent = false;

        // Handle interactive prompts (password and MFA token)
        try (OutputStream os = process.getOutputStream();
             BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(os));
             BufferedReader reader = new BufferedReader(
                new InputStreamReader(process.getInputStream()))) {

            String line;
            while (process.isAlive() || reader.ready()) {
                // Read output line by line
                if (reader.ready()) {
                    line = reader.readLine();
                    if (line == null) break;

                    output.append(line).append("\n");
                    updateMessage("AWS Login: " + line);

                    String lowerLine = line.toLowerCase();

                    // Check if password is being requested
                    if (!passwordSent && (lowerLine.contains("password") || lowerLine.contains("enter"))) {
                        if (password != null && !password.isEmpty()) {
                            updateMessage("Sending password...");
                            writer.write(password);
                            writer.newLine();
                            writer.flush();
                            passwordSent = true;
                        }
                    }

                    // Check if MFA/token is being requested
                    if (passwordSent && !mfaTokenSent &&
                        (lowerLine.contains("token") || lowerLine.contains("mfa") ||
                         lowerLine.contains("code") || lowerLine.contains("verification"))) {

                        updateMessage("MFA token required. Please check your mobile device...");

                        // Prompt user for MFA token (this will be handled by the controller)
                        // For now, we'll throw an exception to indicate MFA is required
                        // The AutoRefreshController will catch this and show MFA dialog
                        throw new MfaRequiredException("MFA token required: " + line, process, writer, reader, output);
                    }
                }

                // Small delay to avoid busy waiting
                Thread.sleep(100);

                // Check for timeout
                if (!process.isAlive()) {
                    break;
                }
            }
        }

        boolean completed = process.waitFor(60, TimeUnit.SECONDS);
        if (!completed) {
            process.destroyForcibly();
            throw new IOException("AWS login command timed out");
        }

        if (process.exitValue() != 0) {
            throw new IOException("AWS login failed: " + output);
        }

        updateMessage("AWS authentication successful");
    }

    /**
     * Custom exception to signal that MFA token is required
     * Contains process handle so calling code can continue the authentication
     */
    public static class MfaRequiredException extends IOException {
        private final Process process;
        private final BufferedWriter writer;
        private final BufferedReader reader;
        private final StringBuilder output;

        public MfaRequiredException(String message, Process process,
                                   BufferedWriter writer, BufferedReader reader,
                                   StringBuilder output) {
            super(message);
            this.process = process;
            this.writer = writer;
            this.reader = reader;
            this.output = output;
        }

        /**
         * Continue authentication by sending MFA token
         */
        public void sendMfaToken(String mfaToken) throws IOException, InterruptedException {
            writer.write(mfaToken);
            writer.newLine();
            writer.flush();

            // Read remaining output
            String line;
            while ((line = reader.readLine()) != null) {
                output.append(line).append("\n");
            }

            boolean completed = process.waitFor(30, TimeUnit.SECONDS);
            if (!completed) {
                process.destroyForcibly();
                throw new IOException("AWS login timed out after MFA");
            }

            if (process.exitValue() != 0) {
                throw new IOException("AWS login failed after MFA: " + output);
            }
        }

        public Process getProcess() {
            return process;
        }

        public StringBuilder getOutput() {
            return output;
        }
    }

    private void setKubectlContext() throws IOException, InterruptedException {
        List<String> command = List.of("kubectl", "config", "use-context", kubectlContext);

        ProcessBuilder pb = new ProcessBuilder(command);
        pb.redirectErrorStream(true);
        Process process = pb.start();

        StringBuilder output = new StringBuilder();
        try (BufferedReader reader = new BufferedReader(
                new InputStreamReader(process.getInputStream()))) {
            String line;
            while ((line = reader.readLine()) != null) {
                output.append(line).append("\n");
            }
        }

        boolean completed = process.waitFor(30, TimeUnit.SECONDS);
        if (!completed) {
            process.destroyForcibly();
            throw new IOException("kubectl context switch timed out");
        }

        if (process.exitValue() != 0) {
            throw new IOException("Failed to set kubectl context: " + output);
        }
    }

    private File downloadLogs() throws IOException, InterruptedException {
        // Create download directory if it doesn't exist
        if (!downloadDirectory.exists()) {
            downloadDirectory.mkdirs();
        }

        // Generate filename with timestamp
        String timestamp = LocalDateTime.now().format(
            DateTimeFormatter.ofPattern("yyyyMMdd_HHmmss"));
        String fileName = String.format("%s_%s.log", podName, timestamp);
        File outputFile = new File(downloadDirectory, fileName);

        List<String> command = new ArrayList<>();
        command.add("kubectl");

        if (namespace != null && !namespace.isEmpty()) {
            command.add("-n");
            command.add(namespace);
        }

        if (logPath != null && !logPath.isEmpty()) {
            // Download log file from container filesystem
            command.add("exec");
            command.add(podName);

            if (containerName != null && !containerName.isEmpty()) {
                command.add("-c");
                command.add(containerName);
            }

            command.add("--");
            command.add("cat");
            command.add(logPath);
        } else {
            // Get container logs (stdout/stderr)
            command.add("logs");
            command.add(podName);

            if (containerName != null && !containerName.isEmpty()) {
                command.add("-c");
                command.add(containerName);
            }

            if (tailLines > 0) {
                command.add("--tail=" + tailLines);
            }
        }

        updateMessage("Executing: " + String.join(" ", command));

        ProcessBuilder pb = new ProcessBuilder(command);
        pb.redirectErrorStream(true);
        Process process = pb.start();

        // Read and write logs to file
        try (BufferedReader reader = new BufferedReader(
                new InputStreamReader(process.getInputStream(), StandardCharsets.UTF_8));
             BufferedWriter writer = new BufferedWriter(
                new FileWriter(outputFile, StandardCharsets.UTF_8))) {

            String line;
            int lineCount = 0;
            while ((line = reader.readLine()) != null) {
                writer.write(line);
                writer.newLine();
                lineCount++;

                if (lineCount % 1000 == 0) {
                    updateMessage(String.format("Downloaded %,d lines...", lineCount));
                }
            }

            updateMessage(String.format("Downloaded %,d lines total", lineCount));
        }

        boolean completed = process.waitFor(120, TimeUnit.SECONDS);
        if (!completed) {
            process.destroyForcibly();
            throw new IOException("kubectl command timed out");
        }

        if (process.exitValue() != 0) {
            if (outputFile.exists()) {
                // Read error from file
                String errorContent = Files.readString(outputFile.toPath());
                outputFile.delete();
                throw new IOException("kubectl command failed: " + errorContent);
            }
            throw new IOException("kubectl command failed with exit code: " + process.exitValue());
        }

        return outputFile;
    }

    private List<String> parseCommand(String command) {
        List<String> parts = new ArrayList<>();
        StringBuilder current = new StringBuilder();
        boolean inQuotes = false;

        for (char c : command.toCharArray()) {
            if (c == '"' || c == '\'') {
                inQuotes = !inQuotes;
            } else if (c == ' ' && !inQuotes) {
                if (current.length() > 0) {
                    parts.add(current.toString());
                    current = new StringBuilder();
                }
            } else {
                current.append(c);
            }
        }

        if (current.length() > 0) {
            parts.add(current.toString());
        }

        return parts;
    }

    // Builder pattern for configuration
    public static class Builder {
        private String awsLoginCommand;
        private String password;
        private String kubectlContext;
        private String namespace = "default";
        private String podName;
        private String containerName;
        private String logPath;
        private int tailLines = 1000;
        private File downloadDirectory = new File(System.getProperty("user.home"), ".logviewer/downloads");

        public Builder awsLoginCommand(String awsLoginCommand) {
            this.awsLoginCommand = awsLoginCommand;
            return this;
        }

        public Builder password(String password) {
            this.password = password;
            return this;
        }

        public Builder kubectlContext(String kubectlContext) {
            this.kubectlContext = kubectlContext;
            return this;
        }

        public Builder namespace(String namespace) {
            this.namespace = namespace;
            return this;
        }

        public Builder podName(String podName) {
            this.podName = podName;
            return this;
        }

        public Builder containerName(String containerName) {
            this.containerName = containerName;
            return this;
        }

        public Builder logPath(String logPath) {
            this.logPath = logPath;
            return this;
        }

        public Builder tailLines(int tailLines) {
            this.tailLines = tailLines;
            return this;
        }

        public Builder downloadDirectory(File downloadDirectory) {
            this.downloadDirectory = downloadDirectory;
            return this;
        }

        public LogDownloadService build() {
            if (podName == null || podName.isEmpty()) {
                throw new IllegalArgumentException("Pod name is required");
            }
            return new LogDownloadService(this);
        }
    }
}
--------------------------------
package com.logviewer.service;

import com.logviewer.model.LogEntry;
import javafx.concurrent.Task;

import java.io.*;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.atomic.AtomicLong;
import java.util.stream.Stream;

/**
 * Efficient log file loader that handles large files (up to 600MB) using streaming
 * and chunked processing
 */
public class LogFileLoader extends Task<List<LogEntry>> {

    private final File file;
    private final int bufferSize = 8192 * 8; // 64KB buffer for efficient reading

    public LogFileLoader(File file) {
        this.file = file;
    }

    @Override
    protected List<LogEntry> call() throws Exception {
        List<LogEntry> entries = new ArrayList<>();
        long fileSize = file.length();
        long bytesRead = 0;
        AtomicLong lineNumber = new AtomicLong(1);

        updateMessage("Loading file: " + file.getName());
        updateProgress(0, fileSize);

        try (BufferedReader reader = new BufferedReader(
                new InputStreamReader(new FileInputStream(file), StandardCharsets.UTF_8),
                bufferSize)) {

            String line;
            int batchSize = 10000; // Process in batches for better performance
            List<LogEntry> batch = new ArrayList<>(batchSize);

            while ((line = reader.readLine()) != null) {
                if (isCancelled()) {
                    updateMessage("Loading cancelled");
                    break;
                }

                // Create log entry
                LogEntry entry = new LogEntry(lineNumber.getAndIncrement(), line);
                batch.add(entry);

                // Add batch to main list periodically
                if (batch.size() >= batchSize) {
                    entries.addAll(batch);
                    batch.clear();

                    // Update progress
                    bytesRead += batchSize * 100; // Approximate
                    updateProgress(Math.min(bytesRead, fileSize), fileSize);
                    updateMessage(String.format("Loaded %,d lines...", entries.size()));
                }
            }

            // Add remaining entries
            if (!batch.isEmpty()) {
                entries.addAll(batch);
            }

            updateProgress(fileSize, fileSize);
            updateMessage(String.format("Loaded %,d lines from %s", entries.size(), file.getName()));
        }

        return entries;
    }

    /**
     * Quick count of lines in file for progress estimation
     */
    public static long countLines(File file) throws IOException {
        try (Stream<String> stream = Files.lines(file.toPath(), StandardCharsets.UTF_8)) {
            return stream.count();
        }
    }

    /**
     * Get file size in MB
     */
    public static double getFileSizeMB(File file) {
        return file.length() / (1024.0 * 1024.0);
    }
}
--------------------------------
package com.logviewer.service;

import com.logviewer.model.LogEntry;
import javafx.concurrent.Task;

import java.time.LocalDateTime;
import java.util.List;
import java.util.stream.Collectors;

/**
 * Fast search service using parallel streams for efficient searching
 * across large log datasets
 */
public class LogSearchService extends Task<List<LogEntry>> {

    private final List<LogEntry> allEntries;
    private final String searchText;
    private final boolean caseSensitive;
    private final boolean includeError;
    private final boolean includeWarn;
    private final boolean includeInfo;
    private final boolean includeDebug;
    private final boolean includeTrace;
    private final LocalDateTime dateFrom;
    private final LocalDateTime dateTo;
    private final String serviceFilter;

    public LogSearchService(
            List<LogEntry> allEntries,
            String searchText,
            boolean caseSensitive,
            boolean includeError,
            boolean includeWarn,
            boolean includeInfo,
            boolean includeDebug,
            boolean includeTrace,
            LocalDateTime dateFrom,
            LocalDateTime dateTo,
            String serviceFilter) {
        this.allEntries = allEntries;
        this.searchText = searchText;
        this.caseSensitive = caseSensitive;
        this.includeError = includeError;
        this.includeWarn = includeWarn;
        this.includeInfo = includeInfo;
        this.includeDebug = includeDebug;
        this.includeTrace = includeTrace;
        this.dateFrom = dateFrom;
        this.dateTo = dateTo;
        this.serviceFilter = serviceFilter;
    }

    @Override
    protected List<LogEntry> call() throws Exception {
        updateMessage("Searching...");
        updateProgress(-1, 1); // Indeterminate progress

        // Use parallel stream for fast searching
        List<LogEntry> results = allEntries.parallelStream()
                .filter(entry -> {
                    if (isCancelled()) {
                        return false;
                    }

                    // Apply search text filter
                    if (!entry.matches(searchText, caseSensitive)) {
                        return false;
                    }

                    // Apply level and date filters
                    return entry.matchesFilters(
                            includeError, includeWarn, includeInfo, includeDebug, includeTrace,
                            dateFrom, dateTo, serviceFilter
                    );
                })
                .collect(Collectors.toList());

        updateMessage(String.format("Found %,d matches", results.size()));
        updateProgress(1, 1);

        return results;
    }

    /**
     * Builder class for easier construction of search queries
     */
    public static class Builder {
        private List<LogEntry> allEntries;
        private String searchText = "";
        private boolean caseSensitive = false;
        private boolean includeError = true;
        private boolean includeWarn = true;
        private boolean includeInfo = true;
        private boolean includeDebug = true;
        private boolean includeTrace = true;
        private LocalDateTime dateFrom = null;
        private LocalDateTime dateTo = null;
        private String serviceFilter = "";

        public Builder allEntries(List<LogEntry> allEntries) {
            this.allEntries = allEntries;
            return this;
        }

        public Builder searchText(String searchText) {
            this.searchText = searchText;
            return this;
        }

        public Builder caseSensitive(boolean caseSensitive) {
            this.caseSensitive = caseSensitive;
            return this;
        }

        public Builder includeError(boolean includeError) {
            this.includeError = includeError;
            return this;
        }

        public Builder includeWarn(boolean includeWarn) {
            this.includeWarn = includeWarn;
            return this;
        }

        public Builder includeInfo(boolean includeInfo) {
            this.includeInfo = includeInfo;
            return this;
        }

        public Builder includeDebug(boolean includeDebug) {
            this.includeDebug = includeDebug;
            return this;
        }

        public Builder includeTrace(boolean includeTrace) {
            this.includeTrace = includeTrace;
            return this;
        }

        public Builder dateFrom(LocalDateTime dateFrom) {
            this.dateFrom = dateFrom;
            return this;
        }

        public Builder dateTo(LocalDateTime dateTo) {
            this.dateTo = dateTo;
            return this;
        }

        public Builder serviceFilter(String serviceFilter) {
            this.serviceFilter = serviceFilter;
            return this;
        }

        public LogSearchService build() {
            return new LogSearchService(
                    allEntries, searchText, caseSensitive,
                    includeError, includeWarn, includeInfo, includeDebug, includeTrace,
                    dateFrom, dateTo, serviceFilter
            );
        }
    }
}
------------------------------------
package com.logviewer.service;

import com.logviewer.model.EnvironmentProfile;

import java.io.*;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;
import java.util.stream.Collectors;

/**
 * Manages multiple environment profiles
 * Profiles are stored in ~/.logviewer/profiles/ directory
 */
public class ProfileManager {

    private static final String PROFILES_DIR = System.getProperty("user.home") +
        File.separator + ".logviewer" + File.separator + "profiles";

    /**
     * Save a profile to disk
     */
    public void saveProfile(EnvironmentProfile profile) throws IOException {
        ensureProfilesDirectoryExists();

        String fileName = profile.getProfileId() + ".properties";
        File file = new File(PROFILES_DIR, fileName);

        Properties props = new Properties();
        props.setProperty("profile.name", safeGet(profile.getProfileName()));
        props.setProperty("aws.login.command", safeGet(profile.getAwsLoginCommand()));
        props.setProperty("kubectl.context", safeGet(profile.getKubectlContext()));
        props.setProperty("namespace", safeGet(profile.getNamespace()));
        props.setProperty("default.pod.name", safeGet(profile.getDefaultPodName()));
        props.setProperty("default.container.name", safeGet(profile.getDefaultContainerName()));
        props.setProperty("tail.lines", String.valueOf(profile.getTailLines()));
        props.setProperty("refresh.interval", String.valueOf(profile.getRefreshIntervalSeconds()));
        props.setProperty("session.refresh.minutes", String.valueOf(profile.getSessionRefreshMinutes()));

        try (OutputStream os = new FileOutputStream(file)) {
            props.store(os, "Environment Profile: " + profile.getProfileName());
        }
    }

    /**
     * Load a profile from disk
     */
    public EnvironmentProfile loadProfile(String profileId) throws IOException {
        String fileName = profileId + ".properties";
        File file = new File(PROFILES_DIR, fileName);

        if (!file.exists()) {
            throw new IOException("Profile not found: " + profileId);
        }

        Properties props = new Properties();
        try (InputStream is = new FileInputStream(file)) {
            props.load(is);
        }

        EnvironmentProfile profile = new EnvironmentProfile();
        profile.setProfileName(props.getProperty("profile.name", ""));
        profile.setAwsLoginCommand(props.getProperty("aws.login.command", ""));
        profile.setKubectlContext(props.getProperty("kubectl.context", ""));
        profile.setNamespace(props.getProperty("namespace", "default"));
        profile.setDefaultPodName(props.getProperty("default.pod.name", ""));
        profile.setDefaultContainerName(props.getProperty("default.container.name", ""));
        profile.setTailLines(Integer.parseInt(props.getProperty("tail.lines", "1000")));
        profile.setRefreshIntervalSeconds(Integer.parseInt(props.getProperty("refresh.interval", "30")));
        profile.setSessionRefreshMinutes(Integer.parseInt(props.getProperty("session.refresh.minutes", "20")));

        return profile;
    }

    /**
     * List all available profiles
     */
    public List<EnvironmentProfile> listProfiles() throws IOException {
        ensureProfilesDirectoryExists();

        File dir = new File(PROFILES_DIR);
        File[] files = dir.listFiles((d, name) -> name.endsWith(".properties"));

        if (files == null || files.length == 0) {
            return new ArrayList<>();
        }

        List<EnvironmentProfile> profiles = new ArrayList<>();
        for (File file : files) {
            try {
                String profileId = file.getName().replace(".properties", "");
                EnvironmentProfile profile = loadProfile(profileId);
                profiles.add(profile);
            } catch (IOException e) {
                System.err.println("Failed to load profile: " + file.getName() + " - " + e.getMessage());
            }
        }

        // Sort by profile name
        profiles.sort(Comparator.comparing(EnvironmentProfile::getProfileName));

        return profiles;
    }

    /**
     * Delete a profile
     */
    public boolean deleteProfile(String profileId) {
        String fileName = profileId + ".properties";
        File file = new File(PROFILES_DIR, fileName);
        return file.exists() && file.delete();
    }

    /**
     * Check if a profile exists
     */
    public boolean profileExists(String profileId) {
        String fileName = profileId + ".properties";
        File file = new File(PROFILES_DIR, fileName);
        return file.exists();
    }

    // Utility methods

    private void ensureProfilesDirectoryExists() throws IOException {
        Path dirPath = Paths.get(PROFILES_DIR);
        if (!Files.exists(dirPath)) {
            Files.createDirectories(dirPath);
        }
    }

    private String safeGet(String value) {
        return value != null ? value : "";
    }
}
----------------------------------------
package com.logviewer.service;

import com.logviewer.model.LogEntry;
import com.logviewer.model.SequenceEvent;

import java.time.LocalDateTime;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Analyzes logs to build sequence diagrams showing service-to-service interactions
 */
public class SequenceDiagramAnalyzer {

    // Patterns to extract service calls
    private static final Pattern HTTP_CALL_PATTERN = Pattern.compile(
        "(GET|POST|PUT|DELETE|PATCH)\\s+([^\\s]+).*?(\\d+)ms", Pattern.CASE_INSENSITIVE);

    private static final Pattern SERVICE_CALL_PATTERN = Pattern.compile(
        "(?:Calling|Invoking|Requesting)\\s+([A-Za-z0-9_-]+)(?:Service|\\.)", Pattern.CASE_INSENSITIVE);

    private static final Pattern DB_QUERY_PATTERN = Pattern.compile(
        "(SELECT|INSERT|UPDATE|DELETE)\\s+.*?(?:FROM|INTO)\\s+([A-Za-z0-9_]+)", Pattern.CASE_INSENSITIVE);

    private static final Pattern RESPONSE_PATTERN = Pattern.compile(
        "(?:Response|Received|Completed).*?(\\d+)\\s*ms", Pattern.CASE_INSENSITIVE);

    private static final Pattern REQUEST_ID_PATTERN = Pattern.compile(
        "(?:requestId|request-id|traceId|trace-id|correlationId)[=:\\s]+([a-zA-Z0-9-]+)", Pattern.CASE_INSENSITIVE);

    /**
     * Analyze logs and build sequence events
     */
    public Map<String, List<SequenceEvent>> analyzeSequence(List<LogEntry> logEntries) {
        Map<String, List<SequenceEvent>> sequencesByRequestId = new HashMap<>();
        Map<String, SequenceEvent> pendingEvents = new HashMap<>();

        for (int i = 0; i < logEntries.size(); i++) {
            LogEntry entry = logEntries.get(i);
            String line = entry.getFormattedLine();

            // Extract request ID
            String requestId = extractRequestId(line);
            if (requestId == null) {
                requestId = "unknown-" + (i / 10); // Group by chunks if no request ID
            }

            // Extract service name
            String serviceName = extractServiceName(line);

            // Check for HTTP calls
            Matcher httpMatcher = HTTP_CALL_PATTERN.matcher(line);
            if (httpMatcher.find()) {
                SequenceEvent event = new SequenceEvent();
                event.setRequestId(requestId);
                event.setFromService(serviceName);
                event.setToService(extractTargetService(httpMatcher.group(2)));
                event.setOperation(httpMatcher.group(1) + " " + httpMatcher.group(2));
                event.setStartTime(entry.getTimestamp());
                event.setDurationMs(Long.parseLong(httpMatcher.group(3)));
                event.setLogLine(line);
                event.setLogLineNumber(i);

                if (line.toUpperCase().contains("ERROR") || line.contains("500") || line.contains("404")) {
                    event.setStatus("ERROR");
                    event.setErrorMessage(extractErrorMessage(line));
                } else {
                    event.setStatus("SUCCESS");
                }

                addEvent(sequencesByRequestId, requestId, event);
            }

            // Check for service calls
            Matcher serviceMatcher = SERVICE_CALL_PATTERN.matcher(line);
            if (serviceMatcher.find()) {
                String key = requestId + "-" + i;
                SequenceEvent event = new SequenceEvent();
                event.setRequestId(requestId);
                event.setFromService(serviceName);
                event.setToService(serviceMatcher.group(1) + "Service");
                event.setOperation("Service Call");
                event.setStartTime(entry.getTimestamp());
                event.setLogLine(line);
                event.setLogLineNumber(i);

                pendingEvents.put(key, event);
            }

            // Check for database queries
            Matcher dbMatcher = DB_QUERY_PATTERN.matcher(line);
            if (dbMatcher.find()) {
                SequenceEvent event = new SequenceEvent();
                event.setRequestId(requestId);
                event.setFromService(serviceName);
                event.setToService("Database");
                event.setOperation(dbMatcher.group(1) + " " + dbMatcher.group(2));
                event.setStartTime(entry.getTimestamp());
                event.setLogLine(line);
                event.setLogLineNumber(i);

                // Extract duration if available
                Matcher durationMatcher = Pattern.compile("(\\d+)\\s*ms").matcher(line);
                if (durationMatcher.find()) {
                    event.setDurationMs(Long.parseLong(durationMatcher.group(1)));
                } else {
                    event.setDurationMs(0);
                }

                if (line.toUpperCase().contains("ERROR") || line.contains("FAILED")) {
                    event.setStatus("ERROR");
                    event.setErrorMessage(extractErrorMessage(line));
                } else {
                    event.setStatus("SUCCESS");
                }

                addEvent(sequencesByRequestId, requestId, event);
            }

            // Check for responses to complete pending events
            Matcher responseMatcher = RESPONSE_PATTERN.matcher(line);
            if (responseMatcher.find() && !pendingEvents.isEmpty()) {
                // Try to find matching pending event
                for (String key : new ArrayList<>(pendingEvents.keySet())) {
                    if (key.startsWith(requestId)) {
                        SequenceEvent event = pendingEvents.remove(key);
                        event.setDurationMs(Long.parseLong(responseMatcher.group(1)));
                        event.setEndTime(entry.getTimestamp());

                        if (line.toUpperCase().contains("ERROR")) {
                            event.setStatus("ERROR");
                            event.setErrorMessage(extractErrorMessage(line));
                        }

                        addEvent(sequencesByRequestId, requestId, event);
                        break;
                    }
                }
            }
        }

        // Add any remaining pending events
        for (SequenceEvent event : pendingEvents.values()) {
            if (event.getDurationMs() == 0) {
                event.setDurationMs(50); // Default duration
            }
            addEvent(sequencesByRequestId, event.getRequestId(), event);
        }

        return sequencesByRequestId;
    }

    private void addEvent(Map<String, List<SequenceEvent>> map, String requestId, SequenceEvent event) {
        map.computeIfAbsent(requestId, k -> new ArrayList<>()).add(event);
    }

    private String extractRequestId(String line) {
        Matcher matcher = REQUEST_ID_PATTERN.matcher(line);
        if (matcher.find()) {
            return matcher.group(1);
        }
        return null;
    }

    private String extractServiceName(String line) {
        // Try to extract service name from log line
        Pattern servicePattern = Pattern.compile("\\[([A-Za-z0-9_-]+Service)\\]");
        Matcher matcher = servicePattern.matcher(line);
        if (matcher.find()) {
            return matcher.group(1);
        }

        // Try package name
        Pattern packagePattern = Pattern.compile("com\\.logviewer\\.([a-z]+)\\.");
        matcher = packagePattern.matcher(line);
        if (matcher.find()) {
            return matcher.group(1) + "Service";
        }

        return "Application";
    }

    private String extractTargetService(String endpoint) {
        // Extract service name from endpoint URL
        String[] parts = endpoint.split("/");
        for (String part : parts) {
            if (!part.isEmpty() && part.matches("[a-zA-Z][a-zA-Z0-9_-]*")) {
                return part + "Service";
            }
        }
        return "ExternalService";
    }

    private String extractErrorMessage(String line) {
        // Try to extract error message
        if (line.contains(":")) {
            String[] parts = line.split(":", 2);
            if (parts.length > 1) {
                String msg = parts[1].trim();
                return msg.length() > 100 ? msg.substring(0, 100) + "..." : msg;
            }
        }
        return "Error occurred";
    }

    /**
     * Get all unique services from sequence events
     */
    public Set<String> extractServices(List<SequenceEvent> events) {
        Set<String> services = new LinkedHashSet<>();
        for (SequenceEvent event : events) {
            if (event.getFromService() != null) services.add(event.getFromService());
            if (event.getToService() != null) services.add(event.getToService());
        }
        return services;
    }
}
------------------------------------
package com.logviewer.service;

import com.logviewer.model.LogEntry;
import com.logviewer.model.SQLQueryInfo;

import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Extracts SQL queries from log entries
 */
public class SQLQueryExtractor {

    // Patterns to match SQL queries in logs
    private static final Pattern SQL_PATTERN = Pattern.compile(
        "(SELECT|INSERT|UPDATE|DELETE|CREATE|ALTER|DROP)\\s+.*?(?:FROM|INTO|TABLE|SET|WHERE|GROUP|ORDER|LIMIT|;|$)",
        Pattern.CASE_INSENSITIVE | Pattern.DOTALL
    );

    private static final Pattern DURATION_PATTERN = Pattern.compile("(\\d+)\\s*ms");
    private static final Pattern ROW_COUNT_PATTERN = Pattern.compile("(\\d+)\\s*row");
    private static final Pattern REQUEST_ID_PATTERN = Pattern.compile(
        "(?:requestId|request-id|traceId)[=:\\s]+([a-zA-Z0-9-]+)",
        Pattern.CASE_INSENSITIVE
    );

    /**
     * Extract all SQL queries from log entries
     */
    public List<SQLQueryInfo> extractQueries(List<LogEntry> logEntries) {
        List<SQLQueryInfo> queries = new ArrayList<>();

        for (int i = 0; i < logEntries.size(); i++) {
            LogEntry entry = logEntries.get(i);
            String line = entry.getFormattedLine();

            // Find SQL queries in the log line
            Matcher sqlMatcher = SQL_PATTERN.matcher(line);

            while (sqlMatcher.find()) {
                String query = sqlMatcher.group().trim();

                // Clean up query
                query = cleanQuery(query);

                if (query.length() > 10) { // Minimum query length
                    SQLQueryInfo queryInfo = new SQLQueryInfo(query);
                    queryInfo.setExecutionTime(entry.getTimestamp());
                    queryInfo.setLogLine(line);
                    queryInfo.setLineNumber(i + 1);

                    // Extract additional info
                    extractDuration(line, queryInfo);
                    extractRequestId(line, queryInfo);
                    extractStatus(line, queryInfo);
                    extractRowCount(line, queryInfo);
                    extractTableInfo(query, queryInfo);

                    queries.add(queryInfo);
                }
            }
        }

        return queries;
    }

    private String cleanQuery(String query) {
        // Remove trailing punctuation and whitespace
        query = query.replaceAll("[;,]$", "").trim();

        // Replace multiple spaces with single space
        query = query.replaceAll("\\s+", " ");

        // Remove newlines
        query = query.replace("\n", " ").replace("\r", " ");

        return query;
    }

    private void extractDuration(String line, SQLQueryInfo queryInfo) {
        Matcher matcher = DURATION_PATTERN.matcher(line);
        if (matcher.find()) {
            try {
                queryInfo.setDurationMs(Long.parseLong(matcher.group(1)));
            } catch (NumberFormatException e) {
                // Ignore
            }
        }
    }

    private void extractRequestId(String line, SQLQueryInfo queryInfo) {
        Matcher matcher = REQUEST_ID_PATTERN.matcher(line);
        if (matcher.find()) {
            queryInfo.setRequestId(matcher.group(1));
        }
    }

    private void extractStatus(String line, SQLQueryInfo queryInfo) {
        String upperLine = line.toUpperCase();
        if (upperLine.contains("ERROR") || upperLine.contains("FAILED")) {
            queryInfo.setStatus("ERROR");
        } else if (upperLine.contains("TIMEOUT")) {
            queryInfo.setStatus("TIMEOUT");
        } else if (upperLine.contains("SUCCESS") || upperLine.contains("COMPLETED")) {
            queryInfo.setStatus("SUCCESS");
        }
    }

    private void extractRowCount(String line, SQLQueryInfo queryInfo) {
        Matcher matcher = ROW_COUNT_PATTERN.matcher(line);
        if (matcher.find()) {
            try {
                queryInfo.setRowCount(Integer.parseInt(matcher.group(1)));
            } catch (NumberFormatException e) {
                // Ignore
            }
        }
    }

    private void extractTableInfo(String query, SQLQueryInfo queryInfo) {
        String upperQuery = query.toUpperCase();

        // Extract table name from FROM clause
        Pattern fromPattern = Pattern.compile("FROM\\s+([a-zA-Z0-9_]+)", Pattern.CASE_INSENSITIVE);
        Matcher fromMatcher = fromPattern.matcher(query);
        if (fromMatcher.find()) {
            queryInfo.setTable(fromMatcher.group(1));
        }

        // Extract table name from INTO clause
        Pattern intoPattern = Pattern.compile("INTO\\s+([a-zA-Z0-9_]+)", Pattern.CASE_INSENSITIVE);
        Matcher intoMatcher = intoPattern.matcher(query);
        if (intoMatcher.find()) {
            queryInfo.setTable(intoMatcher.group(1));
        }

        // Extract table name from UPDATE clause
        Pattern updatePattern = Pattern.compile("UPDATE\\s+([a-zA-Z0-9_]+)", Pattern.CASE_INSENSITIVE);
        Matcher updateMatcher = updatePattern.matcher(query);
        if (updateMatcher.find()) {
            queryInfo.setTable(updateMatcher.group(1));
        }
    }

    /**
     * Get query statistics
     */
    public Map<String, Object> getStatistics(List<SQLQueryInfo> queries) {
        Map<String, Object> stats = new HashMap<>();

        int totalQueries = queries.size();
        int selectCount = 0;
        int insertCount = 0;
        int updateCount = 0;
        int deleteCount = 0;
        long totalDuration = 0;
        int errorCount = 0;

        for (SQLQueryInfo query : queries) {
            switch (query.getQueryType()) {
                case "SELECT": selectCount++; break;
                case "INSERT": insertCount++; break;
                case "UPDATE": updateCount++; break;
                case "DELETE": deleteCount++; break;
            }

            if (query.getDurationMs() != null) {
                totalDuration += query.getDurationMs();
            }

            if ("ERROR".equals(query.getStatus()) || "TIMEOUT".equals(query.getStatus())) {
                errorCount++;
            }
        }

        stats.put("totalQueries", totalQueries);
        stats.put("selectCount", selectCount);
        stats.put("insertCount", insertCount);
        stats.put("updateCount", updateCount);
        stats.put("deleteCount", deleteCount);
        stats.put("totalDuration", totalDuration);
        stats.put("avgDuration", totalQueries > 0 ? totalDuration / totalQueries : 0);
        stats.put("errorCount", errorCount);

        return stats;
    }
}
---------------------------------
package com.logviewer.ui;

import javafx.scene.control.ListCell;
import javafx.scene.paint.Color;
import javafx.scene.text.Font;

public class ColoredLogCell extends ListCell<String> {

    // Static trace ID for highlighting across all cells
    private static String highlightTraceId = null;

    public static void setHighlightTraceId(String traceId) {
        highlightTraceId = traceId;
    }

    public static String getHighlightTraceId() {
        return highlightTraceId;
    }

    @Override
    protected void updateItem(String item, boolean empty) {
        super.updateItem(item, empty);

        if (empty || item == null) {
            setText(null);
            setStyle("");
        } else {
            setText(item);
            setFont(Font.font("Consolas", 11));

            // Apply color based on log level and content type
            String style = "";
            String trimmedItem = item.trim();
            String upperItem = item.toUpperCase();

            // Check for trace ID highlighting first (highest priority)
            boolean containsTraceId = highlightTraceId != null && !highlightTraceId.isEmpty() &&
                                      item.contains(highlightTraceId);

            if (containsTraceId) {
                // Bright yellow/gold highlighting for trace ID matches
                style = "-fx-background-color: #fff9c4; -fx-text-fill: #000000; -fx-font-weight: bold; -fx-border-color: #fbc02d; -fx-border-width: 0 0 0 5;";
            } // Check for stack trace lines (starts with "at " or "Caused by:")
            else if (isStackTraceLine(trimmedItem)) {
                if (trimmedItem.startsWith("Caused by:") || trimmedItem.startsWith("caused by:")) {
                    // Root cause - highlight in bold red
                    style = "-fx-background-color: #ffe0e0; -fx-text-fill: #d32f2f; -fx-font-weight: bold; -fx-border-color: #e57373; -fx-border-width: 0 0 0 3;";
                } else if (trimmedItem.startsWith("at ") || trimmedItem.startsWith("\tat ")) {
                    // Stack trace line - light red/pink background
                    style = "-fx-background-color: #fff5f5; -fx-text-fill: #c62828; -fx-border-color: #ffcdd2; -fx-border-width: 0 0 0 2;";
                } else {
                    // Exception class line (e.g., "java.lang.NullPointerException: ...")
                    style = "-fx-background-color: #ffebee; -fx-text-fill: #b71c1c; -fx-font-weight: bold; -fx-border-color: #ef5350; -fx-border-width: 0 0 0 4;";
                }
            } else if (upperItem.contains("ERROR")) {
                // Red background for errors
                style = "-fx-background-color: #ffebee; -fx-text-fill: #c62828; -fx-font-weight: bold;";
            } else if (upperItem.contains("WARN")) {
                // Orange/yellow background for warnings
                style = "-fx-background-color: #fff8e1; -fx-text-fill: #f57c00; -fx-font-weight: bold;";
            } else if (upperItem.contains("INFO")) {
                // Light blue background for info
                style = "-fx-background-color: #e3f2fd; -fx-text-fill: #1565c0;";
            } else if (upperItem.contains("DEBUG")) {
                // Gray for debug
                style = "-fx-background-color: #f5f5f5; -fx-text-fill: #757575;";
            } else if (upperItem.contains("TRACE")) {
                // Very light gray for trace
                style = "-fx-background-color: #fafafa; -fx-text-fill: #9e9e9e;";
            } else if (upperItem.contains("EXCEPTION") || upperItem.contains("FATAL")) {
                // Dark red for exceptions/fatal
                style = "-fx-background-color: #ffcdd2; -fx-text-fill: #b71c1c; -fx-font-weight: bold;";
            } else {
                // Default styling
                style = "-fx-text-fill: #333333;";
            }

            setStyle(style);
        }
    }

    /**
     * Detects if a line is part of a Java stack trace
     */
    private boolean isStackTraceLine(String line) {
        if (line == null || line.isEmpty()) {
            return false;
        }

        // Stack trace patterns:
        // - "at com.example.ClassName.methodName(FileName.java:123)"
        // - "Caused by: java.lang.Exception: message"
        // - Exception class names (e.g., "java.lang.NullPointerException: message")

        return line.startsWith("at ") ||
               line.startsWith("\tat ") ||
               line.startsWith("Caused by:") ||
               line.startsWith("caused by:") ||
               (line.contains("Exception:") && (line.contains("java.") || line.contains("org.") || line.contains("com."))) ||
               (line.contains("Exception ") && line.contains("at ")) ||
               line.matches(".*Exception.*:.*") ||
               line.contains("... ") && line.contains(" more");
    }
}
--------------------------------------------------------------------------
package com.logviewer;

import com.logviewer.model.EnvironmentProfile;
import com.logviewer.model.LogEntry;
import com.logviewer.service.AutoRefreshLogService;
import com.logviewer.service.LogFileLoader;
import com.logviewer.service.LogDownloadService;
import com.logviewer.service.ProfileManager;
import javafx.application.Platform;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.fxml.FXML;
import javafx.scene.control.*;
import javafx.stage.FileChooser;

import java.io.*;
import java.nio.file.Files;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.Properties;
import java.util.concurrent.TimeUnit;

/**
 * Controller for Auto-Refresh Log Viewer
 * Manages AWS authentication, kubectl commands, and scheduled log downloads
 */
public class AutoRefreshController {

    // Profile Management
    @FXML private ComboBox<EnvironmentProfile> profileComboBox;
    @FXML private Button saveProfileButton;
    @FXML private Button deleteProfileButton;
    @FXML private Button newProfileButton;
    @FXML private TextField profileNameField;

    // Auto-load to main window
    @FXML private CheckBox autoLoadToMainWindowCheck;
    @FXML private RadioButton loadToPane1Radio;
    @FXML private RadioButton loadToPane2Radio;

    // Reference to main controller
    private MainController mainController;

    // AWS Authentication
    @FXML private TextField awsLoginCommandField;
    @FXML private Button loginToAwsButton;
    @FXML private Spinner<Integer> sessionRefreshSpinner;
    @FXML private CheckBox autoRefreshSessionCheck;

    // Kubernetes Configuration
    @FXML private TextField kubectlContextField;
    @FXML private TextField namespaceField;
    @FXML private TextField podNameField;
    @FXML private TextField containerNameField;

    // Log Configuration
    @FXML private RadioButton stdoutLogRadio;
    @FXML private RadioButton fileLogRadio;
    @FXML private TextField logPathField;
    @FXML private Spinner<Integer> tailLinesSpinner;
    @FXML private Spinner<Integer> refreshIntervalSpinner;

    // Control Buttons
    @FXML private Button startButton;
    @FXML private Button stopButton;

    // Status
    @FXML private Label statusLabel;
    @FXML private Label progressLabel;
    @FXML private ProgressBar progressBar;
    @FXML private Label lastUpdateLabel;

    // Log Display
    @FXML private ListView<String> logListView;
    @FXML private TextField searchField;
    @FXML private CheckBox errorCheckBox;
    @FXML private CheckBox warnCheckBox;
    @FXML private CheckBox infoCheckBox;
    @FXML private CheckBox debugCheckBox;
    @FXML private CheckBox traceCheckBox;
    @FXML private Label resultCountLabel;
    @FXML private Label currentFileLabel;

    // Data
    private ProfileManager profileManager;
    private EnvironmentProfile currentProfile;
    private AutoRefreshLogService autoRefreshService;
    private List<LogEntry> allEntries = new ArrayList<>();
    private List<LogEntry> filteredEntries = new ArrayList<>();
    private File currentLogFile;
    private javafx.animation.Timeline sessionRefreshTimer;

    @FXML
    public void initialize() {
        // Initialize profile manager
        profileManager = new ProfileManager();

        // Set up spinners
        tailLinesSpinner.setValueFactory(
            new SpinnerValueFactory.IntegerSpinnerValueFactory(100, 50000, 1000, 100));
        refreshIntervalSpinner.setValueFactory(
            new SpinnerValueFactory.IntegerSpinnerValueFactory(5, 600, 30, 5));
        sessionRefreshSpinner.setValueFactory(
            new SpinnerValueFactory.IntegerSpinnerValueFactory(1, 120, 20, 1));

        // Set up log source radio buttons
        stdoutLogRadio.selectedProperty().addListener((obs, oldVal, newVal) -> {
            logPathField.setDisable(newVal);
        });

        // Set up pane selection radio buttons
        ToggleGroup paneGroup = new ToggleGroup();
        loadToPane1Radio.setToggleGroup(paneGroup);
        loadToPane2Radio.setToggleGroup(paneGroup);
        loadToPane1Radio.setSelected(true);

        // Set up profile combo box
        setupProfileComboBox();
        loadProfiles();

        // Set up list view
        setupListView();

        // Set up tooltips
        awsLoginCommandField.setTooltip(new Tooltip("AWS login command (e.g., pcl aws login)"));
        loginToAwsButton.setTooltip(new Tooltip("Launch command prompt for interactive AWS login"));
        sessionRefreshSpinner.setTooltip(new Tooltip("Auto re-login interval in minutes (to keep session alive)"));
        kubectlContextField.setTooltip(new Tooltip("kubectl context - fixed per environment"));
        podNameField.setTooltip(new Tooltip("Pod name to download logs from"));
        profileNameField.setTooltip(new Tooltip("Profile name (e.g., DEV, STAGING, PROD)"));
    }

    private void setupProfileComboBox() {
        // Configure combo box to display profile name and username
        profileComboBox.setCellFactory(param -> new ListCell<>() {
            @Override
            protected void updateItem(EnvironmentProfile profile, boolean empty) {
                super.updateItem(profile, empty);
                if (empty || profile == null) {
                    setText(null);
                } else {
                    setText(profile.toString());
                }
            }
        });

        profileComboBox.setButtonCell(new ListCell<>() {
            @Override
            protected void updateItem(EnvironmentProfile profile, boolean empty) {
                super.updateItem(profile, empty);
                if (empty || profile == null) {
                    setText("Select Profile...");
                } else {
                    setText(profile.toString());
                }
            }
        });

        // Listen for profile selection changes
        profileComboBox.valueProperty().addListener((obs, oldVal, newVal) -> {
            if (newVal != null) {
                loadProfileToUI(newVal);
            }
        });
    }

    private void loadProfiles() {
        try {
            List<EnvironmentProfile> profiles = profileManager.listProfiles();
            profileComboBox.setItems(FXCollections.observableArrayList(profiles));
        } catch (IOException e) {
            showError("Failed to load profiles: " + e.getMessage());
        }
    }

    private void setupListView() {
        logListView.setCellFactory(lv -> new ListCell<>() {
            @Override
            protected void updateItem(String item, boolean empty) {
                super.updateItem(item, empty);
                if (empty || item == null) {
                    setText(null);
                    setStyle("");
                } else {
                    setText(item);
                    if (item.contains("ERROR") || item.contains("FATAL")) {
                        setStyle("-fx-text-fill: #dc3545; -fx-font-weight: bold;");
                    } else if (item.contains("WARN")) {
                        setStyle("-fx-text-fill: #ffc107;");
                    } else if (item.contains("DEBUG")) {
                        setStyle("-fx-text-fill: #6c757d;");
                    } else {
                        setStyle("");
                    }
                }
            }
        });
    }

    @FXML
    private void onStart() {
        // Validate inputs
        if (podNameField.getText() == null || podNameField.getText().trim().isEmpty()) {
            showError("Pod name is required");
            return;
        }

        try {
            // Create auto-refresh service
            // Note: AWS login must be done manually via "Login to AWS" button before starting
            AutoRefreshLogService.Builder builder = new AutoRefreshLogService.Builder()
                    .namespace(namespaceField.getText())
                    .podName(podNameField.getText().trim())
                    .tailLines(tailLinesSpinner.getValue())
                    .refreshIntervalSeconds(refreshIntervalSpinner.getValue());

            // Add kubectl context
            String context = kubectlContextField.getText();
            if (context != null && !context.trim().isEmpty()) {
                builder.kubectlContext(context.trim());
            }

            // Add container name if specified
            String container = containerNameField.getText();
            if (container != null && !container.trim().isEmpty()) {
                builder.containerName(container.trim());
            }

            // Add log path if file log is selected
            if (fileLogRadio.isSelected()) {
                String logPath = logPathField.getText();
                if (logPath != null && !logPath.trim().isEmpty()) {
                    builder.logPath(logPath.trim());
                }
            }

            autoRefreshService = builder.build();

            // Set up event handlers
            autoRefreshService.setOnSucceeded(event -> {
                File logFile = autoRefreshService.getValue();
                if (logFile != null) {
                    loadLogFile(logFile);
                    updateLastUpdateTime();
                    progressBar.setVisible(false);
                }
            });

            autoRefreshService.setOnFailed(event -> {
                Throwable ex = autoRefreshService.getException();
                Platform.runLater(() -> {
                    progressLabel.setText("Error: " + ex.getMessage());
                    progressBar.setVisible(false);
                    showError("Failed to download logs: " + ex.getMessage());
                });
            });

            autoRefreshService.setOnRunning(event -> {
                Platform.runLater(() -> {
                    progressLabel.setText("Downloading logs...");
                    progressBar.setVisible(true);
                    progressBar.setProgress(-1);
                });
            });

            // Start the service
            autoRefreshService.start();

            // Update UI
            startButton.setDisable(true);
            stopButton.setDisable(false);
            statusLabel.setText("Running");
            statusLabel.setStyle("-fx-text-fill: #28a745;");
            progressLabel.setText("Auto-refresh started");

            // Disable configuration fields
            setConfigurationFieldsDisabled(true);

        } catch (Exception e) {
            showError("Failed to start auto-refresh: " + e.getMessage());
            e.printStackTrace();
        }
    }

    @FXML
    private void onStop() {
        if (autoRefreshService != null) {
            autoRefreshService.cancel();
            autoRefreshService = null;
        }

        startButton.setDisable(false);
        stopButton.setDisable(true);
        statusLabel.setText("Stopped");
        statusLabel.setStyle("-fx-text-fill: #666;");
        progressLabel.setText("Auto-refresh stopped");
        progressBar.setVisible(false);

        // Enable configuration fields
        setConfigurationFieldsDisabled(false);
    }

    @FXML
    private void onDownloadOnce() {
        // Validate inputs
        if (podNameField.getText() == null || podNameField.getText().trim().isEmpty()) {
            showError("Pod name is required");
            return;
        }

        progressBar.setVisible(true);
        progressBar.setProgress(-1);
        progressLabel.setText("Downloading logs...");
        startButton.setDisable(true);

        // Create one-time download service
        // Note: AWS login must be done manually via "Login to AWS" button before downloading
        com.logviewer.service.LogDownloadService.Builder builder =
            new com.logviewer.service.LogDownloadService.Builder()
                .namespace(namespaceField.getText())
                .podName(podNameField.getText().trim())
                .tailLines(tailLinesSpinner.getValue());

        // Add kubectl context
        String context = kubectlContextField.getText();
        if (context != null && !context.trim().isEmpty()) {
            builder.kubectlContext(context.trim());
        }

        // Add container name
        String container = containerNameField.getText();
        if (container != null && !container.trim().isEmpty()) {
            builder.containerName(container.trim());
        }

        // Add log path if file log is selected
        if (fileLogRadio.isSelected()) {
            String logPath = logPathField.getText();
            if (logPath != null && !logPath.trim().isEmpty()) {
                builder.logPath(logPath.trim());
            }
        }

        com.logviewer.service.LogDownloadService downloadService = builder.build();

        downloadService.setOnSucceeded(event -> {
            File logFile = downloadService.getValue();
            loadLogFile(logFile);
            updateLastUpdateTime();
            progressBar.setVisible(false);
            progressLabel.setText("Download completed");
            startButton.setDisable(false);
        });

        downloadService.setOnFailed(event -> {
            Throwable ex = downloadService.getException();
            progressBar.setVisible(false);
            progressLabel.setText("Download failed");
            startButton.setDisable(false);
            showError("Failed to download logs: " + ex.getMessage());
        });

        Thread thread = new Thread(downloadService);
        thread.setDaemon(true);
        thread.start();
    }

    private void loadLogFile(File logFile) {
        Platform.runLater(() -> {
            currentLogFile = logFile;
            currentFileLabel.setText("File: " + logFile.getName());

            // Load log file in background
            LogFileLoader loader = new LogFileLoader(logFile);

            loader.setOnSucceeded(event -> {
                allEntries = loader.getValue();
                filteredEntries = new ArrayList<>(allEntries);
                displayEntries(filteredEntries);
                progressLabel.setText(String.format("Loaded %,d lines", allEntries.size()));

                // Auto-load to main window if enabled
                if (autoLoadToMainWindowCheck.isSelected() && mainController != null) {
                    int pane = loadToPane1Radio.isSelected() ? 1 : 2;
                    mainController.loadLogFileIntoPane(logFile, pane);
                }
            });

            loader.setOnFailed(event -> {
                showError("Failed to load log file: " + loader.getException().getMessage());
            });

            Thread thread = new Thread(loader);
            thread.setDaemon(true);
            thread.start();
        });
    }

    /**
     * Set reference to main controller for auto-loading logs
     */
    public void setMainController(MainController mainController) {
        this.mainController = mainController;
    }

    private void displayEntries(List<LogEntry> entries) {
        ObservableList<String> items = FXCollections.observableArrayList();

        int displayLimit = Math.min(entries.size(), 50000);
        for (int i = 0; i < displayLimit; i++) {
            items.add(entries.get(i).getFormattedLine());
        }

        logListView.setItems(items);
        resultCountLabel.setText(String.format("Lines: %,d%s", entries.size(),
                entries.size() > displayLimit ? " (showing first 50,000)" : ""));

        // Auto-scroll to bottom
        if (!items.isEmpty()) {
            logListView.scrollTo(items.size() - 1);
        }
    }

    private void updateLastUpdateTime() {
        String timeStr = LocalDateTime.now().format(
            DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"));
        lastUpdateLabel.setText("Last Update: " + timeStr);
    }

    @FXML
    private void onSearch() {
        String searchText = searchField.getText();
        if (searchText == null || searchText.trim().isEmpty()) {
            filteredEntries = new ArrayList<>(allEntries);
        } else {
            filteredEntries = allEntries.stream()
                .filter(entry -> entry.matches(searchText, false))
                .toList();
        }
        applyLevelFilter();
    }

    @FXML
    private void onClearSearch() {
        searchField.clear();
        filteredEntries = new ArrayList<>(allEntries);
        displayEntries(filteredEntries);
    }

    @FXML
    private void onApplyFilter() {
        applyLevelFilter();
    }

    private void applyLevelFilter() {
        List<LogEntry> filtered = filteredEntries.stream()
            .filter(entry -> {
                String level = entry.getLevel();
                return switch (level) {
                    case "ERROR", "FATAL" -> errorCheckBox.isSelected();
                    case "WARN", "WARNING" -> warnCheckBox.isSelected();
                    case "INFO" -> infoCheckBox.isSelected();
                    case "DEBUG" -> debugCheckBox.isSelected();
                    case "TRACE" -> traceCheckBox.isSelected();
                    default -> true;
                };
            })
            .toList();

        displayEntries(filtered);
    }

    @FXML
    private void onExport() {
        if (currentLogFile == null) {
            showError("No log file to export");
            return;
        }

        FileChooser fileChooser = new FileChooser();
        fileChooser.setTitle("Export Log File");
        fileChooser.setInitialFileName(currentLogFile.getName());
        fileChooser.getExtensionFilters().add(
            new FileChooser.ExtensionFilter("Log Files", "*.log", "*.txt"));

        File file = fileChooser.showSaveDialog(logListView.getScene().getWindow());
        if (file != null) {
            try {
                Files.copy(currentLogFile.toPath(), file.toPath(),
                    java.nio.file.StandardCopyOption.REPLACE_EXISTING);
                showInfo("Log file exported successfully to: " + file.getAbsolutePath());
            } catch (IOException e) {
                showError("Failed to export: " + e.getMessage());
            }
        }
    }

    @FXML
    private void onGetContexts() {
        executeKubectlCommand("kubectl config get-contexts", "Available Contexts");
    }

    @FXML
    private void onGetNamespaces() {
        executeKubectlCommand("kubectl get namespaces", "Available Namespaces");
    }

    @FXML
    private void onListPods() {
        String namespace = namespaceField.getText();
        String command = namespace != null && !namespace.trim().isEmpty()
            ? "kubectl get pods -n " + namespace
            : "kubectl get pods";
        executeKubectlCommand(command, "Available Pods");
    }

    private void executeKubectlCommand(String command, String title) {
        try {
            ProcessBuilder pb = new ProcessBuilder(command.split(" "));
            pb.redirectErrorStream(true);
            Process process = pb.start();

            StringBuilder output = new StringBuilder();
            try (BufferedReader reader = new BufferedReader(
                    new InputStreamReader(process.getInputStream()))) {
                String line;
                while ((line = reader.readLine()) != null) {
                    output.append(line).append("\n");
                }
            }

            process.waitFor(10, TimeUnit.SECONDS);

            Alert alert = new Alert(Alert.AlertType.INFORMATION);
            alert.setTitle(title);
            alert.setHeaderText(command);
            alert.setContentText(output.toString());
            alert.showAndWait();

        } catch (Exception e) {
            showError("Failed to execute command: " + e.getMessage());
        }
    }

    @FXML
    private void onSaveConfig() {
        FileChooser fileChooser = new FileChooser();
        fileChooser.setTitle("Save Configuration");
        fileChooser.setInitialFileName("auto-refresh-config.properties");
        fileChooser.getExtensionFilters().add(
            new FileChooser.ExtensionFilter("Properties Files", "*.properties"));

        File file = fileChooser.showSaveDialog(startButton.getScene().getWindow());
        if (file != null) {
            saveConfigToFile(file);
        }
    }

    @FXML
    private void onLoadConfig() {
        FileChooser fileChooser = new FileChooser();
        fileChooser.setTitle("Load Configuration");
        fileChooser.getExtensionFilters().add(
            new FileChooser.ExtensionFilter("Properties Files", "*.properties"));

        File file = fileChooser.showOpenDialog(startButton.getScene().getWindow());
        if (file != null) {
            loadConfigFromFile(file);
        }
    }

    private void saveConfigToFile(File file) {
        Properties props = new Properties();
        props.setProperty("aws.login.command", awsLoginCommandField.getText());
        props.setProperty("kubectl.context", kubectlContextField.getText());
        props.setProperty("namespace", namespaceField.getText());
        props.setProperty("pod.name", podNameField.getText());
        props.setProperty("container.name", containerNameField.getText());
        props.setProperty("log.source", stdoutLogRadio.isSelected() ? "stdout" : "file");
        props.setProperty("log.path", logPathField.getText());
        props.setProperty("tail.lines", String.valueOf(tailLinesSpinner.getValue()));
        props.setProperty("refresh.interval", String.valueOf(refreshIntervalSpinner.getValue()));

        try (OutputStream os = new FileOutputStream(file)) {
            props.store(os, "Auto-Refresh Log Viewer Configuration");
            showInfo("Configuration saved successfully");
        } catch (IOException e) {
            showError("Failed to save configuration: " + e.getMessage());
        }
    }

    private void loadConfigFromFile(File file) {
        Properties props = new Properties();
        try (InputStream is = new FileInputStream(file)) {
            props.load(is);

            awsLoginCommandField.setText(props.getProperty("aws.login.command", ""));
            kubectlContextField.setText(props.getProperty("kubectl.context", ""));
            namespaceField.setText(props.getProperty("namespace", "default"));
            podNameField.setText(props.getProperty("pod.name", ""));
            containerNameField.setText(props.getProperty("container.name", ""));

            String logSource = props.getProperty("log.source", "stdout");
            if ("stdout".equals(logSource)) {
                stdoutLogRadio.setSelected(true);
            } else {
                fileLogRadio.setSelected(true);
            }

            logPathField.setText(props.getProperty("log.path", ""));
            tailLinesSpinner.getValueFactory().setValue(
                Integer.parseInt(props.getProperty("tail.lines", "1000")));
            refreshIntervalSpinner.getValueFactory().setValue(
                Integer.parseInt(props.getProperty("refresh.interval", "30")));

            showInfo("Configuration loaded successfully");
        } catch (IOException e) {
            showError("Failed to load configuration: " + e.getMessage());
        }
    }

    private void setConfigurationFieldsDisabled(boolean disabled) {
        awsLoginCommandField.setDisable(disabled);
        loginToAwsButton.setDisable(disabled);
        sessionRefreshSpinner.setDisable(disabled);
        autoRefreshSessionCheck.setDisable(disabled);
        kubectlContextField.setDisable(disabled);
        namespaceField.setDisable(disabled);
        podNameField.setDisable(disabled);
        containerNameField.setDisable(disabled);
        stdoutLogRadio.setDisable(disabled);
        fileLogRadio.setDisable(disabled);
        logPathField.setDisable(disabled || stdoutLogRadio.isSelected());
        tailLinesSpinner.setDisable(disabled);
        refreshIntervalSpinner.setDisable(disabled);
    }

    private void showError(String message) {
        Alert alert = new Alert(Alert.AlertType.ERROR, message);
        alert.showAndWait();
    }

    private void showInfo(String message) {
        Alert alert = new Alert(Alert.AlertType.INFORMATION, message);
        alert.showAndWait();
    }

    // ==================== Profile Management Methods ====================

    @FXML
    private void onNewProfile() {
        // Clear all fields for new profile
        profileNameField.clear();
        awsLoginCommandField.clear();
        kubectlContextField.clear();
        namespaceField.setText("default");
        podNameField.clear();
        containerNameField.clear();
        logPathField.clear();
        stdoutLogRadio.setSelected(true);
        tailLinesSpinner.getValueFactory().setValue(1000);
        refreshIntervalSpinner.getValueFactory().setValue(30);
        sessionRefreshSpinner.getValueFactory().setValue(20);
        autoRefreshSessionCheck.setSelected(false);

        profileComboBox.setValue(null);
        currentProfile = null;

        profileNameField.requestFocus();
    }

    @FXML
    private void onSaveProfile() {
        // Validate inputs
        String profileName = profileNameField.getText();

        if (profileName == null || profileName.trim().isEmpty()) {
            showError("Profile name is required");
            return;
        }

        // Create or update profile
        EnvironmentProfile profile = currentProfile != null ? currentProfile : new EnvironmentProfile();
        profile.setProfileName(profileName.trim());
        profile.setAwsLoginCommand(awsLoginCommandField.getText());
        profile.setKubectlContext(kubectlContextField.getText());
        profile.setNamespace(namespaceField.getText());
        profile.setDefaultPodName(podNameField.getText());
        profile.setDefaultContainerName(containerNameField.getText());
        profile.setTailLines(tailLinesSpinner.getValue());
        profile.setRefreshIntervalSeconds(refreshIntervalSpinner.getValue());
        profile.setSessionRefreshMinutes(sessionRefreshSpinner.getValue());

        try {
            profileManager.saveProfile(profile);
            showInfo("Profile saved successfully: " + profile.toString());

            // Reload profiles
            loadProfiles();

            // Select the saved profile
            profileComboBox.setValue(profile);
            currentProfile = profile;

        } catch (IOException e) {
            showError("Failed to save profile: " + e.getMessage());
        }
    }

    @FXML
    private void onDeleteProfile() {
        EnvironmentProfile selected = profileComboBox.getValue();
        if (selected == null) {
            showError("Please select a profile to delete");
            return;
        }

        Alert confirm = new Alert(Alert.AlertType.CONFIRMATION);
        confirm.setTitle("Delete Profile");
        confirm.setHeaderText("Delete profile: " + selected.toString() + "?");
        confirm.setContentText("This action cannot be undone.");

        Optional<ButtonType> result = confirm.showAndWait();
        if (result.isPresent() && result.get() == ButtonType.OK) {
            boolean deleted = profileManager.deleteProfile(selected.getProfileId());
            if (deleted) {
                showInfo("Profile deleted successfully");
                loadProfiles();
                onNewProfile();  // Clear form
            } else {
                showError("Failed to delete profile");
            }
        }
    }

    private void loadProfileToUI(EnvironmentProfile profile) {
        currentProfile = profile;

        profileNameField.setText(profile.getProfileName());
        awsLoginCommandField.setText(profile.getAwsLoginCommand());
        kubectlContextField.setText(profile.getKubectlContext());
        namespaceField.setText(profile.getNamespace());
        podNameField.setText(profile.getDefaultPodName());
        containerNameField.setText(profile.getDefaultContainerName());
        tailLinesSpinner.getValueFactory().setValue(profile.getTailLines());
        refreshIntervalSpinner.getValueFactory().setValue(profile.getRefreshIntervalSeconds());
        sessionRefreshSpinner.getValueFactory().setValue(profile.getSessionRefreshMinutes());
    }

    // ==================== AWS Session Management ====================

    @FXML
    private void onLoginToAws() {
        String awsCommand = awsLoginCommandField.getText();
        if (awsCommand == null || awsCommand.trim().isEmpty()) {
            showError("Please enter AWS login command");
            return;
        }

        launchInteractiveAwsLogin(awsCommand.trim());

        // Start auto-refresh timer if enabled
        if (autoRefreshSessionCheck.isSelected()) {
            startSessionRefreshTimer();
        }
    }

    private void launchInteractiveAwsLogin(String awsCommand) {
        try {
            // Launch new command prompt window with AWS login command
            ProcessBuilder pb = new ProcessBuilder("cmd.exe", "/c", "start", "cmd.exe", "/k", awsCommand);
            pb.start();

            updateMessage("AWS login command prompt launched. Please complete login in the new window.");
        } catch (IOException e) {
            showError("Failed to launch command prompt: " + e.getMessage());
        }
    }

    private void startSessionRefreshTimer() {
        // Stop existing timer if any
        stopSessionRefreshTimer();

        int intervalMinutes = sessionRefreshSpinner.getValue();
        String awsCommand = awsLoginCommandField.getText();

        if (awsCommand == null || awsCommand.trim().isEmpty()) {
            return;
        }

        // Create timeline that triggers every X minutes
        javafx.util.Duration duration = javafx.util.Duration.minutes(intervalMinutes);
        javafx.animation.KeyFrame keyFrame = new javafx.animation.KeyFrame(duration, event -> {
            updateMessage("Session refresh: launching AWS login...");
            launchInteractiveAwsLogin(awsCommand.trim());
        });

        sessionRefreshTimer = new javafx.animation.Timeline(keyFrame);
        sessionRefreshTimer.setCycleCount(javafx.animation.Timeline.INDEFINITE);
        sessionRefreshTimer.play();

        updateMessage("Auto session refresh started - will re-login every " + intervalMinutes + " minutes");
    }

    private void stopSessionRefreshTimer() {
        if (sessionRefreshTimer != null) {
            sessionRefreshTimer.stop();
            sessionRefreshTimer = null;
        }
    }

    private void updateMessage(String message) {
        Platform.runLater(() -> {
            progressLabel.setText(message);
            statusLabel.setText("Ready");
        });
    }

    /**
     * Show MFA token input dialog
     */
    private String promptForMfaToken(String message) {
        TextInputDialog dialog = new TextInputDialog();
        dialog.setTitle("MFA Token Required");
        dialog.setHeaderText("Multi-Factor Authentication");
        dialog.setContentText(message + "\n\nEnter your MFA token from mobile:");

        Optional<String> result = dialog.showAndWait();
        return result.orElse(null);
    }

    /**
     * Handle MFA prompts during download
     */
    private void handleDownloadWithMfa(LogDownloadService.Builder builder) {
        LogDownloadService downloadService = builder.build();

        downloadService.setOnSucceeded(event -> {
            File logFile = downloadService.getValue();
            loadLogFile(logFile);
            updateLastUpdateTime();
            progressBar.setVisible(false);
            progressLabel.setText("Download completed");
            startButton.setDisable(false);
        });

        downloadService.setOnFailed(event -> {
            Throwable ex = downloadService.getException();

            // Check if it's an MFA exception
            if (ex instanceof LogDownloadService.MfaRequiredException mfaEx) {
                Platform.runLater(() -> {
                    String mfaToken = promptForMfaToken(mfaEx.getMessage());
                    if (mfaToken != null && !mfaToken.trim().isEmpty()) {
                        try {
                            progressLabel.setText("Sending MFA token...");
                            mfaEx.sendMfaToken(mfaToken.trim());
                            progressLabel.setText("Authentication successful");

                            // Continue with kubectl commands after successful MFA
                            // For now, just reload
                            onDownloadOnce();

                        } catch (Exception e) {
                            progressBar.setVisible(false);
                            progressLabel.setText("MFA authentication failed");
                            startButton.setDisable(false);
                            showError("MFA authentication failed: " + e.getMessage());
                        }
                    } else {
                        progressBar.setVisible(false);
                        progressLabel.setText("MFA cancelled");
                        startButton.setDisable(false);
                    }
                });
            } else {
                progressBar.setVisible(false);
                progressLabel.setText("Download failed");
                startButton.setDisable(false);
                showError("Failed to download logs: " + ex.getMessage());
            }
        });

        Thread thread = new Thread(downloadService);
        thread.setDaemon(true);
        thread.start();
    }
}
----------------------------------------
package com.logviewer;

import com.logviewer.model.LogEntry;
import com.logviewer.service.LogContextExtractor;
import javafx.application.Platform;
import javafx.collections.FXCollections;
import javafx.fxml.FXML;
import javafx.scene.control.*;
import javafx.scene.layout.VBox;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;

public class ContextViewerController {

    @FXML private Label selectedLogLabel;
    @FXML private TextArea selectedLogArea;
    @FXML private Label requestIdLabel;
    @FXML private Label threadIdLabel;
    @FXML private Label userIdLabel;
    @FXML private Label endpointLabel;

    @FXML private TabPane contextTabPane;

    @FXML private ListView<String> requestIdListView;
    @FXML private ListView<String> threadListView;
    @FXML private ListView<String> timeWindowListView;
    @FXML private ListView<String> errorsListView;
    @FXML private ListView<String> impactListView;

    @FXML private TextArea keyDataArea;
    @FXML private Label statsLabel;

    @FXML private VBox timelineBox;

    private LogContextExtractor extractor;
    private Map<String, Object> contextData;

    @FXML
    public void initialize() {
        extractor = new LogContextExtractor();
    }

    public void showContext(LogEntry selectedEntry, List<LogEntry> allEntries, int selectedIndex) {
        Platform.runLater(() -> {
            // Extract context
            contextData = extractor.extractContext(selectedEntry, allEntries, selectedIndex);

            // Display selected log
            selectedLogLabel.setText("Selected Log Line #" + (selectedIndex + 1));
            selectedLogArea.setText(selectedEntry.getFormattedLine());

            // Display identifiers
            String requestId = (String) contextData.get("requestId");
            String threadId = (String) contextData.get("threadId");
            String userId = (String) contextData.get("userId");
            String endpoint = (String) contextData.get("endpoint");

            requestIdLabel.setText(requestId != null ? requestId : "Not found");
            threadIdLabel.setText(threadId != null ? threadId : "Not found");
            userIdLabel.setText(userId != null ? userId : "Not found");
            endpointLabel.setText(endpoint != null ? endpoint : "Not found");

            // Populate tabs
            populateRequestIdTab();
            populateThreadTab();
            populateTimeWindowTab();
            populateErrorsTab();
            populateImpactTab();

            // Display key data
            displayKeyData();

            // Display stats
            displayStats();

            // Build timeline
            buildTimeline();
        });
    }

    @SuppressWarnings("unchecked")
    private void populateRequestIdTab() {
        List<LogEntry> entries = (List<LogEntry>) contextData.get("relatedByRequestId");
        List<String> items = new ArrayList<>();

        for (int i = 0; i < entries.size(); i++) {
            LogEntry entry = entries.get(i);
            items.add(String.format("[%d] %s", i + 1, entry.getFormattedLine()));
        }

        requestIdListView.setItems(FXCollections.observableArrayList(items));

        // Update tab title with count
        Tab tab = contextTabPane.getTabs().get(0);
        tab.setText(String.format("By Request ID (%d)", entries.size()));
    }

    @SuppressWarnings("unchecked")
    private void populateThreadTab() {
        List<LogEntry> entries = (List<LogEntry>) contextData.get("relatedByThread");
        List<String> items = new ArrayList<>();

        for (int i = 0; i < entries.size() && i < 500; i++) {
            LogEntry entry = entries.get(i);
            items.add(String.format("[%d] %s", i + 1, entry.getFormattedLine()));
        }

        threadListView.setItems(FXCollections.observableArrayList(items));

        Tab tab = contextTabPane.getTabs().get(1);
        tab.setText(String.format("By Thread (%d)", Math.min(entries.size(), 500)));
    }

    @SuppressWarnings("unchecked")
    private void populateTimeWindowTab() {
        List<LogEntry> entries = (List<LogEntry>) contextData.get("relatedByTime");
        List<String> items = new ArrayList<>();

        for (int i = 0; i < entries.size(); i++) {
            LogEntry entry = entries.get(i);
            items.add(String.format("[%d] %s", i + 1, entry.getFormattedLine()));
        }

        timeWindowListView.setItems(FXCollections.observableArrayList(items));

        Tab tab = contextTabPane.getTabs().get(2);
        tab.setText(String.format("Time Window Â±30s (%d)", entries.size()));
    }

    @SuppressWarnings("unchecked")
    private void populateErrorsTab() {
        List<LogEntry> entries = (List<LogEntry>) contextData.get("relatedErrors");
        List<String> items = new ArrayList<>();

        for (int i = 0; i < entries.size(); i++) {
            LogEntry entry = entries.get(i);
            items.add(String.format("[%d] %s", i + 1, entry.getFormattedLine()));
        }

        errorsListView.setItems(FXCollections.observableArrayList(items));

        Tab tab = contextTabPane.getTabs().get(3);
        tab.setText(String.format("Related Errors (%d)", entries.size()));
    }

    @SuppressWarnings("unchecked")
    private void populateImpactTab() {
        List<LogEntry> entries = (List<LogEntry>) contextData.get("impactedEntries");
        List<String> items = new ArrayList<>();

        for (int i = 0; i < entries.size(); i++) {
            LogEntry entry = entries.get(i);
            items.add(String.format("[%d] %s", i + 1, entry.getFormattedLine()));
        }

        impactListView.setItems(FXCollections.observableArrayList(items));

        Tab tab = contextTabPane.getTabs().get(4);
        tab.setText(String.format("Impact Analysis (%d)", entries.size()));
    }

    @SuppressWarnings("unchecked")
    private void displayKeyData() {
        Map<String, String> keyData = (Map<String, String>) contextData.get("keyData");

        StringBuilder sb = new StringBuilder();
        sb.append("=== Extracted Key Data ===\n\n");

        if (keyData.isEmpty()) {
            sb.append("No key data extracted");
        } else {
            for (Map.Entry<String, String> entry : keyData.entrySet()) {
                sb.append(entry.getKey()).append(": ").append(entry.getValue()).append("\n");
            }
        }

        keyDataArea.setText(sb.toString());
    }

    @SuppressWarnings("unchecked")
    private void displayStats() {
        Map<String, Object> stats = (Map<String, Object>) contextData.get("stats");

        StringBuilder sb = new StringBuilder();
        sb.append(String.format("Request ID matches: %d | ", stats.get("totalRelatedByRequestId")));
        sb.append(String.format("Thread matches: %d | ", stats.get("totalRelatedByThread")));
        sb.append(String.format("Time window: %d | ", stats.get("totalInTimeWindow")));
        sb.append(String.format("Errors: %d | ", stats.get("totalRelatedErrors")));
        sb.append(String.format("Impacted: %d", stats.get("totalImpacted")));

        statsLabel.setText(sb.toString());
    }

    @SuppressWarnings("unchecked")
    private void buildTimeline() {
        List<LogEntry> timelineEntries = (List<LogEntry>) contextData.get("relatedByRequestId");

        if (timelineEntries.isEmpty()) {
            timelineEntries = (List<LogEntry>) contextData.get("relatedByTime");
        }

        timelineBox.getChildren().clear();

        Label titleLabel = new Label("Timeline (chronological view)");
        titleLabel.setStyle("-fx-font-weight: bold; -fx-font-size: 12px;");
        timelineBox.getChildren().add(titleLabel);

        // Sort by timestamp
        List<LogEntry> sorted = new ArrayList<>(timelineEntries);
        sorted.sort(Comparator.comparing(LogEntry::getTimestamp,
            Comparator.nullsLast(Comparator.naturalOrder())));

        int count = 0;
        LocalDateTime previousTime = null;

        for (LogEntry entry : sorted) {
            if (count++ > 100) break; // Limit to 100 entries

            if (entry.getTimestamp() != null) {
                // Show time delta
                if (previousTime != null) {
                    long deltaMs = java.time.Duration.between(previousTime, entry.getTimestamp()).toMillis();
                    Label deltaLabel = new Label(String.format("  â +%dms", deltaMs));
                    deltaLabel.setStyle("-fx-text-fill: #888; -fx-font-size: 10px;");
                    timelineBox.getChildren().add(deltaLabel);
                }

                previousTime = entry.getTimestamp();

                // Show timestamp and log
                Label timeLabel = new Label(entry.getTimestamp().format(
                    DateTimeFormatter.ofPattern("HH:mm:ss.SSS")));
                timeLabel.setStyle("-fx-font-weight: bold; -fx-font-size: 10px;");

                String logLine = entry.getFormattedLine();
                if (logLine.length() > 120) {
                    logLine = logLine.substring(0, 120) + "...";
                }

                Label logLabel = new Label("  " + logLine);
                logLabel.setStyle("-fx-font-family: 'Consolas'; -fx-font-size: 10px;");

                if (logLine.toUpperCase().contains("ERROR")) {
                    logLabel.setStyle(logLabel.getStyle() + "-fx-text-fill: red;");
                }

                timelineBox.getChildren().add(timeLabel);
                timelineBox.getChildren().add(logLabel);
            }
        }
    }

    @FXML
    private void onClose() {
        ((javafx.stage.Stage) selectedLogLabel.getScene().getWindow()).close();
    }
}
------------------------------------
package com.logviewer;

import com.logviewer.model.CorrelationMatch;
import com.logviewer.model.LogEntry;
import com.logviewer.service.CorrelationService;
import javafx.application.Platform;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.fxml.FXML;
import javafx.scene.control.*;

import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

/**
 * Controller for the Correlation View window
 */
public class CorrelationController {

    @FXML private Button analyzeButton;
    @FXML private Button clearButton;
    @FXML private TextField searchIdField;
    @FXML private Label totalCorrelationsLabel;
    @FXML private Label requestIdCountLabel;
    @FXML private Label transactionIdCountLabel;
    @FXML private Label sessionIdCountLabel;
    @FXML private Label userIdCountLabel;
    @FXML private ListView<String> correlationListView;
    @FXML private SplitPane detailsPane;
    @FXML private ListView<String> pane1EntriesView;
    @FXML private ListView<String> pane2EntriesView;
    @FXML private Label pane1CountLabel;
    @FXML private Label pane2CountLabel;
    @FXML private Label statusLabel;
    @FXML private ProgressBar progressBar;

    private List<LogEntry> pane1Entries;
    private List<LogEntry> pane2Entries;
    private List<CorrelationMatch> correlationMatches;

    @FXML
    public void initialize() {
        // Set up selection listener
        correlationListView.getSelectionModel().selectedItemProperty().addListener(
            (obs, oldVal, newVal) -> onCorrelationSelected()
        );

        detailsPane.setDividerPositions(0.5);
    }

    public void setLogData(List<LogEntry> pane1Entries, List<LogEntry> pane2Entries) {
        this.pane1Entries = pane1Entries;
        this.pane2Entries = pane2Entries;
    }

    @FXML
    private void onAnalyze() {
        if (pane1Entries == null || pane2Entries == null) {
            showAlert("No Data", "Please load log files in both panes first.");
            return;
        }

        if (pane1Entries.isEmpty() || pane2Entries.isEmpty()) {
            showAlert("No Data", "Both panes must have log entries to analyze correlations.");
            return;
        }

        analyzeButton.setDisable(true);
        progressBar.setVisible(true);
        statusLabel.setText("Analyzing correlations...");

        CorrelationService service = new CorrelationService(pane1Entries, pane2Entries);

        // Bind progress
        progressBar.progressProperty().bind(service.progressProperty());
        statusLabel.textProperty().bind(service.messageProperty());

        service.setOnSucceeded(event -> {
            correlationMatches = service.getValue();
            displayCorrelations();

            analyzeButton.setDisable(false);
            progressBar.setVisible(false);
            progressBar.progressProperty().unbind();
            statusLabel.textProperty().unbind();
            statusLabel.setText(String.format("Found %d correlations", correlationMatches.size()));
        });

        service.setOnFailed(event -> {
            analyzeButton.setDisable(false);
            progressBar.setVisible(false);
            progressBar.progressProperty().unbind();
            statusLabel.textProperty().unbind();
            statusLabel.setText("Analysis failed");

            showAlert("Error", "Correlation analysis failed: " + service.getException().getMessage());
        });

        Thread thread = new Thread(service);
        thread.setDaemon(true);
        thread.start();
    }

    @FXML
    private void onClear() {
        correlationListView.getItems().clear();
        pane1EntriesView.getItems().clear();
        pane2EntriesView.getItems().clear();
        correlationMatches = null;

        totalCorrelationsLabel.setText("0");
        requestIdCountLabel.setText("0");
        transactionIdCountLabel.setText("0");
        sessionIdCountLabel.setText("0");
        userIdCountLabel.setText("0");
        pane1CountLabel.setText("0 entries");
        pane2CountLabel.setText("0 entries");
        statusLabel.setText("Ready");
    }

    @FXML
    private void onSearchId() {
        String searchId = searchIdField.getText().trim();
        if (searchId.isEmpty()) {
            showAlert("Invalid Input", "Please enter an ID to search.");
            return;
        }

        if (pane1Entries == null || pane2Entries == null) {
            showAlert("No Data", "Please load log files first.");
            return;
        }

        statusLabel.setText("Searching for ID: " + searchId);

        CorrelationMatch match = CorrelationService.findById(searchId, pane1Entries, pane2Entries);

        if (!match.hasEntriesInBothPanes()) {
            statusLabel.setText("ID not found in both panes");
            showAlert("Not Found",
                String.format("ID '%s' found in Pane1: %d, Pane2: %d\nMust appear in both panes for correlation.",
                    searchId, match.getPane1Entries().size(), match.getPane2Entries().size()));
            return;
        }

        // Display the match
        correlationMatches = List.of(match);
        displayCorrelations();
        correlationListView.getSelectionModel().selectFirst();

        statusLabel.setText(String.format("Found ID '%s' in both panes", searchId));
    }

    private void displayCorrelations() {
        Platform.runLater(() -> {
            ObservableList<String> items = FXCollections.observableArrayList();

            for (CorrelationMatch match : correlationMatches) {
                items.add(match.getSummary());
            }

            correlationListView.setItems(items);

            // Update statistics
            totalCorrelationsLabel.setText(String.valueOf(correlationMatches.size()));

            Map<CorrelationMatch.CorrelationType, Long> typeCounts = correlationMatches.stream()
                .collect(Collectors.groupingBy(CorrelationMatch::getType, Collectors.counting()));

            requestIdCountLabel.setText(String.valueOf(
                typeCounts.getOrDefault(CorrelationMatch.CorrelationType.REQUEST_ID, 0L)));
            transactionIdCountLabel.setText(String.valueOf(
                typeCounts.getOrDefault(CorrelationMatch.CorrelationType.TRANSACTION_ID, 0L)));
            sessionIdCountLabel.setText(String.valueOf(
                typeCounts.getOrDefault(CorrelationMatch.CorrelationType.SESSION_ID, 0L)));
            userIdCountLabel.setText(String.valueOf(
                typeCounts.getOrDefault(CorrelationMatch.CorrelationType.USER_ID, 0L)));

            if (!correlationMatches.isEmpty()) {
                correlationListView.getSelectionModel().selectFirst();
            }
        });
    }

    private void onCorrelationSelected() {
        int selectedIndex = correlationListView.getSelectionModel().getSelectedIndex();
        if (selectedIndex < 0 || correlationMatches == null || selectedIndex >= correlationMatches.size()) {
            return;
        }

        CorrelationMatch match = correlationMatches.get(selectedIndex);

        // Display Pane 1 entries
        ObservableList<String> pane1Items = FXCollections.observableArrayList();
        for (LogEntry entry : match.getPane1Entries()) {
            pane1Items.add(entry.getFormattedLine());
        }
        pane1EntriesView.setItems(pane1Items);
        pane1CountLabel.setText(match.getPane1Entries().size() + " entries");

        // Display Pane 2 entries
        ObservableList<String> pane2Items = FXCollections.observableArrayList();
        for (LogEntry entry : match.getPane2Entries()) {
            pane2Items.add(entry.getFormattedLine());
        }
        pane2EntriesView.setItems(pane2Items);
        pane2CountLabel.setText(match.getPane2Entries().size() + " entries");

        statusLabel.setText(String.format("Selected: %s", match.getSummary()));
    }

    private void showAlert(String title, String message) {
        Platform.runLater(() -> {
            Alert alert = new Alert(Alert.AlertType.INFORMATION);
            alert.setTitle(title);
            alert.setHeaderText(null);
            alert.setContentText(message);
            alert.showAndWait();
        });
    }
}
--------------------------------------
package com.logviewer;

import javafx.application.Application;
import javafx.fxml.FXMLLoader;
import javafx.scene.Scene;
import javafx.scene.image.Image;
import javafx.stage.Stage;

import java.io.IOException;

/**
 * Main application class for the Log Viewer
 * Supports dual-pane viewing of large log files (up to 600MB each)
 * with fast search and multi-criteria filtering
 */
public class LogViewerApp extends Application {

    @Override
    public void start(Stage stage) throws IOException {
        FXMLLoader fxmlLoader = new FXMLLoader(
                LogViewerApp.class.getResource("/com/logviewer/main-view.fxml"));

        Scene scene = new Scene(fxmlLoader.load(), 1400, 900);

        // Add CSS styling
        scene.getStylesheets().add(
                LogViewerApp.class.getResource("/com/logviewer/styles.css").toExternalForm());

        stage.setTitle("Microservices Log Viewer - Dual Pane");
        stage.setScene(scene);
        stage.setMinWidth(1000);
        stage.setMinHeight(700);

        // Set application icon (if available)
        try {
            stage.getIcons().add(new Image(
                    LogViewerApp.class.getResourceAsStream("/com/logviewer/icon.png")));
        } catch (Exception e) {
            // Icon not found, ignore
        }

        stage.show();
    }

    public static void main(String[] args) {
        launch();
    }
}
-------------------------------
package com.logviewer;

import com.logviewer.model.FilterCriteria;
import com.logviewer.model.LogEntry;
import com.logviewer.service.LogFileLoader;
import com.logviewer.service.LogSearchService;
import javafx.application.Platform;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.fxml.FXML;
import javafx.scene.control.*;
import javafx.stage.FileChooser;

import java.io.File;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.util.ArrayList;
import java.util.List;

/**
 * Main controller for the dual-pane log viewer application
 */
public class MainController {

    // Pane 1 Controls
    @FXML private Button loadButton1;
    @FXML private Label fileName1;
    @FXML private Label status1;
    @FXML private TextField searchField1;
    @FXML private Button searchButton1;
    @FXML private Button clearSearch1;
    @FXML private CheckBox errorCheck1;
    @FXML private CheckBox warnCheck1;
    @FXML private CheckBox infoCheck1;
    @FXML private CheckBox debugCheck1;
    @FXML private CheckBox traceCheck1;
    @FXML private DatePicker dateFrom1;
    @FXML private DatePicker dateTo1;
    @FXML private TextField serviceFilter1;
    @FXML private ListView<String> logListView1;
    @FXML private Label resultCount1;
    @FXML private Label fileSize1;

    // Pane 2 Controls
    @FXML private Button loadButton2;
    @FXML private Label fileName2;
    @FXML private Label status2;
    @FXML private TextField searchField2;
    @FXML private Button searchButton2;
    @FXML private Button clearSearch2;
    @FXML private CheckBox errorCheck2;
    @FXML private CheckBox warnCheck2;
    @FXML private CheckBox infoCheck2;
    @FXML private CheckBox debugCheck2;
    @FXML private CheckBox traceCheck2;
    @FXML private DatePicker dateFrom2;
    @FXML private DatePicker dateTo2;
    @FXML private TextField serviceFilter2;
    @FXML private ListView<String> logListView2;
    @FXML private Label resultCount2;
    @FXML private Label fileSize2;

    // Error navigation controls
    @FXML private Label errorCount1;
    @FXML private Label errorCount2;
    @FXML private Button prevError1;
    @FXML private Button nextError1;
    @FXML private Button prevError2;
    @FXML private Button nextError2;

    // Global Controls
    @FXML private Label globalStatus;
    @FXML private ProgressBar progressBar;
    @FXML private SplitPane splitPane;
    @FXML private ComboBox<String> themeSelector;

    // Trace ID correlation controls
    @FXML private TextField traceIdField;
    @FXML private Button highlightTraceButton;
    @FXML private Button clearTraceButton;

    // Timestamp synchronization
    @FXML private CheckBox syncScrollCheckbox;

    // Data storage for both panes
    private List<LogEntry> allEntries1 = new ArrayList<>();
    private List<LogEntry> allEntries2 = new ArrayList<>();
    private List<LogEntry> filteredEntries1 = new ArrayList<>();
    private List<LogEntry> filteredEntries2 = new ArrayList<>();

    private FilterCriteria filterCriteria1 = new FilterCriteria();
    private FilterCriteria filterCriteria2 = new FilterCriteria();

    // Error navigation tracking
    private List<Integer> errorIndices1 = new ArrayList<>();
    private List<Integer> errorIndices2 = new ArrayList<>();
    private int currentErrorIndex1 = -1;
    private int currentErrorIndex2 = -1;

    // Trace ID correlation
    private String currentTraceId = null;

    @FXML
    public void initialize() {
        // Set up tooltips
        setupTooltips();

        // Enable search on Enter key
        searchField1.setOnAction(e -> onSearch1());
        searchField2.setOnAction(e -> onSearch2());

        // Initialize list views with custom cell factory for better performance
        setupListView(logListView1);
        setupListView(logListView2);

        // Set up theme selector
        setupThemeSelector();

        // Set up timestamp synchronization
        setupTimestampSync();

        globalStatus.setText("Ready. Load log files to begin analysis.");
    }

    private void setupThemeSelector() {
        // Add available themes
        themeSelector.getItems().addAll("Light", "Dark", "Blue", "Green");

        // Load saved theme or default to Light
        String savedTheme = loadSavedTheme();
        themeSelector.setValue(savedTheme);
        applyTheme(savedTheme);

        // Listen for theme changes
        themeSelector.valueProperty().addListener((obs, oldVal, newVal) -> {
            if (newVal != null) {
                applyTheme(newVal);
                saveThemePreference(newVal);
            }
        });
    }

    private void applyTheme(String themeName) {
        String themeFile = switch (themeName) {
            case "Dark" -> "/com/logviewer/themes/dark-theme.css";
            case "Blue" -> "/com/logviewer/themes/blue-theme.css";
            case "Green" -> "/com/logviewer/themes/green-theme.css";
            default -> "/com/logviewer/themes/light-theme.css";
        };

        // Get the scene
        if (splitPane.getScene() != null) {
            splitPane.getScene().getStylesheets().clear();
            splitPane.getScene().getStylesheets().add(getClass().getResource(themeFile).toExternalForm());
        }
    }

    private String loadSavedTheme() {
        try {
            java.io.File prefsFile = new java.io.File(System.getProperty("user.home"),
                ".logviewer/preferences.properties");
            if (prefsFile.exists()) {
                java.util.Properties props = new java.util.Properties();
                try (java.io.FileInputStream fis = new java.io.FileInputStream(prefsFile)) {
                    props.load(fis);
                    return props.getProperty("theme", "Light");
                }
            }
        } catch (Exception e) {
            // Ignore errors, use default
        }
        return "Light";
    }

    private void saveThemePreference(String theme) {
        try {
            java.io.File prefsDir = new java.io.File(System.getProperty("user.home"), ".logviewer");
            if (!prefsDir.exists()) {
                prefsDir.mkdirs();
            }

            java.io.File prefsFile = new java.io.File(prefsDir, "preferences.properties");
            java.util.Properties props = new java.util.Properties();

            // Load existing preferences if file exists
            if (prefsFile.exists()) {
                try (java.io.FileInputStream fis = new java.io.FileInputStream(prefsFile)) {
                    props.load(fis);
                }
            }

            // Update theme
            props.setProperty("theme", theme);

            // Save
            try (java.io.FileOutputStream fos = new java.io.FileOutputStream(prefsFile)) {
                props.store(fos, "Log Viewer Preferences");
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private void setupTooltips() {
        loadButton1.setTooltip(new Tooltip("Load a log file (up to 600MB)"));
        loadButton2.setTooltip(new Tooltip("Load a log file (up to 600MB)"));
        searchField1.setTooltip(new Tooltip("Enter search text (case-insensitive by default)"));
        searchField2.setTooltip(new Tooltip("Enter search text (case-insensitive by default)"));
    }

    private void setupListView(ListView<String> listView) {
        // Use custom cell factory with enhanced color coding
        listView.setCellFactory(lv -> new com.logviewer.ui.ColoredLogCell());

        // Add context menu for right-click
        setupContextMenu(listView);
    }

    private void setupContextMenu(ListView<String> listView) {
        ContextMenu contextMenu = new ContextMenu();

        MenuItem viewContextItem = new MenuItem("View Full Context");
        viewContextItem.setOnAction(e -> {
            int selectedIndex = listView.getSelectionModel().getSelectedIndex();
            if (selectedIndex >= 0) {
                openContextViewer(listView, selectedIndex);
            }
        });

        MenuItem copyItem = new MenuItem("Copy Log Line");
        copyItem.setOnAction(e -> {
            String selectedItem = listView.getSelectionModel().getSelectedItem();
            if (selectedItem != null) {
                javafx.scene.input.Clipboard clipboard = javafx.scene.input.Clipboard.getSystemClipboard();
                javafx.scene.input.ClipboardContent content = new javafx.scene.input.ClipboardContent();
                content.putString(selectedItem);
                clipboard.setContent(content);
            }
        });

        contextMenu.getItems().addAll(viewContextItem, new SeparatorMenuItem(), copyItem);

        // Show context menu on right-click
        listView.setContextMenu(contextMenu);
    }

    private void openContextViewer(ListView<String> listView, int selectedIndex) {
        // Determine which pane
        List<LogEntry> entries = (listView == logListView1) ? allEntries1 : allEntries2;

        if (entries.isEmpty() || selectedIndex >= entries.size()) {
            return;
        }

        LogEntry selectedEntry = entries.get(selectedIndex);

        try {
            javafx.fxml.FXMLLoader loader = new javafx.fxml.FXMLLoader(
                getClass().getResource("/com/logviewer/context-viewer.fxml"));
            javafx.scene.Parent root = loader.load();

            ContextViewerController controller = loader.getController();
            controller.showContext(selectedEntry, entries, selectedIndex);

            javafx.stage.Stage stage = new javafx.stage.Stage();
            stage.setTitle("Smart Context Viewer - Line #" + (selectedIndex + 1));
            stage.setScene(new javafx.scene.Scene(root, 1400, 900));
            stage.show();

            globalStatus.setText("Opened Context Viewer for log line #" + (selectedIndex + 1));
        } catch (Exception e) {
            Alert alert = new Alert(Alert.AlertType.ERROR,
                "Failed to open context viewer: " + e.getMessage());
            alert.showAndWait();
            e.printStackTrace();
        }
    }

    // ==================== Pane 1 Actions ====================

    @FXML
    private void onLoadLog1() {
        loadLogFile(1);
    }

    @FXML
    private void onSearch1() {
        performSearch(1);
    }

    @FXML
    private void onClearSearch1() {
        searchField1.clear();
        displayEntries(allEntries1, logListView1, resultCount1);
        filteredEntries1 = new ArrayList<>(allEntries1);
    }

    @FXML
    private void onApplyFilter1() {
        applyFilters(1);
    }

    @FXML
    private void onResetFilter1() {
        resetFilters(1);
    }

    // ==================== Pane 2 Actions ====================

    @FXML
    private void onLoadLog2() {
        loadLogFile(2);
    }

    @FXML
    private void onSearch2() {
        performSearch(2);
    }

    @FXML
    private void onClearSearch2() {
        searchField2.clear();
        displayEntries(allEntries2, logListView2, resultCount2);
        filteredEntries2 = new ArrayList<>(allEntries2);
    }

    @FXML
    private void onApplyFilter2() {
        applyFilters(2);
    }

    @FXML
    private void onResetFilter2() {
        resetFilters(2);
    }

    // ==================== Core Logic Methods ====================

    private void loadLogFile(int pane) {
        FileChooser fileChooser = new FileChooser();
        fileChooser.setTitle("Select Log File - Pane " + pane);
        fileChooser.getExtensionFilters().addAll(
                new FileChooser.ExtensionFilter("Log Files", "*.log", "*.txt"),
                new FileChooser.ExtensionFilter("All Files", "*.*")
        );

        File file = fileChooser.showOpenDialog(loadButton1.getScene().getWindow());
        if (file == null) {
            return;
        }

        // Check file size (warn if over 600MB)
        double sizeMB = LogFileLoader.getFileSizeMB(file);
        if (sizeMB > 600) {
            Alert alert = new Alert(Alert.AlertType.WARNING,
                    String.format("File size is %.2f MB. Loading may take time. Continue?", sizeMB),
                    ButtonType.YES, ButtonType.NO);
            if (alert.showAndWait().orElse(ButtonType.NO) != ButtonType.YES) {
                return;
            }
        }

        // Update UI
        Label statusLabel = pane == 1 ? status1 : status2;
        Label fileNameLabel = pane == 1 ? fileName1 : fileName2;
        Label fileSizeLabel = pane == 1 ? fileSize1 : fileSize2;
        Button loadButton = pane == 1 ? loadButton1 : loadButton2;

        statusLabel.setText("Loading...");
        statusLabel.setStyle("-fx-text-fill: #ffc107;");
        fileNameLabel.setText(file.getName());
        fileSizeLabel.setText(String.format("Size: %.2f MB", sizeMB));
        loadButton.setDisable(true);
        progressBar.setVisible(true);

        // Load file in background
        LogFileLoader loader = new LogFileLoader(file);

        // Bind progress
        progressBar.progressProperty().bind(loader.progressProperty());
        globalStatus.textProperty().bind(loader.messageProperty());

        loader.setOnSucceeded(event -> {
            List<LogEntry> entries = loader.getValue();

            if (pane == 1) {
                allEntries1 = entries;
                filteredEntries1 = new ArrayList<>(entries);
                displayEntries(entries, logListView1, resultCount1);
                status1.setText("Ready");
                status1.setStyle("-fx-text-fill: #28a745;");
            } else {
                allEntries2 = entries;
                filteredEntries2 = new ArrayList<>(entries);
                displayEntries(entries, logListView2, resultCount2);
                status2.setText("Ready");
                status2.setStyle("-fx-text-fill: #28a745;");
            }

            loadButton.setDisable(false);
            progressBar.setVisible(false);
            progressBar.progressProperty().unbind();
            globalStatus.textProperty().unbind();
            globalStatus.setText(String.format("Loaded %,d lines from %s", entries.size(), file.getName()));
        });

        loader.setOnFailed(event -> {
            statusLabel.setText("Error");
            statusLabel.setStyle("-fx-text-fill: #dc3545;");
            loadButton.setDisable(false);
            progressBar.setVisible(false);
            progressBar.progressProperty().unbind();
            globalStatus.textProperty().unbind();

            Alert alert = new Alert(Alert.AlertType.ERROR,
                    "Failed to load file: " + loader.getException().getMessage());
            alert.showAndWait();
        });

        // Start loading in background thread
        Thread thread = new Thread(loader);
        thread.setDaemon(true);
        thread.start();
    }

    private void performSearch(int pane) {
        List<LogEntry> allEntries = pane == 1 ? allEntries1 : allEntries2;
        TextField searchField = pane == 1 ? searchField1 : searchField2;
        ListView<String> listView = pane == 1 ? logListView1 : logListView2;
        Label resultCount = pane == 1 ? resultCount1 : resultCount2;
        Label statusLabel = pane == 1 ? status1 : status2;

        if (allEntries.isEmpty()) {
            Alert alert = new Alert(Alert.AlertType.WARNING, "Please load a log file first.");
            alert.showAndWait();
            return;
        }

        String searchText = searchField.getText();
        FilterCriteria criteria = pane == 1 ? filterCriteria1 : filterCriteria2;
        criteria.setSearchText(searchText);

        // Get filter settings
        boolean includeError = pane == 1 ? errorCheck1.isSelected() : errorCheck2.isSelected();
        boolean includeWarn = pane == 1 ? warnCheck1.isSelected() : warnCheck2.isSelected();
        boolean includeInfo = pane == 1 ? infoCheck1.isSelected() : infoCheck2.isSelected();
        boolean includeDebug = pane == 1 ? debugCheck1.isSelected() : debugCheck2.isSelected();
        boolean includeTrace = pane == 1 ? traceCheck1.isSelected() : traceCheck2.isSelected();

        DatePicker dateFromPicker = pane == 1 ? dateFrom1 : dateFrom2;
        DatePicker dateToPicker = pane == 1 ? dateTo1 : dateTo2;
        TextField serviceFilterField = pane == 1 ? serviceFilter1 : serviceFilter2;

        LocalDateTime dateFromTime = dateFromPicker.getValue() != null ?
                dateFromPicker.getValue().atStartOfDay() : null;
        LocalDateTime dateToTime = dateToPicker.getValue() != null ?
                dateToPicker.getValue().atTime(LocalTime.MAX) : null;

        String serviceFilterText = serviceFilterField.getText();

        statusLabel.setText("Searching...");
        statusLabel.setStyle("-fx-text-fill: #ffc107;");
        progressBar.setVisible(true);
        progressBar.setProgress(-1);

        // Create search service
        LogSearchService searchService = new LogSearchService.Builder()
                .allEntries(allEntries)
                .searchText(searchText)
                .caseSensitive(false)
                .includeError(includeError)
                .includeWarn(includeWarn)
                .includeInfo(includeInfo)
                .includeDebug(includeDebug)
                .includeTrace(includeTrace)
                .dateFrom(dateFromTime)
                .dateTo(dateToTime)
                .serviceFilter(serviceFilterText)
                .build();

        searchService.setOnSucceeded(event -> {
            List<LogEntry> results = searchService.getValue();

            if (pane == 1) {
                filteredEntries1 = results;
            } else {
                filteredEntries2 = results;
            }

            displayEntries(results, listView, resultCount);

            statusLabel.setText("Ready");
            statusLabel.setStyle("-fx-text-fill: #28a745;");
            progressBar.setVisible(false);
            globalStatus.setText(String.format("Found %,d matches in Pane %d", results.size(), pane));
        });

        searchService.setOnFailed(event -> {
            statusLabel.setText("Error");
            statusLabel.setStyle("-fx-text-fill: #dc3545;");
            progressBar.setVisible(false);

            Alert alert = new Alert(Alert.AlertType.ERROR,
                    "Search failed: " + searchService.getException().getMessage());
            alert.showAndWait();
        });

        Thread thread = new Thread(searchService);
        thread.setDaemon(true);
        thread.start();
    }

    private void applyFilters(int pane) {
        performSearch(pane);
    }

    private void resetFilters(int pane) {
        if (pane == 1) {
            searchField1.clear();
            errorCheck1.setSelected(true);
            warnCheck1.setSelected(true);
            infoCheck1.setSelected(true);
            debugCheck1.setSelected(true);
            traceCheck1.setSelected(true);
            dateFrom1.setValue(null);
            dateTo1.setValue(null);
            serviceFilter1.clear();
            filterCriteria1.reset();
            displayEntries(allEntries1, logListView1, resultCount1);
            filteredEntries1 = new ArrayList<>(allEntries1);
        } else {
            searchField2.clear();
            errorCheck2.setSelected(true);
            warnCheck2.setSelected(true);
            infoCheck2.setSelected(true);
            debugCheck2.setSelected(true);
            traceCheck2.setSelected(true);
            dateFrom2.setValue(null);
            dateTo2.setValue(null);
            serviceFilter2.clear();
            filterCriteria2.reset();
            displayEntries(allEntries2, logListView2, resultCount2);
            filteredEntries2 = new ArrayList<>(allEntries2);
        }
    }

    private void displayEntries(List<LogEntry> entries, ListView<String> listView, Label countLabel) {
        // Determine which pane based on listView
        int pane = (listView == logListView1) ? 1 : 2;

        Platform.runLater(() -> {
            ObservableList<String> items = FXCollections.observableArrayList();

            // Limit display to prevent UI freeze (show first 50,000 lines)
            int displayLimit = Math.min(entries.size(), 50000);
            for (int i = 0; i < displayLimit; i++) {
                items.add(entries.get(i).getFormattedLine());
            }

            listView.setItems(items);
            countLabel.setText(String.format("Lines: %,d%s", entries.size(),
                    entries.size() > displayLimit ? " (showing first 50,000)" : ""));

            // Build error indices for navigation
            buildErrorIndices(entries, pane);
        });
    }

    @FXML
    private void onOpenCorrelation() {
        if (allEntries1.isEmpty() || allEntries2.isEmpty()) {
            Alert alert = new Alert(Alert.AlertType.WARNING,
                    "Please load log files in both panes before analyzing correlations.");
            alert.showAndWait();
            return;
        }

        try {
            javafx.fxml.FXMLLoader loader = new javafx.fxml.FXMLLoader(
                    getClass().getResource("/com/logviewer/correlation-view.fxml"));
            javafx.scene.Parent root = loader.load();

            CorrelationController controller = loader.getController();
            controller.setLogData(allEntries1, allEntries2);

            javafx.stage.Stage stage = new javafx.stage.Stage();
            stage.setTitle("Correlation Analysis - Track IDs Across Services");
            stage.setScene(new javafx.scene.Scene(root, 1200, 800));
            stage.show();

            globalStatus.setText("Opened Correlation Analysis window");
        } catch (Exception e) {
            Alert alert = new Alert(Alert.AlertType.ERROR,
                    "Failed to open correlation view: " + e.getMessage());
            alert.showAndWait();
            e.printStackTrace();
        }
    }

    @FXML
    private void onOpenSequenceDiagram() {
        // Use pane 1 if available, otherwise pane 2
        List<LogEntry> entries = !allEntries1.isEmpty() ? allEntries1 : allEntries2;

        if (entries.isEmpty()) {
            Alert alert = new Alert(Alert.AlertType.WARNING,
                    "Please load at least one log file to generate a sequence diagram.");
            alert.showAndWait();
            return;
        }

        try {
            javafx.fxml.FXMLLoader loader = new javafx.fxml.FXMLLoader(
                    getClass().getResource("/com/logviewer/sequence-diagram-view.fxml"));
            javafx.scene.Parent root = loader.load();

            SequenceDiagramController controller = loader.getController();
            controller.setLogEntries(entries);

            javafx.stage.Stage stage = new javafx.stage.Stage();
            stage.setTitle("Log Flow Sequence Diagram");
            stage.setScene(new javafx.scene.Scene(root, 1200, 800));
            stage.show();

            globalStatus.setText("Opened Sequence Diagram window");
        } catch (Exception e) {
            Alert alert = new Alert(Alert.AlertType.ERROR,
                    "Failed to open sequence diagram: " + e.getMessage());
            alert.showAndWait();
            e.printStackTrace();
        }
    }

    @FXML
    private void onOpenAutoRefresh() {
        try {
            javafx.fxml.FXMLLoader loader = new javafx.fxml.FXMLLoader(
                    getClass().getResource("/com/logviewer/auto-refresh-view.fxml"));
            javafx.scene.Parent root = loader.load();

            // Pass reference to main controller for auto-loading logs
            AutoRefreshController controller = loader.getController();
            controller.setMainController(this);

            javafx.stage.Stage stage = new javafx.stage.Stage();
            stage.setTitle("Auto-Refresh Log Viewer - AWS/Kubernetes");
            stage.setScene(new javafx.scene.Scene(root, 1200, 900));
            stage.show();

            globalStatus.setText("Opened Auto-Refresh Log Viewer");
        } catch (Exception e) {
            Alert alert = new Alert(Alert.AlertType.ERROR,
                    "Failed to open auto-refresh view: " + e.getMessage());
            alert.showAndWait();
            e.printStackTrace();
        }
    }

    @FXML
    private void onOpenSQLAnalyzer() {
        // Use pane 1 if available, otherwise pane 2
        List<LogEntry> entries = !allEntries1.isEmpty() ? allEntries1 : allEntries2;

        if (entries.isEmpty()) {
            Alert alert = new Alert(Alert.AlertType.WARNING,
                    "Please load at least one log file to analyze SQL queries.");
            alert.showAndWait();
            return;
        }

        try {
            javafx.fxml.FXMLLoader loader = new javafx.fxml.FXMLLoader(
                    getClass().getResource("/com/logviewer/sql-query-analyzer.fxml"));
            javafx.scene.Parent root = loader.load();

            SQLQueryAnalyzerController controller = loader.getController();
            controller.loadQueries(entries);

            javafx.stage.Stage stage = new javafx.stage.Stage();
            stage.setTitle("SQL Query Analyzer - Extract and Execute Queries");
            stage.setScene(new javafx.scene.Scene(root, 1600, 1000));
            stage.show();

            // Ensure cleanup when window closes
            stage.setOnCloseRequest(event -> controller.shutdown());

            globalStatus.setText("Opened SQL Query Analyzer window");
        } catch (Exception e) {
            Alert alert = new Alert(Alert.AlertType.ERROR,
                    "Failed to open SQL query analyzer: " + e.getMessage());
            alert.showAndWait();
            e.printStackTrace();
        }
    }

    @FXML
    private void onOpenMultiEnvMonitor() {
        try {
            javafx.fxml.FXMLLoader loader = new javafx.fxml.FXMLLoader(
                    getClass().getResource("/com/logviewer/multi-env-monitor.fxml"));
            javafx.scene.Parent root = loader.load();

            MultiEnvMonitorController controller = loader.getController();

            javafx.stage.Stage stage = new javafx.stage.Stage();
            stage.setTitle("Multi-Environment Monitor - Watch 4 Environments in Parallel");
            stage.setScene(new javafx.scene.Scene(root, 1800, 1000));
            stage.show();

            // Ensure cleanup when window closes
            stage.setOnCloseRequest(event -> controller.shutdown());

            globalStatus.setText("Opened Multi-Environment Monitor");
        } catch (Exception e) {
            Alert alert = new Alert(Alert.AlertType.ERROR,
                    "Failed to open multi-environment monitor: " + e.getMessage());
            alert.showAndWait();
            e.printStackTrace();
        }
    }

    /**
     * Load a log file into specified pane (called from AutoRefreshController)
     */
    public void loadLogFileIntoPane(File file, int pane) {
        Platform.runLater(() -> {
            if (pane == 1) {
                loadLogFileIntoPaneInternal(file, 1, status1, fileName1, fileSize1, logListView1, resultCount1);
            } else {
                loadLogFileIntoPaneInternal(file, 2, status2, fileName2, fileSize2, logListView2, resultCount2);
            }
        });
    }

    private void loadLogFileIntoPaneInternal(File file, int paneNumber, Label statusLabel,
                                             Label fileNameLabel, Label fileSizeLabel,
                                             ListView<String> listView, Label resultCount) {
        // Update UI
        double sizeMB = LogFileLoader.getFileSizeMB(file);
        statusLabel.setText("Loading...");
        statusLabel.setStyle("-fx-text-fill: #ffc107;");
        fileNameLabel.setText(file.getName());
        fileSizeLabel.setText(String.format("Size: %.2f MB", sizeMB));
        progressBar.setVisible(true);

        // Load file in background
        LogFileLoader loader = new LogFileLoader(file);

        // Bind progress
        progressBar.progressProperty().bind(loader.progressProperty());
        globalStatus.textProperty().bind(loader.messageProperty());

        loader.setOnSucceeded(event -> {
            List<LogEntry> entries = loader.getValue();

            if (paneNumber == 1) {
                allEntries1 = entries;
                filteredEntries1 = new ArrayList<>(entries);
                displayEntries(entries, listView, resultCount);
                status1.setText("Ready (Auto-loaded)");
                status1.setStyle("-fx-text-fill: #28a745;");
            } else {
                allEntries2 = entries;
                filteredEntries2 = new ArrayList<>(entries);
                displayEntries(entries, listView, resultCount);
                status2.setText("Ready (Auto-loaded)");
                status2.setStyle("-fx-text-fill: #28a745;");
            }

            progressBar.setVisible(false);
            progressBar.progressProperty().unbind();
            globalStatus.textProperty().unbind();
            globalStatus.setText(String.format("Auto-loaded %,d lines into Pane %d from %s",
                    entries.size(), paneNumber, file.getName()));
        });

        loader.setOnFailed(event -> {
            statusLabel.setText("Error");
            statusLabel.setStyle("-fx-text-fill: #dc3545;");
            progressBar.setVisible(false);
            progressBar.progressProperty().unbind();
            globalStatus.textProperty().unbind();

            Alert alert = new Alert(Alert.AlertType.ERROR,
                    "Failed to load file: " + loader.getException().getMessage());
            alert.showAndWait();
        });

        // Start loading in background thread
        Thread thread = new Thread(loader);
        thread.setDaemon(true);
        thread.start();
    }

    @FXML
    private void onHelp() {
        Alert alert = new Alert(Alert.AlertType.INFORMATION);
        alert.setTitle("Log Viewer Help");
        alert.setHeaderText("Microservices Log Viewer");
        alert.setContentText(
            "Features:\n\n" +
            "1. DUAL-PANE: View two logs side-by-side\n" +
            "2. FAST SEARCH: Parallel search across millions of lines\n" +
            "3. FILTERS: Filter by log level, date, service name\n" +
            "4. CORRELATION: Track Request IDs, Transaction IDs across services\n" +
            "5. AUTO-REFRESH: Download logs from Kubernetes pods automatically\n\n" +
            "How to use:\n" +
            "- Load logs using 'Load Log File' buttons\n" +
            "- Search using text field + Enter\n" +
            "- Apply multiple filters simultaneously\n" +
            "- Click 'Correlation Analysis' to find related entries\n" +
            "- Click 'Auto-Refresh Logs' to configure kubectl log downloads\n\n" +
            "Supported file size: Up to 600MB per pane"
        );
        alert.showAndWait();
    }

    // ==================== Error Navigation ====================

    @FXML
    private void onNextError1() {
        jumpToNextError(1);
    }

    @FXML
    private void onPrevError1() {
        jumpToPrevError(1);
    }

    @FXML
    private void onNextError2() {
        jumpToNextError(2);
    }

    @FXML
    private void onPrevError2() {
        jumpToPrevError(2);
    }

    private void jumpToNextError(int pane) {
        List<Integer> errorIndices = pane == 1 ? errorIndices1 : errorIndices2;
        ListView<String> listView = pane == 1 ? logListView1 : logListView2;

        if (errorIndices.isEmpty()) {
            showNoErrorsAlert();
            return;
        }

        if (pane == 1) {
            currentErrorIndex1++;
            if (currentErrorIndex1 >= errorIndices.size()) {
                currentErrorIndex1 = 0; // Wrap around
            }
            listView.scrollTo(errorIndices.get(currentErrorIndex1));
            listView.getSelectionModel().select(errorIndices.get(currentErrorIndex1));
            updateErrorCountLabel(1, currentErrorIndex1 + 1, errorIndices.size());
        } else {
            currentErrorIndex2++;
            if (currentErrorIndex2 >= errorIndices.size()) {
                currentErrorIndex2 = 0; // Wrap around
            }
            listView.scrollTo(errorIndices.get(currentErrorIndex2));
            listView.getSelectionModel().select(errorIndices.get(currentErrorIndex2));
            updateErrorCountLabel(2, currentErrorIndex2 + 1, errorIndices.size());
        }
    }

    private void jumpToPrevError(int pane) {
        List<Integer> errorIndices = pane == 1 ? errorIndices1 : errorIndices2;
        ListView<String> listView = pane == 1 ? logListView1 : logListView2;

        if (errorIndices.isEmpty()) {
            showNoErrorsAlert();
            return;
        }

        if (pane == 1) {
            currentErrorIndex1--;
            if (currentErrorIndex1 < 0) {
                currentErrorIndex1 = errorIndices.size() - 1; // Wrap around
            }
            listView.scrollTo(errorIndices.get(currentErrorIndex1));
            listView.getSelectionModel().select(errorIndices.get(currentErrorIndex1));
            updateErrorCountLabel(1, currentErrorIndex1 + 1, errorIndices.size());
        } else {
            currentErrorIndex2--;
            if (currentErrorIndex2 < 0) {
                currentErrorIndex2 = errorIndices.size() - 1; // Wrap around
            }
            listView.scrollTo(errorIndices.get(currentErrorIndex2));
            listView.getSelectionModel().select(errorIndices.get(currentErrorIndex2));
            updateErrorCountLabel(2, currentErrorIndex2 + 1, errorIndices.size());
        }
    }

    private void buildErrorIndices(List<LogEntry> entries, int pane) {
        List<Integer> errorIndices = pane == 1 ? errorIndices1 : errorIndices2;
        errorIndices.clear();

        int displayLimit = Math.min(entries.size(), 50000);
        for (int i = 0; i < displayLimit; i++) {
            String line = entries.get(i).getFormattedLine().toUpperCase();
            if (line.contains("ERROR") || line.contains("EXCEPTION") || line.contains("FATAL")) {
                errorIndices.add(i);
            }
        }

        if (pane == 1) {
            currentErrorIndex1 = -1;
            updateErrorCountLabel(1, 0, errorIndices.size());
        } else {
            currentErrorIndex2 = -1;
            updateErrorCountLabel(2, 0, errorIndices.size());
        }
    }

    private void updateErrorCountLabel(int pane, int current, int total) {
        Platform.runLater(() -> {
            Label label = pane == 1 ? errorCount1 : errorCount2;
            if (total == 0) {
                label.setText("");
            } else if (current == 0) {
                label.setText(String.format("(%d errors)", total));
            } else {
                label.setText(String.format("Error %d/%d", current, total));
            }
        });
    }

    private void showNoErrorsAlert() {
        Alert alert = new Alert(Alert.AlertType.INFORMATION);
        alert.setTitle("No Errors");
        alert.setHeaderText(null);
        alert.setContentText("No errors found in the current log view.");
        alert.showAndWait();
    }

    // ==================== Trace ID Correlation ====================

    @FXML
    private void onHighlightTrace() {
        String traceId = traceIdField.getText().trim();

        if (traceId.isEmpty()) {
            Alert alert = new Alert(Alert.AlertType.WARNING);
            alert.setTitle("No Trace ID");
            alert.setHeaderText(null);
            alert.setContentText("Please enter a Request ID or Trace ID to highlight.");
            alert.showAndWait();
            return;
        }

        currentTraceId = traceId;
        com.logviewer.ui.ColoredLogCell.setHighlightTraceId(traceId);

        // Refresh both list views to apply highlighting
        refreshListViews();

        // Show count of matches
        showTraceIdMatchCount(traceId);
    }

    @FXML
    private void onClearTrace() {
        traceIdField.clear();
        currentTraceId = null;
        com.logviewer.ui.ColoredLogCell.setHighlightTraceId(null);

        // Refresh both list views to remove highlighting
        refreshListViews();
    }

    private void refreshListViews() {
        Platform.runLater(() -> {
            // Force list views to refresh by resetting items
            ObservableList<String> items1 = logListView1.getItems();
            logListView1.setItems(null);
            logListView1.setItems(items1);

            ObservableList<String> items2 = logListView2.getItems();
            logListView2.setItems(null);
            logListView2.setItems(items2);
        });
    }

    private void showTraceIdMatchCount(String traceId) {
        int count1 = 0;
        int count2 = 0;

        for (String item : logListView1.getItems()) {
            if (item.contains(traceId)) {
                count1++;
            }
        }

        for (String item : logListView2.getItems()) {
            if (item.contains(traceId)) {
                count2++;
            }
        }

        String message = String.format("Found %d matches in Pane 1 and %d matches in Pane 2.",
                count1, count2);

        Alert alert = new Alert(Alert.AlertType.INFORMATION);
        alert.setTitle("Trace ID Matches");
        alert.setHeaderText("Highlighting: " + traceId);
        alert.setContentText(message);
        alert.showAndWait();
    }

    // ==================== Timestamp Synchronization ====================

    private boolean isSyncing = false;

    private void setupTimestampSync() {
        // Listen to selection changes in both list views
        logListView1.getSelectionModel().selectedIndexProperty().addListener((obs, oldVal, newVal) -> {
            if (syncScrollCheckbox.isSelected() && !isSyncing && newVal != null && newVal.intValue() >= 0) {
                syncScrollByTimestamp(1, newVal.intValue());
            }
        });

        logListView2.getSelectionModel().selectedIndexProperty().addListener((obs, oldVal, newVal) -> {
            if (syncScrollCheckbox.isSelected() && !isSyncing && newVal != null && newVal.intValue() >= 0) {
                syncScrollByTimestamp(2, newVal.intValue());
            }
        });
    }

    private void syncScrollByTimestamp(int sourcePane, int selectedIndex) {
        isSyncing = true;

        try {
            ListView<String> sourceList = sourcePane == 1 ? logListView1 : logListView2;
            ListView<String> targetList = sourcePane == 1 ? logListView2 : logListView1;
            List<LogEntry> targetEntries = sourcePane == 1 ? allEntries2 : allEntries1;

            if (targetEntries.isEmpty() || sourceList.getItems().isEmpty()) {
                return;
            }

            // Get the selected line from source
            String selectedLine = sourceList.getItems().get(selectedIndex);

            // Extract timestamp from selected line
            LocalDateTime selectedTime = extractTimestamp(selectedLine);

            if (selectedTime == null) {
                return;
            }

            // Find closest timestamp in target pane
            int closestIndex = findClosestTimestampIndex(targetList.getItems(), selectedTime);

            if (closestIndex >= 0) {
                targetList.scrollTo(closestIndex);
                targetList.getSelectionModel().select(closestIndex);
            }

        } finally {
            isSyncing = false;
        }
    }

    private LocalDateTime extractTimestamp(String logLine) {
        try {
            // Common timestamp patterns:
            // 2024-01-15 14:30:45
            // 2024-01-15T14:30:45
            // [2024-01-15 14:30:45.123]

            String pattern1 = "\\d{4}-\\d{2}-\\d{2}[T ]\\d{2}:\\d{2}:\\d{2}";
            java.util.regex.Pattern p = java.util.regex.Pattern.compile(pattern1);
            java.util.regex.Matcher m = p.matcher(logLine);

            if (m.find()) {
                String timestamp = m.group().replace('T', ' ');
                return LocalDateTime.parse(timestamp, java.time.format.DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"));
            }
        } catch (Exception e) {
            // Timestamp parsing failed
        }

        return null;
    }

    private int findClosestTimestampIndex(ObservableList<String> items, LocalDateTime targetTime) {
        int closestIndex = -1;
        long minDiff = Long.MAX_VALUE;

        for (int i = 0; i < items.size(); i++) {
            LocalDateTime itemTime = extractTimestamp(items.get(i));

            if (itemTime != null) {
                long diff = Math.abs(java.time.Duration.between(targetTime, itemTime).toMillis());

                if (diff < minDiff) {
                    minDiff = diff;
                    closestIndex = i;
                }

                // If we find exact match or very close (within 1 second), use it
                if (diff < 1000) {
                    return closestIndex;
                }
            }
        }

        return closestIndex;
    }
}
---------------------------------------------
package com.logviewer;

import com.logviewer.model.Environment;
import com.logviewer.model.LogEntry;
import com.logviewer.service.LogFileLoader;
import javafx.application.Platform;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.fxml.FXML;
import javafx.scene.control.*;
import javafx.scene.layout.HBox;
import javafx.stage.FileChooser;

import java.io.File;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

/**
 * Controller for Multi-Environment Monitor
 * Allows monitoring 4 environments in parallel
 */
public class MultiEnvMonitorController {

    // Tab controls
    @FXML private TabPane environmentTabs;
    @FXML private Tab tab1, tab2, tab3, tab4;

    // Environment 1 controls
    @FXML private Label env1Name;
    @FXML private Label env1Status;
    @FXML private Label env1Stats;
    @FXML private Button env1LoadButton;
    @FXML private CheckBox env1AutoRefresh;
    @FXML private TextField env1RefreshInterval;
    @FXML private ListView<String> env1ListView;
    @FXML private TextField env1SearchField;
    @FXML private Button env1NextError;
    @FXML private Button env1PrevError;

    // Environment 2 controls
    @FXML private Label env2Name;
    @FXML private Label env2Status;
    @FXML private Label env2Stats;
    @FXML private Button env2LoadButton;
    @FXML private CheckBox env2AutoRefresh;
    @FXML private TextField env2RefreshInterval;
    @FXML private ListView<String> env2ListView;
    @FXML private TextField env2SearchField;
    @FXML private Button env2NextError;
    @FXML private Button env2PrevError;

    // Environment 3 controls
    @FXML private Label env3Name;
    @FXML private Label env3Status;
    @FXML private Label env3Stats;
    @FXML private Button env3LoadButton;
    @FXML private CheckBox env3AutoRefresh;
    @FXML private TextField env3RefreshInterval;
    @FXML private ListView<String> env3ListView;
    @FXML private TextField env3SearchField;
    @FXML private Button env3NextError;
    @FXML private Button env3PrevError;

    // Environment 4 controls
    @FXML private Label env4Name;
    @FXML private Label env4Status;
    @FXML private Label env4Stats;
    @FXML private Button env4LoadButton;
    @FXML private CheckBox env4AutoRefresh;
    @FXML private TextField env4RefreshInterval;
    @FXML private ListView<String> env4ListView;
    @FXML private TextField env4SearchField;
    @FXML private Button env4NextError;
    @FXML private Button env4PrevError;

    // Global controls
    @FXML private TextField globalTraceId;
    @FXML private Button globalSearchButton;
    @FXML private CheckBox syncScrollCheckbox;

    // Data storage
    private Map<Integer, Environment> environments = new HashMap<>();
    private Map<Integer, List<LogEntry>> envLogEntries = new HashMap<>();
    private Map<Integer, List<Integer>> envErrorIndices = new HashMap<>();
    private Map<Integer, Integer> envCurrentErrorIndex = new HashMap<>();
    private Map<Integer, File> envLogFiles = new HashMap<>();

    private ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(4);

    public void initialize() {
        // Initialize 4 environments
        environments.put(1, new Environment("Development", "#17a2b8"));
        environments.put(2, new Environment("Staging", "#ffc107"));
        environments.put(3, new Environment("Production", "#dc3545"));
        environments.put(4, new Environment("DR/Backup", "#6c757d"));

        for (int i = 1; i <= 4; i++) {
            envLogEntries.put(i, new ArrayList<>());
            envErrorIndices.put(i, new ArrayList<>());
            envCurrentErrorIndex.put(i, -1);
        }

        // Set environment names and colors
        setEnvironmentHeader(1, env1Name, tab1);
        setEnvironmentHeader(2, env2Name, tab2);
        setEnvironmentHeader(3, env3Name, tab3);
        setEnvironmentHeader(4, env4Name, tab4);

        // Setup list views with cell factory for color coding
        setupListView(env1ListView);
        setupListView(env2ListView);
        setupListView(env3ListView);
        setupListView(env4ListView);

        // Set default refresh intervals
        env1RefreshInterval.setText("5");
        env2RefreshInterval.setText("5");
        env3RefreshInterval.setText("5");
        env4RefreshInterval.setText("5");

        // Setup auto-refresh listeners
        env1AutoRefresh.selectedProperty().addListener((obs, old, newVal) -> toggleAutoRefresh(1, newVal));
        env2AutoRefresh.selectedProperty().addListener((obs, old, newVal) -> toggleAutoRefresh(2, newVal));
        env3AutoRefresh.selectedProperty().addListener((obs, old, newVal) -> toggleAutoRefresh(3, newVal));
        env4AutoRefresh.selectedProperty().addListener((obs, old, newVal) -> toggleAutoRefresh(4, newVal));
    }

    private void setEnvironmentHeader(int envNum, Label nameLabel, Tab tab) {
        Environment env = environments.get(envNum);
        nameLabel.setText(env.getName());
        nameLabel.setStyle("-fx-text-fill: " + env.getColor() + "; -fx-font-weight: bold; -fx-font-size: 16;");
        tab.setStyle("-fx-background-color: " + env.getColor() + ";");
    }

    private void setupListView(ListView<String> listView) {
        listView.setCellFactory(lv -> new ListCell<String>() {
            @Override
            protected void updateItem(String item, boolean empty) {
                super.updateItem(item, empty);
                if (empty || item == null) {
                    setText(null);
                    setStyle("");
                } else {
                    setText(item);
                    String upperItem = item.toUpperCase();

                    if (upperItem.contains("[ERROR]")) {
                        setStyle("-fx-background-color: #ffcccc; -fx-text-fill: #cc0000;");
                    } else if (upperItem.contains("[WARN]")) {
                        setStyle("-fx-background-color: #fff3cd; -fx-text-fill: #856404;");
                    } else if (upperItem.contains("[INFO]")) {
                        setStyle("-fx-background-color: #d1ecf1; -fx-text-fill: #0c5460;");
                    } else if (upperItem.contains("[DEBUG]")) {
                        setStyle("-fx-background-color: #e2e3e5; -fx-text-fill: #383d41;");
                    } else {
                        setStyle("");
                    }
                }
            }
        });
    }

    @FXML
    private void onLoadEnv1() { loadEnvironment(1); }

    @FXML
    private void onLoadEnv2() { loadEnvironment(2); }

    @FXML
    private void onLoadEnv3() { loadEnvironment(3); }

    @FXML
    private void onLoadEnv4() { loadEnvironment(4); }

    private void loadEnvironment(int envNum) {
        FileChooser fileChooser = new FileChooser();
        fileChooser.setTitle("Load Log File for " + environments.get(envNum).getName());
        fileChooser.getExtensionFilters().addAll(
            new FileChooser.ExtensionFilter("Log Files", "*.log", "*.txt"),
            new FileChooser.ExtensionFilter("All Files", "*.*")
        );

        if (envLogFiles.get(envNum) != null) {
            fileChooser.setInitialDirectory(envLogFiles.get(envNum).getParentFile());
        }

        File file = fileChooser.showOpenDialog(getListView(envNum).getScene().getWindow());
        if (file != null) {
            envLogFiles.put(envNum, file);
            loadLogFile(envNum, file);
        }
    }

    private void loadLogFile(int envNum, File file) {
        getStatusLabel(envNum).setText("Loading...");
        getStatusLabel(envNum).setStyle("-fx-text-fill: #ffc107;");

        LogFileLoader loader = new LogFileLoader(file);

        loader.setOnSucceeded(event -> {
            List<LogEntry> entries = loader.getValue();
            envLogEntries.put(envNum, entries);

            displayLogs(envNum, entries);
            updateStats(envNum, entries);
            buildErrorIndices(envNum, entries);

            environments.get(envNum).setLogFilePath(file.getAbsolutePath());
            environments.get(envNum).setStatus("CONNECTED");

            getStatusLabel(envNum).setText("â Connected");
            getStatusLabel(envNum).setStyle("-fx-text-fill: #28a745;");
        });

        loader.setOnFailed(event -> {
            getStatusLabel(envNum).setText("â Error");
            getStatusLabel(envNum).setStyle("-fx-text-fill: #dc3545;");

            Alert alert = new Alert(Alert.AlertType.ERROR,
                "Failed to load log file: " + loader.getException().getMessage());
            alert.showAndWait();
        });

        new Thread(loader).start();
    }

    private void displayLogs(int envNum, List<LogEntry> entries) {
        ObservableList<String> items = FXCollections.observableArrayList();

        int displayLimit = Math.min(entries.size(), 50000);
        for (int i = 0; i < displayLimit; i++) {
            items.add(entries.get(i).getFormattedLine());
        }

        getListView(envNum).setItems(items);
    }

    private void updateStats(int envNum, List<LogEntry> entries) {
        int errorCount = 0;
        int warnCount = 0;

        for (LogEntry entry : entries) {
            String line = entry.getFormattedLine().toUpperCase();
            if (line.contains("[ERROR]")) errorCount++;
            else if (line.contains("[WARN]")) warnCount++;
        }

        Environment env = environments.get(envNum);
        env.setTotalLines(entries.size());
        env.setErrorCount(errorCount);
        env.setWarnCount(warnCount);

        String stats = String.format("Lines: %,d | Errors: %d | Warnings: %d",
            entries.size(), errorCount, warnCount);
        getStatsLabel(envNum).setText(stats);
    }

    private void buildErrorIndices(int envNum, List<LogEntry> entries) {
        List<Integer> errorIndices = new ArrayList<>();
        for (int i = 0; i < entries.size(); i++) {
            if (entries.get(i).getFormattedLine().toUpperCase().contains("[ERROR]")) {
                errorIndices.add(i);
            }
        }
        envErrorIndices.put(envNum, errorIndices);
        envCurrentErrorIndex.put(envNum, -1);
    }

    @FXML
    private void onEnv1NextError() { navigateToError(1, true); }

    @FXML
    private void onEnv1PrevError() { navigateToError(1, false); }

    @FXML
    private void onEnv2NextError() { navigateToError(2, true); }

    @FXML
    private void onEnv2PrevError() { navigateToError(2, false); }

    @FXML
    private void onEnv3NextError() { navigateToError(3, true); }

    @FXML
    private void onEnv3PrevError() { navigateToError(3, false); }

    @FXML
    private void onEnv4NextError() { navigateToError(4, true); }

    @FXML
    private void onEnv4PrevError() { navigateToError(4, false); }

    private void navigateToError(int envNum, boolean next) {
        List<Integer> errorIndices = envErrorIndices.get(envNum);
        if (errorIndices.isEmpty()) return;

        int currentIndex = envCurrentErrorIndex.get(envNum);
        if (next) {
            currentIndex = (currentIndex + 1) % errorIndices.size();
        } else {
            currentIndex = (currentIndex - 1 + errorIndices.size()) % errorIndices.size();
        }

        envCurrentErrorIndex.put(envNum, currentIndex);
        int errorLine = errorIndices.get(currentIndex);
        getListView(envNum).scrollTo(errorLine);
        getListView(envNum).getSelectionModel().select(errorLine);
    }

    @FXML
    private void onGlobalSearch() {
        String traceId = globalTraceId.getText().trim();
        if (traceId.isEmpty()) {
            Alert alert = new Alert(Alert.AlertType.WARNING,
                "Please enter a Trace ID to search across all environments.");
            alert.showAndWait();
            return;
        }

        // Search and highlight in all environments
        for (int envNum = 1; envNum <= 4; envNum++) {
            highlightTraceId(envNum, traceId);
        }
    }

    private void highlightTraceId(int envNum, String traceId) {
        List<LogEntry> entries = envLogEntries.get(envNum);
        if (entries.isEmpty()) return;

        ObservableList<String> items = FXCollections.observableArrayList();
        for (LogEntry entry : entries) {
            String line = entry.getFormattedLine();
            items.add(line);
        }

        getListView(envNum).setItems(items);

        // Find first occurrence and scroll to it
        for (int i = 0; i < entries.size(); i++) {
            if (entries.get(i).getFormattedLine().contains(traceId)) {
                getListView(envNum).scrollTo(i);
                getListView(envNum).getSelectionModel().select(i);
                break;
            }
        }
    }

    private void toggleAutoRefresh(int envNum, boolean enabled) {
        Environment env = environments.get(envNum);
        env.setAutoRefresh(enabled);

        if (enabled) {
            int interval = Integer.parseInt(getRefreshIntervalField(envNum).getText());
            env.setRefreshInterval(interval);
            scheduleAutoRefresh(envNum);
        }
    }

    private void scheduleAutoRefresh(int envNum) {
        Environment env = environments.get(envNum);
        File logFile = envLogFiles.get(envNum);

        if (logFile == null) return;

        scheduler.scheduleAtFixedRate(() -> {
            if (env.isAutoRefresh()) {
                Platform.runLater(() -> loadLogFile(envNum, logFile));
            }
        }, env.getRefreshInterval(), env.getRefreshInterval(), TimeUnit.SECONDS);
    }

    // Helper methods to get controls by environment number
    private ListView<String> getListView(int envNum) {
        switch (envNum) {
            case 1: return env1ListView;
            case 2: return env2ListView;
            case 3: return env3ListView;
            case 4: return env4ListView;
            default: return null;
        }
    }

    private Label getStatusLabel(int envNum) {
        switch (envNum) {
            case 1: return env1Status;
            case 2: return env2Status;
            case 3: return env3Status;
            case 4: return env4Status;
            default: return null;
        }
    }

    private Label getStatsLabel(int envNum) {
        switch (envNum) {
            case 1: return env1Stats;
            case 2: return env2Stats;
            case 3: return env3Stats;
            case 4: return env4Stats;
            default: return null;
        }
    }

    private TextField getRefreshIntervalField(int envNum) {
        switch (envNum) {
            case 1: return env1RefreshInterval;
            case 2: return env2RefreshInterval;
            case 3: return env3RefreshInterval;
            case 4: return env4RefreshInterval;
            default: return null;
        }
    }

    public void shutdown() {
        scheduler.shutdown();
    }
}
---------------------------------

package com.logviewer;

import com.logviewer.model.LogEntry;
import com.logviewer.model.SequenceEvent;
import com.logviewer.service.SequenceDiagramAnalyzer;
import javafx.fxml.FXML;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.control.*;
import javafx.scene.paint.Color;
import javafx.scene.text.Font;

import java.util.*;

public class SequenceDiagramController {

    @FXML private Canvas sequenceCanvas;
    @FXML private ComboBox<String> requestIdSelector;
    @FXML private ScrollPane canvasScrollPane;
    @FXML private TextArea eventDetailsArea;
    @FXML private Label statsLabel;

    private List<LogEntry> logEntries;
    private Map<String, List<SequenceEvent>> sequencesByRequestId;
    private SequenceDiagramAnalyzer analyzer;

    private static final int SERVICE_WIDTH = 150;
    private static final int SERVICE_HEIGHT = 40;
    private static final int VERTICAL_SPACING = 60;
    private static final int HORIZONTAL_MARGIN = 50;
    private static final int TOP_MARGIN = 80;

    @FXML
    public void initialize() {
        analyzer = new SequenceDiagramAnalyzer();

        // Setup canvas click handler for event details
        sequenceCanvas.setOnMouseClicked(event -> {
            handleCanvasClick(event.getX(), event.getY());
        });

        // Setup request ID selector
        requestIdSelector.setOnAction(e -> drawSequenceDiagram());
    }

    public void setLogEntries(List<LogEntry> entries) {
        this.logEntries = entries;
        analyzeAndDisplay();
    }

    private void analyzeAndDisplay() {
        if (logEntries == null || logEntries.isEmpty()) {
            return;
        }

        // Analyze logs to build sequences
        sequencesByRequestId = analyzer.analyzeSequence(logEntries);

        // Populate request ID selector
        requestIdSelector.getItems().clear();
        requestIdSelector.getItems().addAll(sequencesByRequestId.keySet());

        if (!sequencesByRequestId.isEmpty()) {
            // Select first request ID
            requestIdSelector.getSelectionModel().selectFirst();
            drawSequenceDiagram();
        }

        // Update stats
        int totalEvents = sequencesByRequestId.values().stream()
            .mapToInt(List::size)
            .sum();
        statsLabel.setText(String.format("Found %d sequences with %d total events",
            sequencesByRequestId.size(), totalEvents));
    }

    private void drawSequenceDiagram() {
        String selectedRequestId = requestIdSelector.getValue();
        if (selectedRequestId == null) {
            return;
        }

        List<SequenceEvent> events = sequencesByRequestId.get(selectedRequestId);
        if (events == null || events.isEmpty()) {
            return;
        }

        // Get all services
        Set<String> services = analyzer.extractServices(events);
        List<String> serviceList = new ArrayList<>(services);

        // Calculate canvas size
        int canvasWidth = Math.max(800, HORIZONTAL_MARGIN * 2 + serviceList.size() * SERVICE_WIDTH);
        int canvasHeight = Math.max(600, TOP_MARGIN + events.size() * VERTICAL_SPACING + 100);

        sequenceCanvas.setWidth(canvasWidth);
        sequenceCanvas.setHeight(canvasHeight);

        GraphicsContext gc = sequenceCanvas.getGraphicsContext2D();

        // Clear canvas
        gc.setFill(Color.WHITE);
        gc.fillRect(0, 0, canvasWidth, canvasHeight);

        // Draw title
        gc.setFont(Font.font("Arial", 16));
        gc.setFill(Color.BLACK);
        gc.fillText("Sequence Diagram - Request ID: " + selectedRequestId, 20, 30);

        // Draw service boxes and lifelines
        Map<String, Integer> servicePositions = new HashMap<>();
        int x = HORIZONTAL_MARGIN;

        for (String service : serviceList) {
            servicePositions.put(service, x + SERVICE_WIDTH / 2);

            // Draw service box
            gc.setStroke(Color.DARKBLUE);
            gc.setLineWidth(2);
            gc.strokeRect(x, TOP_MARGIN, SERVICE_WIDTH, SERVICE_HEIGHT);
            gc.setFill(Color.LIGHTBLUE);
            gc.fillRect(x, TOP_MARGIN, SERVICE_WIDTH, SERVICE_HEIGHT);

            // Draw service name
            gc.setFill(Color.BLACK);
            gc.setFont(Font.font("Arial", 12));
            String displayName = service.length() > 15 ? service.substring(0, 15) + "..." : service;
            gc.fillText(displayName, x + 10, TOP_MARGIN + 25);

            // Draw lifeline (vertical dotted line)
            gc.setStroke(Color.GRAY);
            gc.setLineDashes(5, 5);
            gc.strokeLine(x + SERVICE_WIDTH / 2, TOP_MARGIN + SERVICE_HEIGHT,
                         x + SERVICE_WIDTH / 2, canvasHeight - 20);
            gc.setLineDashes(); // Reset to solid line

            x += SERVICE_WIDTH;
        }

        // Draw events (arrows between services)
        int y = TOP_MARGIN + SERVICE_HEIGHT + 40;

        for (int i = 0; i < events.size(); i++) {
            SequenceEvent event = events.get(i);

            Integer fromX = servicePositions.get(event.getFromService());
            Integer toX = servicePositions.get(event.getToService());

            if (fromX != null && toX != null) {
                // Set color based on status
                if ("ERROR".equals(event.getStatus())) {
                    gc.setStroke(Color.RED);
                    gc.setFill(Color.RED);
                } else {
                    gc.setStroke(Color.GREEN);
                    gc.setFill(Color.GREEN);
                }

                gc.setLineWidth(2);

                // Draw arrow
                drawArrow(gc, fromX, y, toX, y);

                // Draw operation label
                gc.setFont(Font.font("Arial", 10));
                String label = String.format("%s (%dms)", event.getOperation(), event.getDurationMs());
                if (label.length() > 30) {
                    label = label.substring(0, 30) + "...";
                }

                int labelX = Math.min(fromX, toX) + Math.abs(fromX - toX) / 2 - 40;
                gc.fillText(label, labelX, y - 5);

                y += VERTICAL_SPACING;
            }
        }
    }

    private void drawArrow(GraphicsContext gc, double x1, double y1, double x2, double y2) {
        // Draw line
        gc.strokeLine(x1, y1, x2, y2);

        // Draw arrowhead
        double arrowLength = 10;
        double arrowWidth = 5;

        double angle = Math.atan2(y2 - y1, x2 - x1);

        double x3 = x2 - arrowLength * Math.cos(angle - Math.PI / 6);
        double y3 = y2 - arrowLength * Math.sin(angle - Math.PI / 6);

        double x4 = x2 - arrowLength * Math.cos(angle + Math.PI / 6);
        double y4 = y2 - arrowLength * Math.sin(angle + Math.PI / 6);

        gc.fillPolygon(new double[]{x2, x3, x4}, new double[]{y2, y3, y4}, 3);
    }

    private void handleCanvasClick(double x, double y) {
        String selectedRequestId = requestIdSelector.getValue();
        if (selectedRequestId == null) {
            return;
        }

        List<SequenceEvent> events = sequencesByRequestId.get(selectedRequestId);
        if (events == null) {
            return;
        }

        // Find clicked event
        int eventY = TOP_MARGIN + SERVICE_HEIGHT + 40;
        for (SequenceEvent event : events) {
            if (y >= eventY - 20 && y <= eventY + 20) {
                showEventDetails(event);
                return;
            }
            eventY += VERTICAL_SPACING;
        }
    }

    private void showEventDetails(SequenceEvent event) {
        StringBuilder details = new StringBuilder();
        details.append("=== Event Details ===\n\n");
        details.append("From: ").append(event.getFromService()).append("\n");
        details.append("To: ").append(event.getToService()).append("\n");
        details.append("Operation: ").append(event.getOperation()).append("\n");
        details.append("Duration: ").append(event.getDurationMs()).append(" ms\n");
        details.append("Status: ").append(event.getStatus()).append("\n");

        if (event.getStartTime() != null) {
            details.append("Time: ").append(event.getStartTime()).append("\n");
        }

        if (event.getErrorMessage() != null) {
            details.append("\nError: ").append(event.getErrorMessage()).append("\n");
        }

        details.append("\nLog Line:\n").append(event.getLogLine());

        eventDetailsArea.setText(details.toString());
    }

    @FXML
    private void onRefresh() {
        analyzeAndDisplay();
    }

    @FXML
    private void onExport() {
        Alert alert = new Alert(Alert.AlertType.INFORMATION);
        alert.setTitle("Export");
        alert.setHeaderText("Export Sequence Diagram");
        alert.setContentText("Export functionality will be available soon!");
        alert.showAndWait();
    }
}
---------------------
package com.logviewer;

import com.logviewer.model.LogEntry;
import com.logviewer.model.SQLQueryInfo;
import com.logviewer.service.SQLQueryExtractor;
import javafx.application.Platform;
import javafx.beans.property.SimpleObjectProperty;
import javafx.beans.property.SimpleStringProperty;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.fxml.FXML;
import javafx.scene.control.*;
import javafx.scene.control.cell.PropertyValueFactory;
import javafx.scene.input.Clipboard;
import javafx.scene.input.ClipboardContent;
import javafx.scene.layout.VBox;
import javafx.stage.FileChooser;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * Controller for SQL Query Analyzer window
 * Shows all SQL queries extracted from logs in chronological sequence
 */
public class SQLQueryAnalyzerController {

    @FXML private TableView<SQLQueryInfo> queryTableView;
    @FXML private TableColumn<SQLQueryInfo, Integer> lineNumberColumn;
    @FXML private TableColumn<SQLQueryInfo, String> queryTypeColumn;
    @FXML private TableColumn<SQLQueryInfo, String> queryPreviewColumn;
    @FXML private TableColumn<SQLQueryInfo, Long> durationColumn;
    @FXML private TableColumn<SQLQueryInfo, String> statusColumn;
    @FXML private TableColumn<SQLQueryInfo, LocalDateTime> timeColumn;

    @FXML private TextArea queryDetailsArea;
    @FXML private TextArea executionDetailsArea;
    @FXML private TextArea logLineArea;

    @FXML private Label statsLabel;
    @FXML private Label selectedQueryLabel;

    @FXML private Button copyQueryButton;
    @FXML private Button executeButton;
    @FXML private Button exportResultsButton;

    @FXML private TextField databricksHostField;
    @FXML private TextField databricksTokenField;
    @FXML private TextField databricksPathField;

    @FXML private VBox resultsContainer;
    @FXML private TableView<ObservableList<String>> resultsTableView;
    @FXML private Label resultsStatusLabel;
    @FXML private ProgressBar executionProgressBar;

    private SQLQueryExtractor extractor;
    private List<SQLQueryInfo> allQueries;
    private ExecutorService executorService;

    private static final DateTimeFormatter TIME_FORMATTER = DateTimeFormatter.ofPattern("HH:mm:ss.SSS");

    public void initialize() {
        extractor = new SQLQueryExtractor();
        executorService = Executors.newSingleThreadExecutor();

        // Set up query table columns
        lineNumberColumn.setCellValueFactory(new PropertyValueFactory<>("lineNumber"));
        queryTypeColumn.setCellValueFactory(new PropertyValueFactory<>("queryType"));
        queryPreviewColumn.setCellValueFactory(cellData ->
            new SimpleStringProperty(cellData.getValue().getShortQuery()));
        durationColumn.setCellValueFactory(new PropertyValueFactory<>("durationMs"));
        statusColumn.setCellValueFactory(new PropertyValueFactory<>("status"));
        timeColumn.setCellValueFactory(new PropertyValueFactory<>("executionTime"));

        // Format time column
        timeColumn.setCellFactory(column -> new TableCell<SQLQueryInfo, LocalDateTime>() {
            @Override
            protected void updateItem(LocalDateTime item, boolean empty) {
                super.updateItem(item, empty);
                if (empty || item == null) {
                    setText(null);
                } else {
                    setText(item.format(TIME_FORMATTER));
                }
            }
        });

        // Color code status column
        statusColumn.setCellFactory(column -> new TableCell<SQLQueryInfo, String>() {
            @Override
            protected void updateItem(String item, boolean empty) {
                super.updateItem(item, empty);
                if (empty || item == null) {
                    setText(null);
                    setStyle("");
                } else {
                    setText(item);
                    switch (item) {
                        case "ERROR":
                        case "TIMEOUT":
                            setStyle("-fx-background-color: #ffcccc; -fx-text-fill: #cc0000;");
                            break;
                        case "SUCCESS":
                            setStyle("-fx-background-color: #ccffcc; -fx-text-fill: #006600;");
                            break;
                        default:
                            setStyle("-fx-background-color: #fff3cd; -fx-text-fill: #856404;");
                            break;
                    }
                }
            }
        });

        // Set up selection listener
        queryTableView.getSelectionModel().selectedItemProperty().addListener(
            (obs, oldSelection, newSelection) -> {
                if (newSelection != null) {
                    showQueryDetails(newSelection);
                }
            }
        );

        // Initially disable buttons
        copyQueryButton.setDisable(true);
        executeButton.setDisable(true);
        exportResultsButton.setDisable(true);
        executionProgressBar.setVisible(false);

        // Enable copy button when query selected
        queryTableView.getSelectionModel().selectedItemProperty().addListener(
            (obs, oldSelection, newSelection) -> {
                copyQueryButton.setDisable(newSelection == null);
                executeButton.setDisable(newSelection == null);
            }
        );
    }

    public void loadQueries(List<LogEntry> logEntries) {
        // Extract all SQL queries
        allQueries = extractor.extractQueries(logEntries);

        // Populate table
        ObservableList<SQLQueryInfo> queryList = FXCollections.observableArrayList(allQueries);
        queryTableView.setItems(queryList);

        // Show statistics
        updateStatistics();

        // Select first query if available
        if (!allQueries.isEmpty()) {
            queryTableView.getSelectionModel().select(0);
        }
    }

    private void updateStatistics() {
        Map<String, Object> stats = extractor.getStatistics(allQueries);

        String statsText = String.format(
            "Total Queries: %d | SELECT: %d | INSERT: %d | UPDATE: %d | DELETE: %d | " +
            "Total Duration: %dms | Avg Duration: %dms | Errors: %d",
            stats.get("totalQueries"),
            stats.get("selectCount"),
            stats.get("insertCount"),
            stats.get("updateCount"),
            stats.get("deleteCount"),
            stats.get("totalDuration"),
            stats.get("avgDuration"),
            stats.get("errorCount")
        );

        statsLabel.setText(statsText);
    }

    private void showQueryDetails(SQLQueryInfo query) {
        // Update selected query label
        selectedQueryLabel.setText(String.format("Query #%d - %s",
            query.getLineNumber(), query.getQueryType()));

        // Show full query
        queryDetailsArea.setText(query.getQuery());

        // Show execution details
        StringBuilder execDetails = new StringBuilder();
        execDetails.append("Execution Time: ").append(
            query.getExecutionTime() != null ?
            query.getExecutionTime().format(TIME_FORMATTER) : "N/A"
        ).append("\n");
        execDetails.append("Duration: ").append(
            query.getDurationMs() != null ? query.getDurationMs() + " ms" : "N/A"
        ).append("\n");
        execDetails.append("Status: ").append(query.getStatus()).append("\n");
        execDetails.append("Request ID: ").append(
            query.getRequestId() != null ? query.getRequestId() : "N/A"
        ).append("\n");
        execDetails.append("Thread ID: ").append(
            query.getThreadId() != null ? query.getThreadId() : "N/A"
        ).append("\n");
        execDetails.append("Table: ").append(
            query.getTable() != null ? query.getTable() : "N/A"
        ).append("\n");
        execDetails.append("Row Count: ").append(
            query.getRowCount() != null ? query.getRowCount() : "N/A"
        ).append("\n");

        executionDetailsArea.setText(execDetails.toString());

        // Show original log line
        logLineArea.setText(query.getLogLine());
    }

    @FXML
    private void onCopyQuery() {
        SQLQueryInfo selected = queryTableView.getSelectionModel().getSelectedItem();
        if (selected != null) {
            ClipboardContent content = new ClipboardContent();
            content.putString(selected.getQuery());
            Clipboard.getSystemClipboard().setContent(content);

            // Show confirmation
            Alert alert = new Alert(Alert.AlertType.INFORMATION,
                "Query copied to clipboard!", ButtonType.OK);
            alert.setHeaderText(null);
            alert.showAndWait();
        }
    }

    @FXML
    private void onExecuteQuery() {
        SQLQueryInfo selected = queryTableView.getSelectionModel().getSelectedItem();
        if (selected == null) {
            return;
        }

        String host = databricksHostField.getText().trim();
        String token = databricksTokenField.getText().trim();
        String path = databricksPathField.getText().trim();

        if (host.isEmpty() || token.isEmpty() || path.isEmpty()) {
            Alert alert = new Alert(Alert.AlertType.WARNING,
                "Please provide Databricks Host, Token, and HTTP Path to execute queries.",
                ButtonType.OK);
            alert.setHeaderText("Missing Databricks Configuration");
            alert.showAndWait();
            return;
        }

        // Execute query asynchronously
        executeButton.setDisable(true);
        executionProgressBar.setVisible(true);
        executionProgressBar.setProgress(-1); // Indeterminate

        resultsStatusLabel.setText("Executing query...");
        resultsTableView.getItems().clear();
        resultsTableView.getColumns().clear();

        executorService.submit(() -> {
            try {
                // Simulate execution (replace with actual Databricks API call)
                executeDatabricksQuery(selected.getQuery(), host, token, path);
            } catch (Exception e) {
                Platform.runLater(() -> {
                    resultsStatusLabel.setText("Error: " + e.getMessage());
                    executionProgressBar.setVisible(false);
                    executeButton.setDisable(false);

                    Alert alert = new Alert(Alert.AlertType.ERROR,
                        "Failed to execute query: " + e.getMessage(),
                        ButtonType.OK);
                    alert.setHeaderText("Execution Error");
                    alert.showAndWait();
                });
            }
        });
    }

    private void executeDatabricksQuery(String query, String host, String token, String path) {
        // This is a placeholder for actual Databricks SQL execution
        // In a real implementation, you would use Databricks JDBC driver or REST API

        Platform.runLater(() -> {
            resultsStatusLabel.setText("Connected to Databricks. Executing query...");
        });

        try {
            // Simulate network delay
            Thread.sleep(1000);

            // For demonstration, create sample results
            // In real implementation, fetch from Databricks
            createSampleResults(query);

            Platform.runLater(() -> {
                executionProgressBar.setVisible(false);
                executeButton.setDisable(false);
                exportResultsButton.setDisable(false);
                resultsStatusLabel.setText("Query executed successfully. Results ready.");
            });

        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            Platform.runLater(() -> {
                resultsStatusLabel.setText("Execution interrupted.");
                executionProgressBar.setVisible(false);
                executeButton.setDisable(false);
            });
        }
    }

    private void createSampleResults(String query) {
        // Sample results for demonstration
        // In real implementation, parse actual Databricks response

        Platform.runLater(() -> {
            // Clear existing columns
            resultsTableView.getColumns().clear();

            // Create columns based on query type
            String queryType = query.trim().toUpperCase();

            if (queryType.startsWith("SELECT")) {
                // Create sample columns
                TableColumn<ObservableList<String>, String> col1 = new TableColumn<>("Column 1");
                col1.setCellValueFactory(cellData ->
                    new SimpleStringProperty(cellData.getValue().get(0)));

                TableColumn<ObservableList<String>, String> col2 = new TableColumn<>("Column 2");
                col2.setCellValueFactory(cellData ->
                    new SimpleStringProperty(cellData.getValue().get(1)));

                TableColumn<ObservableList<String>, String> col3 = new TableColumn<>("Column 3");
                col3.setCellValueFactory(cellData ->
                    new SimpleStringProperty(cellData.getValue().get(2)));

                resultsTableView.getColumns().addAll(col1, col2, col3);

                // Add sample data
                ObservableList<ObservableList<String>> data = FXCollections.observableArrayList();
                for (int i = 1; i <= 10; i++) {
                    ObservableList<String> row = FXCollections.observableArrayList(
                        "Row " + i + " Data 1",
                        "Row " + i + " Data 2",
                        "Row " + i + " Data 3"
                    );
                    data.add(row);
                }
                resultsTableView.setItems(data);
            } else {
                // For INSERT/UPDATE/DELETE, show affected rows
                resultsStatusLabel.setText("Query executed successfully. 1 row(s) affected.");
            }
        });
    }

    @FXML
    private void onExportResults() {
        if (resultsTableView.getItems().isEmpty()) {
            Alert alert = new Alert(Alert.AlertType.WARNING,
                "No results to export.",
                ButtonType.OK);
            alert.showAndWait();
            return;
        }

        FileChooser fileChooser = new FileChooser();
        fileChooser.setTitle("Export Results");
        fileChooser.getExtensionFilters().add(
            new FileChooser.ExtensionFilter("CSV Files", "*.csv")
        );
        fileChooser.setInitialFileName("query_results.csv");

        File file = fileChooser.showSaveDialog(resultsTableView.getScene().getWindow());
        if (file != null) {
            try {
                exportToCSV(file);
                Alert alert = new Alert(Alert.AlertType.INFORMATION,
                    "Results exported successfully to " + file.getAbsolutePath(),
                    ButtonType.OK);
                alert.setHeaderText(null);
                alert.showAndWait();
            } catch (IOException e) {
                Alert alert = new Alert(Alert.AlertType.ERROR,
                    "Failed to export results: " + e.getMessage(),
                    ButtonType.OK);
                alert.showAndWait();
            }
        }
    }

    private void exportToCSV(File file) throws IOException {
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(file))) {
            // Write headers
            for (int i = 0; i < resultsTableView.getColumns().size(); i++) {
                writer.write(resultsTableView.getColumns().get(i).getText());
                if (i < resultsTableView.getColumns().size() - 1) {
                    writer.write(",");
                }
            }
            writer.newLine();

            // Write data
            for (ObservableList<String> row : resultsTableView.getItems()) {
                for (int i = 0; i < row.size(); i++) {
                    writer.write("\"" + row.get(i).replace("\"", "\"\"") + "\"");
                    if (i < row.size() - 1) {
                        writer.write(",");
                    }
                }
                writer.newLine();
            }
        }
    }

    @FXML
    private void onRefresh() {
        // Reload queries from current log data
        if (allQueries != null) {
            queryTableView.refresh();
            updateStatistics();
        }
    }

    public void shutdown() {
        if (executorService != null) {
            executorService.shutdown();
        }
    }
}
----------------------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>

<?import javafx.geometry.Insets?>
<?import javafx.scene.control.*?>
<?import javafx.scene.layout.*?>

<VBox xmlns="http://javafx.com/javafx"
      xmlns:fx="http://javafx.com/fxml"
      fx:controller="com.logviewer.AutoRefreshController"
      spacing="10" style="-fx-background-color: #f4f4f4;">
    <padding>
        <Insets top="10" right="10" bottom="10" left="10"/>
    </padding>

    <!-- Header -->
    <HBox spacing="10" style="-fx-background-color: white; -fx-padding: 10;" alignment="CENTER_LEFT">
        <Label text="Auto-Refresh Log Viewer" style="-fx-font-size: 16px; -fx-font-weight: bold;"/>
        <Region HBox.hgrow="ALWAYS"/>
        <Label fx:id="statusLabel" text="Not Started" style="-fx-text-fill: #666;"/>
    </HBox>

    <!-- Profile Management Panel -->
    <VBox spacing="10" style="-fx-background-color: white; -fx-padding: 10;">
        <Label text="Environment Profiles" style="-fx-font-weight: bold; -fx-font-size: 14px;"/>
        <Separator/>

        <HBox spacing="10" alignment="CENTER_LEFT">
            <Label text="Select Profile:" style="-fx-min-width: 150px;"/>
            <ComboBox fx:id="profileComboBox" promptText="Select an environment profile..." HBox.hgrow="ALWAYS"/>
            <Button fx:id="newProfileButton" text="New" onAction="#onNewProfile"/>
            <Button fx:id="saveProfileButton" text="Save" onAction="#onSaveProfile" style="-fx-base: #28a745;"/>
            <Button fx:id="deleteProfileButton" text="Delete" onAction="#onDeleteProfile" style="-fx-base: #dc3545;"/>
        </HBox>

        <HBox spacing="10" alignment="CENTER_LEFT">
            <Label text="Profile Name:" style="-fx-min-width: 150px;"/>
            <TextField fx:id="profileNameField" promptText="e.g., DEV, STAGING, PROD" HBox.hgrow="ALWAYS"/>
        </HBox>
    </VBox>

    <!-- Configuration Panel -->
    <VBox spacing="10" style="-fx-background-color: white; -fx-padding: 10;">
        <Label text="Configuration" style="-fx-font-weight: bold; -fx-font-size: 14px;"/>
        <Separator/>

        <!-- AWS Login Section -->
        <VBox spacing="5">
            <Label text="AWS Authentication" style="-fx-font-weight: bold;"/>

            <HBox spacing="10" alignment="CENTER_LEFT">
                <Label text="AWS Login Command:" style="-fx-min-width: 150px;"/>
                <TextField fx:id="awsLoginCommandField"
                          promptText="e.g., pcl aws login"
                          HBox.hgrow="ALWAYS"/>
                <Button fx:id="loginToAwsButton" text="Login to AWS" onAction="#onLoginToAws" style="-fx-base: #007bff;"/>
            </HBox>

            <HBox spacing="10" alignment="CENTER_LEFT">
                <Label text="Session Refresh:" style="-fx-min-width: 150px;"/>
                <CheckBox fx:id="autoRefreshSessionCheck" text="Auto re-login every"/>
                <Spinner fx:id="sessionRefreshSpinner" prefWidth="80" editable="true"/>
                <Label text="minutes (to keep session alive)"/>
            </HBox>
        </VBox>

        <Separator/>

        <!-- Kubernetes Configuration -->
        <VBox spacing="5">
            <Label text="Kubernetes Configuration" style="-fx-font-weight: bold;"/>

            <HBox spacing="10" alignment="CENTER_LEFT">
                <Label text="Kubectl Context:" style="-fx-min-width: 150px;"/>
                <TextField fx:id="kubectlContextField"
                          promptText="e.g., arn:aws:eks:us-east-1:123456:cluster/my-cluster"
                          HBox.hgrow="ALWAYS"/>
                <Button text="Get Contexts" onAction="#onGetContexts"/>
            </HBox>

            <HBox spacing="10" alignment="CENTER_LEFT">
                <Label text="Namespace:" style="-fx-min-width: 150px;"/>
                <TextField fx:id="namespaceField"
                          text="default"
                          promptText="e.g., default, production, staging"/>
                <Button text="Get Namespaces" onAction="#onGetNamespaces"/>
            </HBox>

            <HBox spacing="10" alignment="CENTER_LEFT">
                <Label text="Pod Name:" style="-fx-min-width: 150px;"/>
                <TextField fx:id="podNameField"
                          promptText="e.g., my-app-7d8f9c-xyz12"
                          HBox.hgrow="ALWAYS"/>
                <Button text="List Pods" onAction="#onListPods"/>
            </HBox>

            <HBox spacing="10" alignment="CENTER_LEFT">
                <Label text="Container Name:" style="-fx-min-width: 150px;"/>
                <TextField fx:id="containerNameField"
                          promptText="Optional: Leave empty for single-container pods"/>
            </HBox>
        </VBox>

        <Separator/>

        <!-- Log Configuration -->
        <VBox spacing="5">
            <Label text="Log Configuration" style="-fx-font-weight: bold;"/>

            <HBox spacing="10" alignment="CENTER_LEFT">
                <Label text="Log Source:" style="-fx-min-width: 150px;"/>
                <RadioButton fx:id="stdoutLogRadio" text="Container Logs (stdout/stderr)" selected="true">
                    <toggleGroup>
                        <ToggleGroup fx:id="logSourceGroup"/>
                    </toggleGroup>
                </RadioButton>
                <RadioButton fx:id="fileLogRadio" text="Log File Path" toggleGroup="$logSourceGroup"/>
            </HBox>

            <HBox spacing="10" alignment="CENTER_LEFT">
                <Label text="Log File Path:" style="-fx-min-width: 150px;"/>
                <TextField fx:id="logPathField"
                          promptText="/var/log/app/application.log (only if 'Log File Path' selected)"
                          disable="true"
                          HBox.hgrow="ALWAYS"/>
            </HBox>

            <HBox spacing="10" alignment="CENTER_LEFT">
                <Label text="Tail Lines:" style="-fx-min-width: 150px;"/>
                <Spinner fx:id="tailLinesSpinner"
                        editable="true"
                        prefWidth="120"
                        initialValue="1000"
                        min="100"
                        max="50000"
                        amountToStepBy="100"/>
                <Label text="(number of recent lines to download)"/>
            </HBox>

            <HBox spacing="10" alignment="CENTER_LEFT">
                <Label text="Refresh Interval:" style="-fx-min-width: 150px;"/>
                <Spinner fx:id="refreshIntervalSpinner"
                        editable="true"
                        prefWidth="120"
                        initialValue="30"
                        min="5"
                        max="600"
                        amountToStepBy="5"/>
                <Label text="seconds"/>
            </HBox>
        </VBox>

        <Separator/>

        <!-- Auto-Load to Main Window -->
        <VBox spacing="5">
            <Label text="Auto-Load to Main Window" style="-fx-font-weight: bold;"/>

            <HBox spacing="10" alignment="CENTER_LEFT">
                <CheckBox fx:id="autoLoadToMainWindowCheck" text="Automatically load downloaded logs into main window"/>
            </HBox>

            <HBox spacing="10" alignment="CENTER_LEFT">
                <Label text="Load into:" style="-fx-min-width: 150px;"/>
                <RadioButton fx:id="loadToPane1Radio" text="Pane 1 (Left)" selected="true"/>
                <RadioButton fx:id="loadToPane2Radio" text="Pane 2 (Right)"/>
            </HBox>
        </VBox>

        <Separator/>

        <!-- Control Buttons -->
        <HBox spacing="10" alignment="CENTER">
            <Button fx:id="startButton" text="Start Auto-Refresh" onAction="#onStart"
                    style="-fx-background-color: #28a745; -fx-text-fill: white; -fx-font-weight: bold;"
                    prefWidth="150"/>
            <Button fx:id="stopButton" text="Stop" onAction="#onStop"
                    disable="true"
                    style="-fx-background-color: #dc3545; -fx-text-fill: white;"
                    prefWidth="100"/>
            <Button text="Download Once" onAction="#onDownloadOnce"
                    prefWidth="150"/>
            <Button text="Save Config" onAction="#onSaveConfig"/>
            <Button text="Load Config" onAction="#onLoadConfig"/>
        </HBox>

        <!-- Progress and Status -->
        <VBox spacing="5">
            <Label fx:id="progressLabel" text="Status: Ready" style="-fx-font-size: 12px;"/>
            <ProgressBar fx:id="progressBar" prefWidth="Infinity" visible="false"/>
            <Label fx:id="lastUpdateLabel" text="Last Update: Never" style="-fx-font-size: 11px; -fx-text-fill: #666;"/>
        </VBox>
    </VBox>

    <!-- Log Display Area -->
    <VBox spacing="5" style="-fx-background-color: white; -fx-padding: 10;" VBox.vgrow="ALWAYS">
        <HBox spacing="10" alignment="CENTER_LEFT">
            <Label text="Downloaded Logs" style="-fx-font-weight: bold; -fx-font-size: 14px;"/>
            <Region HBox.hgrow="ALWAYS"/>
            <TextField fx:id="searchField" promptText="Search in logs..." prefWidth="200"/>
            <Button text="Search" onAction="#onSearch"/>
            <Button text="Clear" onAction="#onClearSearch"/>
            <Button text="Export" onAction="#onExport"/>
        </HBox>

        <HBox spacing="10" alignment="CENTER_LEFT">
            <CheckBox fx:id="errorCheckBox" text="ERROR" selected="true"/>
            <CheckBox fx:id="warnCheckBox" text="WARN" selected="true"/>
            <CheckBox fx:id="infoCheckBox" text="INFO" selected="true"/>
            <CheckBox fx:id="debugCheckBox" text="DEBUG" selected="true"/>
            <CheckBox fx:id="traceCheckBox" text="TRACE" selected="true"/>
            <Button text="Apply Filter" onAction="#onApplyFilter"/>
        </HBox>

        <Separator/>

        <HBox spacing="10" alignment="CENTER_LEFT">
            <Label fx:id="resultCountLabel" text="Lines: 0" style="-fx-font-size: 11px;"/>
            <Region HBox.hgrow="ALWAYS"/>
            <Label fx:id="currentFileLabel" text="File: None" style="-fx-font-size: 11px;"/>
        </HBox>

        <ListView fx:id="logListView" VBox.vgrow="ALWAYS"
                 style="-fx-font-family: 'Consolas', 'Monaco', monospace; -fx-font-size: 11px;"/>
    </VBox>
</VBox>
--------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>

<?import javafx.geometry.Insets?>
<?import javafx.scene.control.*?>
<?import javafx.scene.layout.*?>

<VBox xmlns="http://javafx.com/javafx"
      xmlns:fx="http://javafx.com/fxml"
      fx:controller="com.logviewer.ContextViewerController"
      spacing="10" style="-fx-background-color: #f4f4f4;">
    <padding>
        <Insets top="10" right="10" bottom="10" left="10"/>
    </padding>

    <!-- Header -->
    <HBox spacing="10" alignment="CENTER_LEFT" style="-fx-background-color: white; -fx-padding: 10;">
        <Label text="Smart Context Viewer" style="-fx-font-size: 16px; -fx-font-weight: bold;"/>
        <Region HBox.hgrow="ALWAYS"/>
        <Button text="Close" onAction="#onClose"/>
    </HBox>

    <!-- Selected Log Display -->
    <VBox spacing="5" style="-fx-background-color: white; -fx-padding: 10;">
        <Label fx:id="selectedLogLabel" text="Selected Log Line" style="-fx-font-weight: bold;"/>
        <TextArea fx:id="selectedLogArea"
                 editable="false"
                 wrapText="true"
                 prefHeight="60"
                 style="-fx-font-family: 'Consolas'; -fx-font-size: 11px; -fx-background-color: #fffacd;"/>
    </VBox>

    <!-- Extracted Identifiers -->
    <GridPane hgap="10" vgap="5" style="-fx-background-color: white; -fx-padding: 10;">
        <columnConstraints>
            <ColumnConstraints hgrow="NEVER" minWidth="100"/>
            <ColumnConstraints hgrow="ALWAYS"/>
            <ColumnConstraints hgrow="NEVER" minWidth="100"/>
            <ColumnConstraints hgrow="ALWAYS"/>
        </columnConstraints>

        <Label text="Request ID:" style="-fx-font-weight: bold;" GridPane.columnIndex="0" GridPane.rowIndex="0"/>
        <Label fx:id="requestIdLabel" text="N/A" GridPane.columnIndex="1" GridPane.rowIndex="0"/>

        <Label text="Thread ID:" style="-fx-font-weight: bold;" GridPane.columnIndex="2" GridPane.rowIndex="0"/>
        <Label fx:id="threadIdLabel" text="N/A" GridPane.columnIndex="3" GridPane.rowIndex="0"/>

        <Label text="User ID:" style="-fx-font-weight: bold;" GridPane.columnIndex="0" GridPane.rowIndex="1"/>
        <Label fx:id="userIdLabel" text="N/A" GridPane.columnIndex="1" GridPane.rowIndex="1"/>

        <Label text="Endpoint:" style="-fx-font-weight: bold;" GridPane.columnIndex="2" GridPane.rowIndex="1"/>
        <Label fx:id="endpointLabel" text="N/A" GridPane.columnIndex="3" GridPane.rowIndex="1"/>
    </GridPane>

    <!-- Stats -->
    <Label fx:id="statsLabel" text="Loading stats..." style="-fx-font-size: 11px; -fx-text-fill: #666;"/>

    <!-- Main Content with Tabs -->
    <SplitPane dividerPositions="0.7" VBox.vgrow="ALWAYS">
        <!-- Left: Context Tabs -->
        <TabPane fx:id="contextTabPane" style="-fx-background-color: white;">
            <Tab text="By Request ID" closable="false">
                <ListView fx:id="requestIdListView"
                         style="-fx-font-family: 'Consolas'; -fx-font-size: 10px;"/>
            </Tab>

            <Tab text="By Thread" closable="false">
                <ListView fx:id="threadListView"
                         style="-fx-font-family: 'Consolas'; -fx-font-size: 10px;"/>
            </Tab>

            <Tab text="Time Window" closable="false">
                <ListView fx:id="timeWindowListView"
                         style="-fx-font-family: 'Consolas'; -fx-font-size: 10px;"/>
            </Tab>

            <Tab text="Related Errors" closable="false">
                <ListView fx:id="errorsListView"
                         style="-fx-font-family: 'Consolas'; -fx-font-size: 10px;"/>
            </Tab>

            <Tab text="Impact Analysis" closable="false">
                <ListView fx:id="impactListView"
                         style="-fx-font-family: 'Consolas'; -fx-font-size: 10px;"/>
            </Tab>
        </TabPane>

        <!-- Right: Key Data and Timeline -->
        <VBox spacing="10" style="-fx-background-color: white; -fx-padding: 10;">
            <!-- Key Data -->
            <VBox spacing="5" VBox.vgrow="NEVER">
                <Label text="Key Data Extracted" style="-fx-font-weight: bold;"/>
                <TextArea fx:id="keyDataArea"
                         editable="false"
                         wrapText="true"
                         prefHeight="100"
                         style="-fx-font-family: 'Consolas'; -fx-font-size: 10px;"/>
            </VBox>

            <Separator/>

            <!-- Timeline -->
            <ScrollPane VBox.vgrow="ALWAYS" fitToWidth="true">
                <VBox fx:id="timelineBox" spacing="2" style="-fx-padding: 5;"/>
            </ScrollPane>
        </VBox>
    </SplitPane>

    <!-- Help Text -->
    <HBox spacing="10" style="-fx-background-color: #e9ecef; -fx-padding: 5;">
        <Label text="ð¡ Right-click any log line to view its full context. All related logs, errors, and impact are shown automatically."
               style="-fx-font-size: 11px;"/>
    </HBox>
</VBox>
---------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>

<?import javafx.geometry.Insets?>
<?import javafx.scene.control.*?>
<?import javafx.scene.layout.*?>

<VBox xmlns="http://javafx.com/javafx"
      xmlns:fx="http://javafx.com/fxml"
      fx:controller="com.logviewer.CorrelationController"
      spacing="10" style="-fx-background-color: #f4f4f4;">
    <padding>
        <Insets top="10" right="10" bottom="10" left="10"/>
    </padding>

    <!-- Header -->
    <HBox spacing="10" alignment="CENTER_LEFT" style="-fx-background-color: white; -fx-padding: 10;">
        <Label text="Correlation Analysis" style="-fx-font-size: 16px; -fx-font-weight: bold;"/>
        <Region HBox.hgrow="ALWAYS"/>
        <Button fx:id="analyzeButton" text="Analyze Correlations" onAction="#onAnalyze"/>
        <Button fx:id="clearButton" text="Clear" onAction="#onClear"/>
    </HBox>

    <!-- Search by ID -->
    <HBox spacing="10" alignment="CENTER_LEFT" style="-fx-background-color: white; -fx-padding: 10;">
        <Label text="Quick Search ID:"/>
        <TextField fx:id="searchIdField" promptText="Enter ID to search..." HBox.hgrow="ALWAYS"/>
        <Button text="Find" onAction="#onSearchId"/>
    </HBox>

    <!-- Statistics -->
    <HBox spacing="20" style="-fx-background-color: white; -fx-padding: 10;">
        <VBox spacing="5">
            <Label text="Total Correlations:" style="-fx-font-size: 11px;"/>
            <Label fx:id="totalCorrelationsLabel" text="0" style="-fx-font-size: 20px; -fx-font-weight: bold; -fx-text-fill: #007bff;"/>
        </VBox>
        <Separator orientation="VERTICAL"/>
        <VBox spacing="5">
            <Label text="Request IDs:" style="-fx-font-size: 11px;"/>
            <Label fx:id="requestIdCountLabel" text="0" style="-fx-font-size: 16px; -fx-font-weight: bold;"/>
        </VBox>
        <VBox spacing="5">
            <Label text="Transaction IDs:" style="-fx-font-size: 11px;"/>
            <Label fx:id="transactionIdCountLabel" text="0" style="-fx-font-size: 16px; -fx-font-weight: bold;"/>
        </VBox>
        <VBox spacing="5">
            <Label text="Session IDs:" style="-fx-font-size: 11px;"/>
            <Label fx:id="sessionIdCountLabel" text="0" style="-fx-font-size: 16px; -fx-font-weight: bold;"/>
        </VBox>
        <VBox spacing="5">
            <Label text="User IDs:" style="-fx-font-size: 11px;"/>
            <Label fx:id="userIdCountLabel" text="0" style="-fx-font-size: 16px; -fx-font-weight: bold;"/>
        </VBox>
    </HBox>

    <!-- Correlation List -->
    <VBox VBox.vgrow="ALWAYS" style="-fx-background-color: white; -fx-padding: 10;">
        <Label text="Correlated Entries (showing entries found in BOTH panes):" style="-fx-font-weight: bold; -fx-padding: 0 0 5 0;"/>

        <ListView fx:id="correlationListView" VBox.vgrow="ALWAYS"
                 style="-fx-font-family: 'Consolas', 'Monaco', monospace; -fx-font-size: 12px;"/>
    </VBox>

    <!-- Details Panel -->
    <SplitPane fx:id="detailsPane" orientation="HORIZONTAL" VBox.vgrow="ALWAYS">
        <!-- Left: Pane 1 Entries -->
        <VBox style="-fx-background-color: white; -fx-padding: 10;">
            <HBox spacing="10" alignment="CENTER_LEFT">
                <Label text="Pane 1 Entries" style="-fx-font-weight: bold; -fx-font-size: 14px;"/>
                <Region HBox.hgrow="ALWAYS"/>
                <Label fx:id="pane1CountLabel" text="0 entries" style="-fx-font-size: 11px;"/>
            </HBox>
            <Separator/>
            <ListView fx:id="pane1EntriesView" VBox.vgrow="ALWAYS"
                     style="-fx-font-family: 'Consolas', 'Monaco', monospace; -fx-font-size: 11px;"/>
        </VBox>

        <!-- Right: Pane 2 Entries -->
        <VBox style="-fx-background-color: white; -fx-padding: 10;">
            <HBox spacing="10" alignment="CENTER_LEFT">
                <Label text="Pane 2 Entries" style="-fx-font-weight: bold; -fx-font-size: 14px;"/>
                <Region HBox.hgrow="ALWAYS"/>
                <Label fx:id="pane2CountLabel" text="0 entries" style="-fx-font-size: 11px;"/>
            </HBox>
            <Separator/>
            <ListView fx:id="pane2EntriesView" VBox.vgrow="ALWAYS"
                     style="-fx-font-family: 'Consolas', 'Monaco', monospace; -fx-font-size: 11px;"/>
        </VBox>
    </SplitPane>

    <!-- Status Bar -->
    <HBox spacing="10" style="-fx-background-color: #e9ecef; -fx-padding: 5;">
        <Label fx:id="statusLabel" text="Ready"/>
        <Region HBox.hgrow="ALWAYS"/>
        <ProgressBar fx:id="progressBar" prefWidth="200" visible="false"/>
    </HBox>
</VBox>
-----------------------------------------
<?xml version="1.0" encoding="UTF-8"?>

<?import javafx.geometry.Insets?>
<?import javafx.scene.control.*?>
<?import javafx.scene.layout.*?>

<VBox xmlns="http://javafx.com/javafx"
      xmlns:fx="http://javafx.com/fxml"
      fx:controller="com.logviewer.MainController"
      spacing="10" style="-fx-background-color: #f4f4f4;">
    <padding>
        <Insets top="10" right="10" bottom="10" left="10"/>
    </padding>

    <!-- Toolbar -->
    <HBox spacing="10" style="-fx-background-color: white; -fx-padding: 10;" alignment="CENTER_LEFT">
        <Label text="Log Viewer" style="-fx-font-size: 16px; -fx-font-weight: bold;"/>
        <Separator orientation="VERTICAL"/>
        <Label text="Trace ID:"/>
        <TextField fx:id="traceIdField" promptText="Enter Request/Trace ID..." prefWidth="200"/>
        <Button fx:id="highlightTraceButton" text="Highlight" onAction="#onHighlightTrace" style="-fx-background-color: #17a2b8; -fx-text-fill: white;"/>
        <Button fx:id="clearTraceButton" text="Clear" onAction="#onClearTrace"/>
        <Separator orientation="VERTICAL"/>
        <CheckBox fx:id="syncScrollCheckbox" text="Sync Scroll by Time"/>
        <Region HBox.hgrow="ALWAYS"/>
        <Label text="Theme:"/>
        <ComboBox fx:id="themeSelector" prefWidth="120"/>
        <Button text="Sequence Diagram" onAction="#onOpenSequenceDiagram"
                style="-fx-background-color: #6f42c1; -fx-text-fill: white;"/>
        <Button text="Auto-Refresh Logs" onAction="#onOpenAutoRefresh"
                style="-fx-background-color: #007bff; -fx-text-fill: white;"/>
        <Button fx:id="correlationButton" text="Correlation Analysis" onAction="#onOpenCorrelation"
                style="-fx-background-color: #28a745; -fx-text-fill: white;"/>
        <Button text="SQL Query Analyzer" onAction="#onOpenSQLAnalyzer"
                style="-fx-background-color: #e74c3c; -fx-text-fill: white;"/>
        <Button text="Multi-Env Monitor" onAction="#onOpenMultiEnvMonitor"
                style="-fx-background-color: #fd7e14; -fx-text-fill: white; -fx-font-weight: bold;"/>
        <Button text="Help" onAction="#onHelp"/>
    </HBox>

    <!-- Main Content: Dual Pane -->
    <SplitPane fx:id="splitPane" dividerPositions="0.5" VBox.vgrow="ALWAYS">

        <!-- Left Log Pane -->
        <VBox spacing="5" style="-fx-background-color: white; -fx-padding: 5;">

            <!-- Left Panel Header -->
            <HBox spacing="10" alignment="CENTER_LEFT">
                <Label text="Log Pane 1" style="-fx-font-weight: bold; -fx-font-size: 14px;"/>
                <Button fx:id="loadButton1" text="Load Log File" onAction="#onLoadLog1"/>
                <Label fx:id="fileName1" text="No file loaded" style="-fx-text-fill: #666;"/>
                <Region HBox.hgrow="ALWAYS"/>
                <Label fx:id="status1" text="Ready" style="-fx-text-fill: #28a745;"/>
            </HBox>

            <Separator/>

            <!-- Search and Filter Controls for Left Pane -->
            <VBox spacing="5">
                <HBox spacing="10" alignment="CENTER_LEFT">
                    <Label text="Search:" style="-fx-min-width: 60px;"/>
                    <TextField fx:id="searchField1" promptText="Enter search text..." HBox.hgrow="ALWAYS"/>
                    <Button fx:id="searchButton1" text="Search" onAction="#onSearch1"/>
                    <Button fx:id="clearSearch1" text="Clear" onAction="#onClearSearch1"/>
                </HBox>

                <HBox spacing="10" alignment="CENTER_LEFT">
                    <Label text="Level:" style="-fx-min-width: 60px;"/>
                    <CheckBox fx:id="errorCheck1" text="ERROR" selected="true"/>
                    <CheckBox fx:id="warnCheck1" text="WARN" selected="true"/>
                    <CheckBox fx:id="infoCheck1" text="INFO" selected="true"/>
                    <CheckBox fx:id="debugCheck1" text="DEBUG" selected="true"/>
                    <CheckBox fx:id="traceCheck1" text="TRACE" selected="true"/>
                </HBox>

                <HBox spacing="10" alignment="CENTER_LEFT">
                    <Label text="Date From:" style="-fx-min-width: 60px;"/>
                    <DatePicker fx:id="dateFrom1" promptText="Start date"/>
                    <Label text="To:"/>
                    <DatePicker fx:id="dateTo1" promptText="End date"/>
                    <Button text="Apply Filters" onAction="#onApplyFilter1"/>
                    <Button text="Reset" onAction="#onResetFilter1"/>
                </HBox>

                <HBox spacing="10" alignment="CENTER_LEFT">
                    <Label text="Service:" style="-fx-min-width: 60px;"/>
                    <TextField fx:id="serviceFilter1" promptText="Service name filter..." HBox.hgrow="ALWAYS"/>
                </HBox>
            </VBox>

            <Separator/>

            <!-- Log Display Area for Left Pane -->
            <VBox VBox.vgrow="ALWAYS">
                <HBox spacing="10" alignment="CENTER_LEFT">
                    <Label fx:id="resultCount1" text="Lines: 0" style="-fx-font-size: 11px;"/>
                    <Label fx:id="errorCount1" text="" style="-fx-font-size: 11px; -fx-text-fill: #dc3545;"/>
                    <Region HBox.hgrow="ALWAYS"/>
                    <Button fx:id="prevError1" text="â Prev Error" onAction="#onPrevError1" style="-fx-font-size: 10px;"/>
                    <Button fx:id="nextError1" text="Next Error â" onAction="#onNextError1" style="-fx-font-size: 10px;"/>
                    <Label fx:id="fileSize1" text="Size: 0 MB" style="-fx-font-size: 11px;"/>
                </HBox>
                <ListView fx:id="logListView1" VBox.vgrow="ALWAYS"
                         style="-fx-font-family: 'Consolas', 'Monaco', monospace; -fx-font-size: 11px;"/>
            </VBox>
        </VBox>

        <!-- Right Log Pane -->
        <VBox spacing="5" style="-fx-background-color: white; -fx-padding: 5;">

            <!-- Right Panel Header -->
            <HBox spacing="10" alignment="CENTER_LEFT">
                <Label text="Log Pane 2" style="-fx-font-weight: bold; -fx-font-size: 14px;"/>
                <Button fx:id="loadButton2" text="Load Log File" onAction="#onLoadLog2"/>
                <Label fx:id="fileName2" text="No file loaded" style="-fx-text-fill: #666;"/>
                <Region HBox.hgrow="ALWAYS"/>
                <Label fx:id="status2" text="Ready" style="-fx-text-fill: #28a745;"/>
            </HBox>

            <Separator/>

            <!-- Search and Filter Controls for Right Pane -->
            <VBox spacing="5">
                <HBox spacing="10" alignment="CENTER_LEFT">
                    <Label text="Search:" style="-fx-min-width: 60px;"/>
                    <TextField fx:id="searchField2" promptText="Enter search text..." HBox.hgrow="ALWAYS"/>
                    <Button fx:id="searchButton2" text="Search" onAction="#onSearch2"/>
                    <Button fx:id="clearSearch2" text="Clear" onAction="#onClearSearch2"/>
                </HBox>

                <HBox spacing="10" alignment="CENTER_LEFT">
                    <Label text="Level:" style="-fx-min-width: 60px;"/>
                    <CheckBox fx:id="errorCheck2" text="ERROR" selected="true"/>
                    <CheckBox fx:id="warnCheck2" text="WARN" selected="true"/>
                    <CheckBox fx:id="infoCheck2" text="INFO" selected="true"/>
                    <CheckBox fx:id="debugCheck2" text="DEBUG" selected="true"/>
                    <CheckBox fx:id="traceCheck2" text="TRACE" selected="true"/>
                </HBox>

                <HBox spacing="10" alignment="CENTER_LEFT">
                    <Label text="Date From:" style="-fx-min-width: 60px;"/>
                    <DatePicker fx:id="dateFrom2" promptText="Start date"/>
                    <Label text="To:"/>
                    <DatePicker fx:id="dateTo2" promptText="End date"/>
                    <Button text="Apply Filters" onAction="#onApplyFilter2"/>
                    <Button text="Reset" onAction="#onResetFilter2"/>
                </HBox>

                <HBox spacing="10" alignment="CENTER_LEFT">
                    <Label text="Service:" style="-fx-min-width: 60px;"/>
                    <TextField fx:id="serviceFilter2" promptText="Service name filter..." HBox.hgrow="ALWAYS"/>
                </HBox>
            </VBox>

            <Separator/>

            <!-- Log Display Area for Right Pane -->
            <VBox VBox.vgrow="ALWAYS">
                <HBox spacing="10" alignment="CENTER_LEFT">
                    <Label fx:id="resultCount2" text="Lines: 0" style="-fx-font-size: 11px;"/>
                    <Label fx:id="errorCount2" text="" style="-fx-font-size: 11px; -fx-text-fill: #dc3545;"/>
                    <Region HBox.hgrow="ALWAYS"/>
                    <Button fx:id="prevError2" text="â Prev Error" onAction="#onPrevError2" style="-fx-font-size: 10px;"/>
                    <Button fx:id="nextError2" text="Next Error â" onAction="#onNextError2" style="-fx-font-size: 10px;"/>
                    <Label fx:id="fileSize2" text="Size: 0 MB" style="-fx-font-size: 11px;"/>
                </HBox>
                <ListView fx:id="logListView2" VBox.vgrow="ALWAYS"
                         style="-fx-font-family: 'Consolas', 'Monaco', monospace; -fx-font-size: 11px;"/>
            </VBox>
        </VBox>
    </SplitPane>

    <!-- Status Bar -->
    <HBox spacing="10" style="-fx-background-color: #e9ecef; -fx-padding: 5;">
        <Label fx:id="globalStatus" text="Ready to load log files"/>
        <Region HBox.hgrow="ALWAYS"/>
        <ProgressBar fx:id="progressBar" prefWidth="200" visible="false"/>
    </HBox>
</VBox>
----------------------------------------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>

<?import javafx.geometry.Insets?>
<?import javafx.scene.control.*?>
<?import javafx.scene.layout.*?>
<?import javafx.scene.text.Font?>

<BorderPane xmlns="http://javafx.com/javafx"
            xmlns:fx="http://javafx.com/fxml"
            fx:controller="com.logviewer.MultiEnvMonitorController"
            prefWidth="1800" prefHeight="1000">

    <!-- Top: Global Controls -->
    <top>
        <VBox style="-fx-background-color: #2c3e50; -fx-padding: 15;">
            <Label text="Multi-Environment Monitor" textFill="white">
                <font>
                    <Font name="System Bold" size="20"/>
                </font>
            </Label>
            <Label text="Monitor 4 environments in parallel with real-time updates" textFill="#ecf0f1">
                <font>
                    <Font size="12"/>
                </font>
                <VBox.margin>
                    <Insets top="5"/>
                </VBox.margin>
            </Label>

            <!-- Global Search -->
            <HBox spacing="10" alignment="CENTER_LEFT" style="-fx-padding: 10 0 0 0;">
                <Label text="Search Trace ID Across All Environments:" textFill="white" style="-fx-font-weight: bold;"/>
                <TextField fx:id="globalTraceId" promptText="Enter Trace/Request ID..." prefWidth="300"/>
                <Button fx:id="globalSearchButton" text="Search All" onAction="#onGlobalSearch"
                        style="-fx-background-color: #e74c3c; -fx-text-fill: white; -fx-font-weight: bold;"/>
                <CheckBox fx:id="syncScrollCheckbox" text="Sync Scroll" textFill="white"/>
            </HBox>
        </VBox>
    </top>

    <!-- Center: Tabs for Each Environment -->
    <center>
        <TabPane fx:id="environmentTabs" tabClosingPolicy="UNAVAILABLE">

            <!-- Tab 1: Development -->
            <Tab fx:id="tab1" text="Development" style="-fx-background-color: #17a2b8;">
                <VBox spacing="10" style="-fx-padding: 10;">
                    <!-- Header -->
                    <HBox spacing="15" alignment="CENTER_LEFT" style="-fx-background-color: white; -fx-padding: 10;">
                        <Label fx:id="env1Name" text="Development" style="-fx-font-weight: bold; -fx-font-size: 16;"/>
                        <Separator orientation="VERTICAL"/>
                        <Label fx:id="env1Status" text="Not Connected" style="-fx-text-fill: #6c757d;"/>
                        <Separator orientation="VERTICAL"/>
                        <Label fx:id="env1Stats" text="Lines: 0 | Errors: 0 | Warnings: 0" style="-fx-font-size: 11;"/>
                    </HBox>

                    <!-- Controls -->
                    <HBox spacing="10" alignment="CENTER_LEFT" style="-fx-background-color: #f8f9fa; -fx-padding: 10;">
                        <Button fx:id="env1LoadButton" text="Load Log File" onAction="#onLoadEnv1"
                                style="-fx-background-color: #17a2b8; -fx-text-fill: white;"/>
                        <Separator orientation="VERTICAL"/>
                        <CheckBox fx:id="env1AutoRefresh" text="Auto-Refresh"/>
                        <Label text="Interval (sec):"/>
                        <TextField fx:id="env1RefreshInterval" prefWidth="60" promptText="5"/>
                        <Separator orientation="VERTICAL"/>
                        <Label text="Search:"/>
                        <TextField fx:id="env1SearchField" promptText="Filter logs..." prefWidth="200"/>
                        <Button fx:id="env1PrevError" text="â Prev Error" onAction="#onEnv1PrevError" style="-fx-font-size: 10;"/>
                        <Button fx:id="env1NextError" text="Next Error â" onAction="#onEnv1NextError" style="-fx-font-size: 10;"/>
                    </HBox>

                    <!-- Log Viewer -->
                    <ListView fx:id="env1ListView" VBox.vgrow="ALWAYS"
                              style="-fx-font-family: 'Consolas', 'Monaco', monospace; -fx-font-size: 10px;"/>
                </VBox>
            </Tab>

            <!-- Tab 2: Staging -->
            <Tab fx:id="tab2" text="Staging" style="-fx-background-color: #ffc107;">
                <VBox spacing="10" style="-fx-padding: 10;">
                    <HBox spacing="15" alignment="CENTER_LEFT" style="-fx-background-color: white; -fx-padding: 10;">
                        <Label fx:id="env2Name" text="Staging" style="-fx-font-weight: bold; -fx-font-size: 16;"/>
                        <Separator orientation="VERTICAL"/>
                        <Label fx:id="env2Status" text="Not Connected" style="-fx-text-fill: #6c757d;"/>
                        <Separator orientation="VERTICAL"/>
                        <Label fx:id="env2Stats" text="Lines: 0 | Errors: 0 | Warnings: 0" style="-fx-font-size: 11;"/>
                    </HBox>

                    <HBox spacing="10" alignment="CENTER_LEFT" style="-fx-background-color: #f8f9fa; -fx-padding: 10;">
                        <Button fx:id="env2LoadButton" text="Load Log File" onAction="#onLoadEnv2"
                                style="-fx-background-color: #ffc107; -fx-text-fill: black;"/>
                        <Separator orientation="VERTICAL"/>
                        <CheckBox fx:id="env2AutoRefresh" text="Auto-Refresh"/>
                        <Label text="Interval (sec):"/>
                        <TextField fx:id="env2RefreshInterval" prefWidth="60" promptText="5"/>
                        <Separator orientation="VERTICAL"/>
                        <Label text="Search:"/>
                        <TextField fx:id="env2SearchField" promptText="Filter logs..." prefWidth="200"/>
                        <Button fx:id="env2PrevError" text="â Prev Error" onAction="#onEnv2PrevError" style="-fx-font-size: 10;"/>
                        <Button fx:id="env2NextError" text="Next Error â" onAction="#onEnv2NextError" style="-fx-font-size: 10;"/>
                    </HBox>

                    <ListView fx:id="env2ListView" VBox.vgrow="ALWAYS"
                              style="-fx-font-family: 'Consolas', 'Monaco', monospace; -fx-font-size: 10px;"/>
                </VBox>
            </Tab>

            <!-- Tab 3: Production -->
            <Tab fx:id="tab3" text="Production" style="-fx-background-color: #dc3545;">
                <VBox spacing="10" style="-fx-padding: 10;">
                    <HBox spacing="15" alignment="CENTER_LEFT" style="-fx-background-color: white; -fx-padding: 10;">
                        <Label fx:id="env3Name" text="Production" style="-fx-font-weight: bold; -fx-font-size: 16;"/>
                        <Separator orientation="VERTICAL"/>
                        <Label fx:id="env3Status" text="Not Connected" style="-fx-text-fill: #6c757d;"/>
                        <Separator orientation="VERTICAL"/>
                        <Label fx:id="env3Stats" text="Lines: 0 | Errors: 0 | Warnings: 0" style="-fx-font-size: 11;"/>
                    </HBox>

                    <HBox spacing="10" alignment="CENTER_LEFT" style="-fx-background-color: #f8f9fa; -fx-padding: 10;">
                        <Button fx:id="env3LoadButton" text="Load Log File" onAction="#onLoadEnv3"
                                style="-fx-background-color: #dc3545; -fx-text-fill: white;"/>
                        <Separator orientation="VERTICAL"/>
                        <CheckBox fx:id="env3AutoRefresh" text="Auto-Refresh"/>
                        <Label text="Interval (sec):"/>
                        <TextField fx:id="env3RefreshInterval" prefWidth="60" promptText="5"/>
                        <Separator orientation="VERTICAL"/>
                        <Label text="Search:"/>
                        <TextField fx:id="env3SearchField" promptText="Filter logs..." prefWidth="200"/>
                        <Button fx:id="env3PrevError" text="â Prev Error" onAction="#onEnv3PrevError" style="-fx-font-size: 10;"/>
                        <Button fx:id="env3NextError" text="Next Error â" onAction="#onEnv3NextError" style="-fx-font-size: 10;"/>
                    </HBox>

                    <ListView fx:id="env3ListView" VBox.vgrow="ALWAYS"
                              style="-fx-font-family: 'Consolas', 'Monaco', monospace; -fx-font-size: 10px;"/>
                </VBox>
            </Tab>

            <!-- Tab 4: DR/Backup -->
            <Tab fx:id="tab4" text="DR/Backup" style="-fx-background-color: #6c757d;">
                <VBox spacing="10" style="-fx-padding: 10;">
                    <HBox spacing="15" alignment="CENTER_LEFT" style="-fx-background-color: white; -fx-padding: 10;">
                        <Label fx:id="env4Name" text="DR/Backup" style="-fx-font-weight: bold; -fx-font-size: 16;"/>
                        <Separator orientation="VERTICAL"/>
                        <Label fx:id="env4Status" text="Not Connected" style="-fx-text-fill: #6c757d;"/>
                        <Separator orientation="VERTICAL"/>
                        <Label fx:id="env4Stats" text="Lines: 0 | Errors: 0 | Warnings: 0" style="-fx-font-size: 11;"/>
                    </HBox>

                    <HBox spacing="10" alignment="CENTER_LEFT" style="-fx-background-color: #f8f9fa; -fx-padding: 10;">
                        <Button fx:id="env4LoadButton" text="Load Log File" onAction="#onLoadEnv4"
                                style="-fx-background-color: #6c757d; -fx-text-fill: white;"/>
                        <Separator orientation="VERTICAL"/>
                        <CheckBox fx:id="env4AutoRefresh" text="Auto-Refresh"/>
                        <Label text="Interval (sec):"/>
                        <TextField fx:id="env4RefreshInterval" prefWidth="60" promptText="5"/>
                        <Separator orientation="VERTICAL"/>
                        <Label text="Search:"/>
                        <TextField fx:id="env4SearchField" promptText="Filter logs..." prefWidth="200"/>
                        <Button fx:id="env4PrevError" text="â Prev Error" onAction="#onEnv4PrevError" style="-fx-font-size: 10;"/>
                        <Button fx:id="env4NextError" text="Next Error â" onAction="#onEnv4NextError" style="-fx-font-size: 10;"/>
                    </HBox>

                    <ListView fx:id="env4ListView" VBox.vgrow="ALWAYS"
                              style="-fx-font-family: 'Consolas', 'Monaco', monospace; -fx-font-size: 10px;"/>
                </VBox>
            </Tab>

        </TabPane>
    </center>

    <!-- Bottom: Help -->
    <bottom>
        <HBox style="-fx-background-color: #ecf0f1; -fx-padding: 10;" spacing="20">
            <Label text="ð¡ Tips: Load different log files in each tab. Use 'Search All' to find the same Trace ID across all environments. Enable Auto-Refresh for real-time monitoring."
                   wrapText="true" style="-fx-font-size: 11; -fx-text-fill: #7f8c8d;"/>
        </HBox>
    </bottom>

</BorderPane>
--------------------------------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>

<?import javafx.geometry.Insets?>
<?import javafx.scene.canvas.Canvas?>
<?import javafx.scene.control.*?>
<?import javafx.scene.layout.*?>

<VBox xmlns="http://javafx.com/javafx"
      xmlns:fx="http://javafx.com/fxml"
      fx:controller="com.logviewer.SequenceDiagramController"
      spacing="10" style="-fx-background-color: #f4f4f4;">
    <padding>
        <Insets top="10" right="10" bottom="10" left="10"/>
    </padding>

    <!-- Header -->
    <HBox spacing="10" alignment="CENTER_LEFT" style="-fx-background-color: white; -fx-padding: 10;">
        <Label text="Log Flow Sequence Diagram" style="-fx-font-size: 16px; -fx-font-weight: bold;"/>
        <Region HBox.hgrow="ALWAYS"/>
        <Label text="Request ID:"/>
        <ComboBox fx:id="requestIdSelector" prefWidth="250" promptText="Select Request ID..."/>
        <Button text="Refresh" onAction="#onRefresh" style="-fx-background-color: #007bff; -fx-text-fill: white;"/>
        <Button text="Export" onAction="#onExport" style="-fx-background-color: #28a745; -fx-text-fill: white;"/>
    </HBox>

    <!-- Stats Label -->
    <Label fx:id="statsLabel" text="No data" style="-fx-font-size: 12px; -fx-text-fill: #666;"/>

    <!-- Main Content -->
    <SplitPane dividerPositions="0.7" VBox.vgrow="ALWAYS">
        <!-- Sequence Diagram Canvas -->
        <ScrollPane fx:id="canvasScrollPane" style="-fx-background-color: white;">
            <Canvas fx:id="sequenceCanvas" width="800" height="600"/>
        </ScrollPane>

        <!-- Event Details Panel -->
        <VBox spacing="5" style="-fx-background-color: white; -fx-padding: 10;">
            <Label text="Event Details" style="-fx-font-weight: bold; -fx-font-size: 14px;"/>
            <Separator/>
            <TextArea fx:id="eventDetailsArea"
                     promptText="Click on any event in the diagram to see details..."
                     editable="false"
                     wrapText="true"
                     VBox.vgrow="ALWAYS"
                     style="-fx-font-family: 'Consolas', 'Courier New', monospace; -fx-font-size: 11px;"/>
        </VBox>
    </SplitPane>

    <!-- Help Text -->
    <HBox spacing="10" style="-fx-background-color: #e9ecef; -fx-padding: 5;">
        <Label text="ð¡ Click on events in the diagram to see full details. Green = Success, Red = Error."
               style="-fx-font-size: 11px;"/>
    </HBox>
</VBox>
------------------------------------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>

<?import javafx.geometry.Insets?>
<?import javafx.scene.control.*?>
<?import javafx.scene.layout.*?>
<?import javafx.scene.text.Font?>

<BorderPane xmlns="http://javafx.com/javafx"
            xmlns:fx="http://javafx.com/fxml"
            fx:controller="com.logviewer.SQLQueryAnalyzerController"
            prefWidth="1600" prefHeight="1000">

    <!-- Top: Title and Statistics -->
    <top>
        <VBox style="-fx-background-color: #2c3e50; -fx-padding: 15;">
            <Label text="SQL Query Analyzer" textFill="white">
                <font>
                    <Font name="System Bold" size="20"/>
                </font>
            </Label>
            <Label fx:id="statsLabel" textFill="#ecf0f1" wrapText="true">
                <font>
                    <Font size="12"/>
                </font>
                <VBox.margin>
                    <Insets top="5"/>
                </VBox.margin>
            </Label>
        </VBox>
    </top>

    <!-- Center: Main Content -->
    <center>
        <SplitPane dividerPositions="0.5" orientation="VERTICAL">
            <!-- Top Half: Query List and Details -->
            <SplitPane dividerPositions="0.6">
                <!-- Left: Query Table -->
                <VBox>
                    <Label text="SQL Queries in Execution Sequence" style="-fx-font-weight: bold; -fx-font-size: 14; -fx-padding: 10;">
                        <VBox.margin>
                            <Insets bottom="5"/>
                        </VBox.margin>
                    </Label>

                    <TableView fx:id="queryTableView" VBox.vgrow="ALWAYS">
                        <columns>
                            <TableColumn fx:id="lineNumberColumn" text="Line" prefWidth="60" minWidth="50"/>
                            <TableColumn fx:id="queryTypeColumn" text="Type" prefWidth="80" minWidth="70"/>
                            <TableColumn fx:id="queryPreviewColumn" text="Query Preview" prefWidth="400" minWidth="200"/>
                            <TableColumn fx:id="durationColumn" text="Duration (ms)" prefWidth="100" minWidth="90"/>
                            <TableColumn fx:id="statusColumn" text="Status" prefWidth="100" minWidth="80"/>
                            <TableColumn fx:id="timeColumn" text="Execution Time" prefWidth="120" minWidth="100"/>
                        </columns>
                        <columnResizePolicy>
                            <TableView fx:constant="CONSTRAINED_RESIZE_POLICY"/>
                        </columnResizePolicy>
                    </TableView>
                </VBox>

                <!-- Right: Query Details -->
                <VBox spacing="10" style="-fx-padding: 10;">
                    <Label fx:id="selectedQueryLabel" text="Select a query to view details"
                           style="-fx-font-weight: bold; -fx-font-size: 14;"/>

                    <Separator/>

                    <!-- Full Query -->
                    <VBox spacing="5">
                        <Label text="Full SQL Query:" style="-fx-font-weight: bold;"/>
                        <TextArea fx:id="queryDetailsArea" prefHeight="120" wrapText="true" editable="false"
                                  style="-fx-font-family: 'Courier New'; -fx-font-size: 12;"/>
                    </VBox>

                    <!-- Execution Details -->
                    <VBox spacing="5">
                        <Label text="Execution Details:" style="-fx-font-weight: bold;"/>
                        <TextArea fx:id="executionDetailsArea" prefHeight="100" editable="false"
                                  style="-fx-font-family: 'Courier New'; -fx-font-size: 11;"/>
                    </VBox>

                    <!-- Original Log Line -->
                    <VBox spacing="5">
                        <Label text="Original Log Line:" style="-fx-font-weight: bold;"/>
                        <TextArea fx:id="logLineArea" prefHeight="60" wrapText="true" editable="false"
                                  style="-fx-font-family: 'Courier New'; -fx-font-size: 11;"/>
                    </VBox>

                    <!-- Action Buttons -->
                    <HBox spacing="10" alignment="CENTER_LEFT">
                        <Button fx:id="copyQueryButton" text="Copy Query to Clipboard" onAction="#onCopyQuery"
                                style="-fx-background-color: #3498db; -fx-text-fill: white; -fx-font-weight: bold;"/>
                        <Button text="Refresh" onAction="#onRefresh"
                                style="-fx-background-color: #95a5a6; -fx-text-fill: white;"/>
                    </HBox>
                </VBox>
            </SplitPane>

            <!-- Bottom Half: Databricks Execution -->
            <VBox spacing="10" style="-fx-padding: 10;">
                <Label text="Execute Query on Databricks" style="-fx-font-weight: bold; -fx-font-size: 14;"/>

                <!-- Databricks Configuration -->
                <GridPane hgap="10" vgap="8">
                    <columnConstraints>
                        <ColumnConstraints hgrow="NEVER" minWidth="120"/>
                        <ColumnConstraints hgrow="ALWAYS" minWidth="300"/>
                    </columnConstraints>

                    <Label text="Databricks Host:" GridPane.columnIndex="0" GridPane.rowIndex="0"/>
                    <TextField fx:id="databricksHostField" promptText="e.g., adb-1234567890123456.7.azuredatabricks.net"
                               GridPane.columnIndex="1" GridPane.rowIndex="0"/>

                    <Label text="Access Token:" GridPane.columnIndex="0" GridPane.rowIndex="1"/>
                    <PasswordField fx:id="databricksTokenField" promptText="Your Databricks personal access token"
                                   GridPane.columnIndex="1" GridPane.rowIndex="1"/>

                    <Label text="SQL HTTP Path:" GridPane.columnIndex="0" GridPane.rowIndex="2"/>
                    <TextField fx:id="databricksPathField" promptText="e.g., /sql/1.0/warehouses/abc123def456"
                               GridPane.columnIndex="1" GridPane.rowIndex="2"/>
                </GridPane>

                <!-- Execution Controls -->
                <HBox spacing="10" alignment="CENTER_LEFT">
                    <Button fx:id="executeButton" text="Execute Query on Databricks" onAction="#onExecuteQuery"
                            style="-fx-background-color: #27ae60; -fx-text-fill: white; -fx-font-weight: bold; -fx-font-size: 14; -fx-padding: 10 20;"/>
                    <Button fx:id="exportResultsButton" text="Export Results to CSV" onAction="#onExportResults"
                            style="-fx-background-color: #e67e22; -fx-text-fill: white; -fx-font-weight: bold;"/>
                    <ProgressBar fx:id="executionProgressBar" prefWidth="200" visible="false"/>
                    <Label fx:id="resultsStatusLabel" text="Ready to execute"/>
                </HBox>

                <Separator/>

                <!-- Results Table (with virtual scrolling) -->
                <VBox spacing="5" VBox.vgrow="ALWAYS">
                    <Label text="Query Results:" style="-fx-font-weight: bold;"/>
                    <TableView fx:id="resultsTableView" VBox.vgrow="ALWAYS">
                        <!-- Columns will be added dynamically based on query results -->
                        <placeholder>
                            <Label text="Execute a query to see results here"
                                   style="-fx-font-size: 14; -fx-text-fill: #7f8c8d;"/>
                        </placeholder>
                    </TableView>
                    <Label text="Virtual scrolling enabled - supports millions of rows"
                           style="-fx-font-size: 10; -fx-text-fill: #95a5a6; -fx-font-style: italic;"/>
                </VBox>
            </VBox>
        </SplitPane>
    </center>

    <!-- Bottom: Help Text -->
    <bottom>
        <HBox style="-fx-background-color: #ecf0f1; -fx-padding: 10;" spacing="20">
            <Label text="Tips: Select any query from the list to see details. Click 'Copy Query' to copy SQL to clipboard. Configure Databricks connection to execute queries directly."
                   wrapText="true" style="-fx-font-size: 11; -fx-text-fill: #7f8c8d;"/>
        </HBox>
    </bottom>

</BorderPane>
----------------------------------
/* Main application styling */
.root {
    -fx-font-family: "Segoe UI", "Arial", sans-serif;
    -fx-font-size: 13px;
}

/* Button styling */
.button {
    -fx-background-color: #007bff;
    -fx-text-fill: white;
    -fx-padding: 5 15 5 15;
    -fx-background-radius: 4;
    -fx-cursor: hand;
}

.button:hover {
    -fx-background-color: #0056b3;
}

.button:pressed {
    -fx-background-color: #004085;
}

.button:disabled {
    -fx-background-color: #6c757d;
    -fx-opacity: 0.6;
}

/* TextField styling */
.text-field {
    -fx-background-color: white;
    -fx-border-color: #ced4da;
    -fx-border-radius: 4;
    -fx-background-radius: 4;
    -fx-padding: 5;
}

.text-field:focused {
    -fx-border-color: #80bdff;
    -fx-border-width: 2;
}

/* ListView styling */
.list-view {
    -fx-background-color: white;
    -fx-border-color: #ced4da;
    -fx-border-radius: 4;
}

.list-view .list-cell {
    -fx-padding: 2 5 2 5;
    -fx-background-color: transparent;
}

.list-view .list-cell:even {
    -fx-background-color: #f8f9fa;
}

.list-view .list-cell:selected {
    -fx-background-color: #007bff;
    -fx-text-fill: white;
}

.list-view .list-cell:filled:hover {
    -fx-background-color: #e9ecef;
}

/* CheckBox styling */
.check-box {
    -fx-cursor: hand;
}

.check-box .box {
    -fx-background-color: white;
    -fx-border-color: #ced4da;
    -fx-border-radius: 3;
}

.check-box:selected .mark {
    -fx-background-color: #007bff;
}

/* DatePicker styling */
.date-picker {
    -fx-background-color: white;
}

.date-picker .text-field {
    -fx-background-color: white;
    -fx-border-color: #ced4da;
}

/* Label styling */
.label {
    -fx-text-fill: #212529;
}

/* Separator styling */
.separator {
    -fx-background-color: #dee2e6;
}

/* SplitPane styling */
.split-pane {
    -fx-background-color: #f4f4f4;
}

.split-pane-divider {
    -fx-background-color: #ced4da;
    -fx-padding: 0 2 0 2;
}

/* ProgressBar styling */
.progress-bar {
    -fx-accent: #007bff;
}

.progress-bar .track {
    -fx-background-color: #e9ecef;
}

.progress-bar .bar {
    -fx-background-color: #007bff;
}

/* Tooltip styling */
.tooltip {
    -fx-background-color: #212529;
    -fx-text-fill: white;
    -fx-font-size: 12px;
    -fx-padding: 5;
    -fx-background-radius: 4;
}

/* ScrollBar styling */
.scroll-bar {
    -fx-background-color: #f8f9fa;
}

.scroll-bar .thumb {
    -fx-background-color: #adb5bd;
    -fx-background-radius: 5;
}

.scroll-bar .thumb:hover {
    -fx-background-color: #6c757d;
}

/* Custom log level colors */
.log-error {
    -fx-text-fill: #dc3545;
    -fx-font-weight: bold;
}

.log-warn {
    -fx-text-fill: #ffc107;
}

.log-info {
    -fx-text-fill: #212529;
}

.log-debug {
    -fx-text-fill: #6c757d;
}

.log-trace {
    -fx-text-fill: #adb5bd;
}
-------------------------------------------------

/* Blue Theme */
.root {
    -fx-base: #E3F2FD;
    -fx-background: #BBDEFB;
    -fx-control-inner-background: #E3F2FD;
    -fx-accent: #1976D2;
}

/* Background colors */
VBox, HBox, SplitPane {
    -fx-background-color: #E3F2FD;
}

/* Text colors */
.label {
    -fx-text-fill: #0D47A1;
}

/* Text fields and inputs */
.text-field, .text-area, .password-field {
    -fx-background-color: white;
    -fx-text-fill: #0D47A1;
    -fx-border-color: #64B5F6;
}

.text-field:focused, .text-area:focused, .password-field:focused {
    -fx-border-color: #1976D2;
    -fx-border-width: 2px;
}

/* Buttons */
.button {
    -fx-background-color: #2196F3;
    -fx-text-fill: white;
}

.button:hover {
    -fx-background-color: #1976D2;
}

.button:pressed {
    -fx-background-color: #0D47A1;
}

/* List views */
.list-view {
    -fx-background-color: white;
    -fx-control-inner-background: white;
}

.list-cell {
    -fx-background-color: white;
    -fx-text-fill: #0D47A1;
    -fx-font-family: "Consolas", "Courier New", monospace;
}

.list-cell:filled:selected {
    -fx-background-color: #64B5F6;
    -fx-text-fill: #0D47A1;
}

.list-cell:filled:hover {
    -fx-background-color: #BBDEFB;
}

/* ComboBox */
.combo-box {
    -fx-background-color: white;
    -fx-border-color: #64B5F6;
}

/* CheckBox */
.check-box {
    -fx-text-fill: #0D47A1;
}

.check-box .box {
    -fx-background-color: white;
    -fx-border-color: #2196F3;
}

/* RadioButton */
.radio-button {
    -fx-text-fill: #0D47A1;
}

/* Progress bar */
.progress-bar .bar {
    -fx-background-color: #2196F3;
}

/* Separator */
.separator .line {
    -fx-border-color: #64B5F6;
}
--------------

/* Dark Theme */
.root {
    -fx-base: #2b2b2b;
    -fx-background: #1e1e1e;
    -fx-control-inner-background: #3c3f41;
    -fx-accent: #4A9EFF;
}

/* Background colors */
VBox, HBox, SplitPane {
    -fx-background-color: #2b2b2b;
}

/* Text colors */
.label {
    -fx-text-fill: #d4d4d4;
}

/* Text fields and inputs */
.text-field, .text-area, .password-field {
    -fx-background-color: #3c3f41;
    -fx-text-fill: #d4d4d4;
    -fx-prompt-text-fill: #808080;
    -fx-border-color: #555555;
}

.text-field:focused, .text-area:focused, .password-field:focused {
    -fx-border-color: #4A9EFF;
}

/* Buttons */
.button {
    -fx-background-color: #3c3f41;
    -fx-text-fill: #d4d4d4;
    -fx-border-color: #555555;
}

.button:hover {
    -fx-background-color: #4c4f51;
}

.button:pressed {
    -fx-background-color: #2c2f31;
}

/* List views */
.list-view {
    -fx-background-color: #2b2b2b;
    -fx-control-inner-background: #2b2b2b;
}

.list-cell {
    -fx-background-color: #2b2b2b;
    -fx-text-fill: #d4d4d4;
    -fx-font-family: "Consolas", "Courier New", monospace;
}

.list-cell:filled:selected {
    -fx-background-color: #214283;
    -fx-text-fill: white;
}

.list-cell:filled:hover {
    -fx-background-color: #3c3f41;
}

/* ComboBox */
.combo-box {
    -fx-background-color: #3c3f41;
}

.combo-box .list-cell {
    -fx-background-color: #3c3f41;
    -fx-text-fill: #d4d4d4;
}

/* CheckBox */
.check-box {
    -fx-text-fill: #d4d4d4;
}

.check-box .box {
    -fx-background-color: #3c3f41;
    -fx-border-color: #555555;
}

/* RadioButton */
.radio-button {
    -fx-text-fill: #d4d4d4;
}

/* Spinner */
.spinner {
    -fx-background-color: #3c3f41;
}

.spinner .text-field {
    -fx-background-color: #3c3f41;
    -fx-text-fill: #d4d4d4;
}

/* Progress bar */
.progress-bar {
    -fx-background-color: #3c3f41;
}

.progress-bar .bar {
    -fx-background-color: #4A9EFF;
}

/* Separator */
.separator .line {
    -fx-border-color: #555555;
}

/* ScrollBar */
.scroll-bar {
    -fx-background-color: #2b2b2b;
}

.scroll-bar .thumb {
    -fx-background-color: #555555;
}

.scroll-bar .thumb:hover {
    -fx-background-color: #666666;
}

/* DatePicker */
.date-picker {
    -fx-background-color: #3c3f41;
}

.date-picker-popup {
    -fx-background-color: #2b2b2b;
}
-----------------------------------------------------

/* Green/Nature Theme */
.root {
    -fx-base: #E8F5E9;
    -fx-background: #C8E6C9;
    -fx-control-inner-background: #E8F5E9;
    -fx-accent: #388E3C;
}

/* Background colors */
VBox, HBox, SplitPane {
    -fx-background-color: #E8F5E9;
}

/* Text colors */
.label {
    -fx-text-fill: #1B5E20;
}

/* Text fields and inputs */
.text-field, .text-area, .password-field {
    -fx-background-color: white;
    -fx-text-fill: #1B5E20;
    -fx-border-color: #81C784;
}

.text-field:focused, .text-area:focused, .password-field:focused {
    -fx-border-color: #388E3C;
    -fx-border-width: 2px;
}

/* Buttons */
.button {
    -fx-background-color: #4CAF50;
    -fx-text-fill: white;
}

.button:hover {
    -fx-background-color: #388E3C;
}

.button:pressed {
    -fx-background-color: #2E7D32;
}

/* List views */
.list-view {
    -fx-background-color: white;
    -fx-control-inner-background: white;
}

.list-cell {
    -fx-background-color: white;
    -fx-text-fill: #1B5E20;
    -fx-font-family: "Consolas", "Courier New", monospace;
}

.list-cell:filled:selected {
    -fx-background-color: #81C784;
    -fx-text-fill: #1B5E20;
}

.list-cell:filled:hover {
    -fx-background-color: #C8E6C9;
}

/* ComboBox */
.combo-box {
    -fx-background-color: white;
    -fx-border-color: #81C784;
}

/* CheckBox */
.check-box {
    -fx-text-fill: #1B5E20;
}

.check-box .box {
    -fx-background-color: white;
    -fx-border-color: #4CAF50;
}

/* RadioButton */
.radio-button {
    -fx-text-fill: #1B5E20;
}

/* Progress bar */
.progress-bar .bar {
    -fx-background-color: #4CAF50;
}

/* Separator */
.separator .line {
    -fx-border-color: #81C784;
}
--------------------------------------

/* Light Theme (Default) */
.root {
    -fx-base: #f4f4f4;
    -fx-background: white;
    -fx-control-inner-background: white;
    -fx-accent: #0078d4;
}

/* Background colors */
VBox, HBox, SplitPane {
    -fx-background-color: #f4f4f4;
}

/* Text colors */
.label {
    -fx-text-fill: #333333;
}

/* Text fields and inputs */
.text-field, .text-area, .password-field {
    -fx-background-color: white;
    -fx-text-fill: #333333;
    -fx-border-color: #cccccc;
}

.text-field:focused, .text-area:focused, .password-field:focused {
    -fx-border-color: #0078d4;
    -fx-border-width: 2px;
}

/* Buttons */
.button {
    -fx-background-color: #e1e1e1;
    -fx-text-fill: #333333;
}

.button:hover {
    -fx-background-color: #d1d1d1;
}

.button:pressed {
    -fx-background-color: #c1c1c1;
}

/* List views */
.list-view {
    -fx-background-color: white;
    -fx-control-inner-background: white;
}

.list-cell {
    -fx-background-color: white;
    -fx-text-fill: #333333;
    -fx-font-family: "Consolas", "Courier New", monospace;
}

.list-cell:filled:selected {
    -fx-background-color: #0078d4;
    -fx-text-fill: white;
}

.list-cell:filled:hover {
    -fx-background-color: #f0f0f0;
}

/* ComboBox */
.combo-box {
    -fx-background-color: white;
    -fx-border-color: #cccccc;
}

/* CheckBox */
.check-box {
    -fx-text-fill: #333333;
}

.check-box .box {
    -fx-background-color: white;
    -fx-border-color: #999999;
}

/* RadioButton */
.radio-button {
    -fx-text-fill: #333333;
}

/* Progress bar */
.progress-bar .bar {
    -fx-background-color: #0078d4;
}

/* Separator */
.separator .line {
    -fx-border-color: #cccccc;
}
------------
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
         http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.logviewer</groupId>
    <artifactId>log-viewer-app</artifactId>
    <version>1.0.0</version>
    <packaging>jar</packaging>

    <properties>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <maven.compiler.source>21</maven.compiler.source>
        <maven.compiler.target>21</maven.compiler.target>
        <javafx.version>21.0.1</javafx.version>
    </properties>

    <dependencies>
        <!-- JavaFX Controls -->
        <dependency>
            <groupId>org.openjfx</groupId>
            <artifactId>javafx-controls</artifactId>
            <version>${javafx.version}</version>
        </dependency>

        <!-- JavaFX FXML -->
        <dependency>
            <groupId>org.openjfx</groupId>
            <artifactId>javafx-fxml</artifactId>
            <version>${javafx.version}</version>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <!-- Maven Compiler Plugin -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.11.0</version>
                <configuration>
                    <source>21</source>
                    <target>21</target>
                    <executable>C:\Program Files\Java\jdk-21\bin\javac</executable>
                    <fork>true</fork>
                </configuration>
            </plugin>

            <!-- JavaFX Maven Plugin - Required for proper module path setup -->
            <plugin>
                <groupId>org.openjfx</groupId>
                <artifactId>javafx-maven-plugin</artifactId>
                <version>0.0.8</version>
                <configuration>
                    <mainClass>com.logviewer.LogViewerApp</mainClass>
                    <executable>C:\Program Files\Java\jdk-21\bin\java</executable>
                </configuration>
            </plugin>

            <!-- Maven Dependency Plugin - Copy dependencies to lib folder -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-dependency-plugin</artifactId>
                <version>3.6.1</version>
                <executions>
                    <execution>
                        <id>copy-dependencies</id>
                        <phase>package</phase>
                        <goals>
                            <goal>copy-dependencies</goal>
                        </goals>
                        <configuration>
                            <outputDirectory>${project.build.directory}/lib</outputDirectory>
                            <includeScope>runtime</includeScope>
                        </configuration>
                    </execution>
                </executions>
            </plugin>

            <!-- Maven JAR Plugin - Create JAR with classpath -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-jar-plugin</artifactId>
                <version>3.3.0</version>
                <configuration>
                    <archive>
                        <manifest>
                            <addClasspath>true</addClasspath>
                            <classpathPrefix>lib/</classpathPrefix>
                            <mainClass>com.logviewer.LogViewerApp</mainClass>
                        </manifest>
                    </archive>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>
