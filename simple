package com.example.aspect;

import org.apache.ibatis.mapping.BoundSql;
import org.apache.ibatis.mapping.MappedStatement;
import org.apache.ibatis.mapping.ParameterMapping;
import org.apache.ibatis.reflection.MetaObject;
import org.apache.ibatis.session.Configuration;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.type.TypeHandlerRegistry;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.reflect.MethodSignature;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.math.BigDecimal;
import java.math.BigInteger;
import java.sql.Timestamp;
import java.text.SimpleDateFormat;
import java.time.*;
import java.time.format.DateTimeFormatter;
import java.util.*;

@Aspect
public class SqlLoggingAspect {

    private static final Logger log = LoggerFactory.getLogger(SqlLoggingAspect.class);

    private final SqlSessionFactory sqlSessionFactory;

    public SqlLoggingAspect(SqlSessionFactory sqlSessionFactory) {
        this.sqlSessionFactory = sqlSessionFactory;
        log.info("========================================");
        log.info("SQL Logging Aspect Initialized");
        log.info("========================================");
    }

    /**
     * UPDATE THIS: Change "com.example.mapper" to YOUR mapper package
     */
    @Around("execution(* com.example.mapper..*.*(..))")
    public Object logExecutableSql(ProceedingJoinPoint joinPoint) throws Throwable {
        Object result = null;
        Throwable executionException = null;

        // Execute the original method first
        try {
            result = joinPoint.proceed();
        } catch (Throwable e) {
            executionException = e;
        }

        // Try to log SQL (won't affect execution if logging fails)
        try {
            String executableSql = extractExecutableSql(joinPoint);
            if (executableSql != null && !executableSql.isEmpty()) {
                log.info("\n[EXECUTABLE SQL] {}\n", executableSql);
            }
        } catch (Exception e) {
            log.debug("Could not log SQL: {}", e.getMessage());
        }

        // Throw original exception if any
        if (executionException != null) {
            throw executionException;
        }

        return result;
    }

    private String extractExecutableSql(ProceedingJoinPoint joinPoint) {
        try {
            MethodSignature signature = (MethodSignature) joinPoint.getSignature();
            String className = signature.getDeclaringType().getName();
            String methodName = signature.getName();
            String statementId = className + "." + methodName;

            Configuration configuration = sqlSessionFactory.getConfiguration();

            if (!configuration.hasStatement(statementId)) {
                return null;
            }

            MappedStatement mappedStatement = configuration.getMappedStatement(statementId);
            if (mappedStatement == null) {
                return null;
            }

            Object parameterObject = buildParameterObject(joinPoint.getArgs());
            BoundSql boundSql = mappedStatement.getBoundSql(parameterObject);

            if (boundSql == null) {
                return null;
            }

            String sql = boundSql.getSql();
            if (sql == null || sql.trim().isEmpty()) {
                return null;
            }

            List<ParameterMapping> parameterMappings = boundSql.getParameterMappings();

            return replacePlaceholders(sql, parameterMappings, boundSql, configuration);

        } catch (Exception e) {
            log.debug("Failed to extract SQL: {}", e.getMessage());
            return null;
        }
    }

    private Object buildParameterObject(Object[] args) {
        if (args == null || args.length == 0) {
            return null;
        }

        if (args.length == 1) {
            return args[0];
        }

        Map<String, Object> paramMap = new HashMap<>();
        for (int i = 0; i < args.length; i++) {
            paramMap.put("param" + (i + 1), args[i]);
            paramMap.put("arg" + i, args[i]);
        }
        return paramMap;
    }

    private String replacePlaceholders(String sql,
                                       List<ParameterMapping> parameterMappings,
                                       BoundSql boundSql,
                                       Configuration configuration) {

        if (parameterMappings == null || parameterMappings.isEmpty()) {
            return cleanSql(sql);
        }

        String result = sql;
        Object parameterObject = boundSql.getParameterObject();
        TypeHandlerRegistry typeHandlerRegistry = configuration.getTypeHandlerRegistry();

        try {
            for (ParameterMapping parameterMapping : parameterMappings) {
                try {
                    String propertyName = parameterMapping.getProperty();
                    Object value = null;

                    if (parameterObject != null) {
                        if (boundSql.hasAdditionalParameter(propertyName)) {
                            value = boundSql.getAdditionalParameter(propertyName);
                        } else if (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) {
                            value = parameterObject;
                        } else {
                            MetaObject metaObject = configuration.newMetaObject(parameterObject);
                            value = metaObject.getValue(propertyName);
                        }
                    }

                    String formattedValue = formatValue(value);
                    result = result.replaceFirst("\\?", formattedValue);

                } catch (Exception e) {
                    result = result.replaceFirst("\\?", "NULL");
                }
            }
        } catch (Exception e) {
            log.debug("Error replacing placeholders: {}", e.getMessage());
        }

        return cleanSql(result);
    }

    private String formatValue(Object value) {
        if (value == null) {
            return "NULL";
        }

        try {
            if (value instanceof String) {
                return "'" + escapeSql((String) value) + "'";
            }

            if (value instanceof Character) {
                return "'" + escapeSql(value.toString()) + "'";
            }

            if (value instanceof Boolean) {
                return ((Boolean) value) ? "TRUE" : "FALSE";
            }

            if (value instanceof Byte || value instanceof Short ||
                value instanceof Integer || value instanceof Long) {
                return value.toString();
            }

            if (value instanceof Float || value instanceof Double) {
                return value.toString();
            }

            if (value instanceof BigDecimal || value instanceof BigInteger) {
                return value.toString();
            }

            if (value instanceof java.util.Date) {
                SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
                return "'" + sdf.format((java.util.Date) value) + "'";
            }

            if (value instanceof java.sql.Date) {
                return "'" + value.toString() + "'";
            }

            if (value instanceof java.sql.Time) {
                return "'" + value.toString() + "'";
            }

            if (value instanceof Timestamp) {
                SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS");
                return "'" + sdf.format((Timestamp) value) + "'";
            }

            if (value instanceof LocalDate) {
                return "'" + ((LocalDate) value).format(DateTimeFormatter.ISO_LOCAL_DATE) + "'";
            }

            if (value instanceof LocalTime) {
                return "'" + ((LocalTime) value).format(DateTimeFormatter.ISO_LOCAL_TIME) + "'";
            }

            if (value instanceof LocalDateTime) {
                return "'" + ((LocalDateTime) value).format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")) + "'";
            }

            if (value instanceof ZonedDateTime) {
                return "'" + ((ZonedDateTime) value).format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")) + "'";
            }

            if (value instanceof Instant) {
                return "'" + ((Instant) value).toString() + "'";
            }

            if (value instanceof OffsetDateTime) {
                return "'" + ((OffsetDateTime) value).format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")) + "'";
            }

            if (value instanceof byte[]) {
                byte[] bytes = (byte[]) value;
                return bytes.length > 0 ? "0x" + bytesToHex(bytes) : "NULL";
            }

            if (value instanceof UUID) {
                return "'" + value.toString() + "'";
            }

            if (value instanceof Enum) {
                return "'" + ((Enum<?>) value).name() + "'";
            }

            if (value instanceof Collection) {
                Collection<?> collection = (Collection<?>) value;
                if (collection.isEmpty()) {
                    return "()";
                }
                StringBuilder sb = new StringBuilder("(");
                int i = 0;
                for (Object item : collection) {
                    if (i++ > 0) sb.append(", ");
                    sb.append(formatValue(item));
                    if (i > 100) {
                        sb.append(", ...");
                        break;
                    }
                }
                sb.append(")");
                return sb.toString();
            }

            if (value.getClass().isArray()) {
                List<Object> list = new ArrayList<>();
                if (value instanceof Object[]) {
                    Object[] arr = (Object[]) value;
                    list.addAll(Arrays.asList(arr));
                } else {
                    int length = Math.min(java.lang.reflect.Array.getLength(value), 100);
                    for (int i = 0; i < length; i++) {
                        list.add(java.lang.reflect.Array.get(value, i));
                    }
                }
                return formatValue(list);
            }

            return "'" + escapeSql(String.valueOf(value)) + "'";

        } catch (Exception e) {
            log.debug("Error formatting value: {}", e.getMessage());
            return "NULL";
        }
    }

    private String escapeSql(String str) {
        if (str == null) return "";
        return str.replace("'", "''");
    }

    private String bytesToHex(byte[] bytes) {
        if (bytes == null || bytes.length == 0) return "";
        StringBuilder sb = new StringBuilder();
        int limit = Math.min(bytes.length, 50);
        for (int i = 0; i < limit; i++) {
            sb.append(String.format("%02X", bytes[i]));
        }
        if (bytes.length > 50) {
            sb.append("...");
        }
        return sb.toString();
    }

    private String cleanSql(String sql) {
        if (sql == null) return "";
        return sql.replaceAll("\\s+", " ").trim();
    }
}