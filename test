package com.codereview.manager.config;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.context.annotation.Configuration;
import org.springframework.scheduling.annotation.AsyncConfigurer;
import org.springframework.scheduling.annotation.EnableAsync;
import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;

import java.util.concurrent.Executor;

/**
 * Configuration for asynchronous processing
 */
@Configuration
@EnableAsync
public class AsyncConfig implements AsyncConfigurer {

    private static final Logger logger = LoggerFactory.getLogger(AsyncConfig.class);

    @Override
    public Executor getAsyncExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(2);
        executor.setMaxPoolSize(5);
        executor.setQueueCapacity(100);
        executor.setThreadNamePrefix("CodeReview-");
        executor.setWaitForTasksToCompleteOnShutdown(true);
        executor.setAwaitTerminationSeconds(60);
        executor.initialize();

        logger.info("Configured async executor with core pool size: {}, max pool size: {}",
                   executor.getCorePoolSize(), executor.getMaxPoolSize());

        return executor;
    }
}
-----------------------
package com.codereview.manager.config;

import com.codereview.manager.model.Category;
import com.codereview.manager.model.CodeReviewSubmission;
import com.codereview.manager.model.Project;
import com.codereview.manager.model.Prompt;
import com.codereview.manager.model.Team;
import com.codereview.manager.repository.CategoryRepository;
import com.codereview.manager.repository.CodeReviewSubmissionRepository;
import com.codereview.manager.repository.ProjectRepository;
import com.codereview.manager.repository.PromptRepository;
import com.codereview.manager.repository.TeamRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.CommandLineRunner;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

import java.util.HashMap;
import java.util.Map;

/**
 * Data Initializer component that populates the database with sample data on startup.
 * This is particularly useful for the H2 in-memory database which loses data on restart.
 */
@Component
public class DataInitializer implements CommandLineRunner {

    private static final Logger logger = LoggerFactory.getLogger(DataInitializer.class);

    private final CategoryRepository categoryRepository;
    private final PromptRepository promptRepository;
    private final TeamRepository teamRepository;
    private final ProjectRepository projectRepository;
    private final CodeReviewSubmissionRepository submissionRepository;

    @Autowired
    public DataInitializer(CategoryRepository categoryRepository, PromptRepository promptRepository,
                          TeamRepository teamRepository, ProjectRepository projectRepository,
                          CodeReviewSubmissionRepository submissionRepository) {
        this.categoryRepository = categoryRepository;
        this.promptRepository = promptRepository;
        this.teamRepository = teamRepository;
        this.projectRepository = projectRepository;
        this.submissionRepository = submissionRepository;
    }

    @Override
    @Transactional
    public void run(String... args) throws Exception {
        logger.info("Starting data initialization...");

        // Check if data already exists
        if (categoryRepository.count() > 0) {
            logger.info("Data already exists, skipping initialization");
            return;
        }

        // Initialize categories
        Map<String, Category> categories = initializeCategories();

        // Initialize prompts
        initializePrompts(categories);

        // Initialize teams and projects
        initializeTeamsAndProjects();

        // Initialize sample code review submissions
        initializeCodeReviewSubmissions();

        logger.info("Data initialization completed successfully!");
        logger.info("Created {} categories, {} prompts, {} teams, {} projects, and {} submissions",
                   categoryRepository.count(), promptRepository.count(),
                   teamRepository.count(), projectRepository.count(), submissionRepository.count());
    }

    private Map<String, Category> initializeCategories() {
        logger.info("Initializing categories...");
        Map<String, Category> categories = new HashMap<>();

        // Create and save categories
        categories.put("CODE_REVIEW", createAndSaveCategory("Code Review",
                "Guidelines and prompts for general code reviews"));

        categories.put("SECURITY", createAndSaveCategory("Security",
                "Security-focused review prompts and best practices"));

        categories.put("PERFORMANCE", createAndSaveCategory("Performance Analysis",
                "Performance optimization and monitoring code reviews"));

        categories.put("ARCHITECTURE", createAndSaveCategory("Architecture Review",
                "Architectural patterns, microservices, and design reviews"));

        categories.put("TESTING", createAndSaveCategory("Testing & Quality",
                "Test coverage, quality metrics, and testing strategies"));

        categories.put("CONFIG", createAndSaveCategory("Configuration Management",
                "Configuration, deployment, and infrastructure reviews"));

        categories.put("SPECIALIZED", createAndSaveCategory("Specialized Technologies",
                "Reactive programming, GraphQL, batch processing, and other specialized tech"));

        categories.put("DOCUMENTATION", createAndSaveCategory("Documentation & README",
                "README generation, API documentation, and technical writing prompts"));

        logger.info("Created {} categories", categories.size());
        return categories;
    }

    private Category createAndSaveCategory(String name, String description) {
        Category category = new Category(name, description);
        return categoryRepository.save(category);
    }

    private void initializePrompts(Map<String, Category> categories) {
        logger.info("Initializing prompts...");

        // Code Review prompts
        createPrompt("Check for proper error handling", categories.get("CODE_REVIEW"),
                "Review error handling patterns and exception management",
                """
                Please review this code for proper error handling. Check for:
                - Try-catch blocks where appropriate
                - Meaningful error messages
                - Proper exception propagation
                - Resource cleanup in finally blocks
                - Logging of errors with appropriate context

                Code to review:
                {CODE}
                """);

        // Security prompts
        createPrompt("Security Analysis Prompt", categories.get("SECURITY"),
                "Comprehensive security vulnerability analysis for Java/Spring Boot applications",
                """
                Analyze the provided Java/Spring Boot code for security vulnerabilities with focus on:

                CRITICAL CHECKS:
                1. SQL Injection vulnerabilities in repository methods, native queries, or JDBC templates
                2. Cross-Site Scripting (XSS) in REST endpoints returning HTML/JavaScript
                3. Authentication bypass possibilities in Spring Security configurations
                4. Insecure deserialization in Jackson/JSON processing
                5. Path traversal in file operations
                6. LDAP injection in directory services
                7. XXE attacks in XML processing
                8. Sensitive data exposure in logs, responses, or error messages
                9. Missing or incorrect @PreAuthorize/@Secured annotations
                10. Hardcoded credentials or API keys

                For each issue found, provide:
                - Severity level (CRITICAL/HIGH/MEDIUM/LOW)
                - Affected lines
                - CWE/CVE reference if applicable
                - Specific remediation code with Spring Security best practices
                - Example of secure implementation

                Context about the application:
                - Application type: {APPLICATION_TYPE}
                - Security framework version: {SPRING_SECURITY_VERSION}
                - Authentication method: {AUTH_METHOD}

                Code to review:
                {CODE}

                Previous security patterns in this codebase:
                {SECURITY_CONTEXT}
                """);

        createPrompt("Spring Security Configuration Audit", categories.get("SECURITY"),
                "Audit Spring Security configuration for vulnerabilities and best practices",
                """
                Audit Spring Security configuration for vulnerabilities and best practices:

                SECURITY REVIEW:
                1. Authentication
                   - Authentication provider configuration
                   - Password encoding
                   - Remember-me security
                   - Session management

                2. Authorization
                   - Role hierarchy
                   - Method security
                   - URL patterns
                   - Expression-based access

                3. CORS & CSRF
                   - CORS configuration
                   - CSRF token handling
                   - SameSite cookies
                   - Origin validation

                4. OAuth2/JWT
                   - Token validation
                   - Scope management
                   - Refresh token handling
                   - Key rotation

                5. Security Headers
                   - CSP configuration
                   - X-Frame-Options
                   - HSTS settings
                   - XSS protection

                Provide:
                - Security score (0-100)
                - Critical vulnerabilities
                - Configuration improvements
                - Compliance gaps

                Security requirements:
                {SECURITY_REQUIREMENTS}

                Code to review:
                {CODE}

                Authentication method: {AUTH_METHOD}
                """);

        // Performance prompts
        createPrompt("Performance Optimization Analysis", categories.get("PERFORMANCE"),
                "Comprehensive performance analysis of Java/Spring Boot code",
                """
                Perform a comprehensive performance analysis of this Java/Spring Boot code:

                PERFORMANCE ASPECTS TO ANALYZE:
                1. Database Query Optimization
                   - N+1 query problems in JPA/Hibernate
                   - Missing @Transactional boundaries
                   - Incorrect FetchType (LAZY vs EAGER)
                   - Missing database indexes implications
                   - Unnecessary data fetching

                2. Memory Management
                   - Memory leaks in collections or caches
                   - Large object allocations
                   - Stream API inefficiencies
                   - String concatenation in loops

                3. Concurrency Issues
                   - Thread safety violations
                   - Missing synchronization
                   - Incorrect use of concurrent collections
                   - Potential deadlocks

                4. Caching Opportunities
                   - Missing @Cacheable annotations
                   - Cache invalidation issues
                   - Redis/Caffeine optimization

                5. Async Processing
                   - Blocking I/O in reactive stack
                   - Missing @Async for long operations
                   - Thread pool sizing issues

                For each finding, provide:
                - Performance impact (HIGH/MEDIUM/LOW)
                - Benchmark estimation (e.g., "Could reduce response time by ~30%")
                - Optimized code example
                - JVM flags or Spring properties to tune

                Current performance SLA:
                - Expected response time: {RESPONSE_TIME_SLA}
                - Concurrent users: {CONCURRENT_USERS}
                - Database: {DATABASE_TYPE}

                Code to review:
                {CODE}

                Related performance metrics:
                {PERFORMANCE_METRICS}
                """);

        createPrompt("JPA/Hibernate Optimization", categories.get("PERFORMANCE"),
                "Analyze JPA/Hibernate implementation for correctness and performance",
                """
                Analyze JPA/Hibernate implementation for correctness and performance:

                FOCUS AREAS:
                1. Entity Mapping
                   - Incorrect @Entity relationships
                   - Missing indexes via @Table
                   - Improper cascade types
                   - Orphan removal settings

                2. Query Optimization
                   - JPQL/HQL inefficiencies
                   - Missing JOIN FETCH
                   - N+1 query problems
                   - Cartesian products

                3. Transaction Management
                   - @Transactional scope issues
                   - Read-only transaction opportunities
                   - Isolation level appropriateness
                   - Transaction timeout settings

                4. Hibernate Specific
                   - First-level cache issues
                   - Second-level cache opportunities
                   - Batch processing optimization
                   - Lazy initialization exceptions

                5. Database Schema
                   - Naming strategy compliance
                   - Migration script issues
                   - Foreign key constraints

                Provide:
                - Generated SQL analysis
                - Query execution plan implications
                - Suggested @Query optimizations
                - Batch processing improvements

                Database: {DATABASE_TYPE}
                Hibernate Version: {HIBERNATE_VERSION}

                Code to review:
                {CODE}

                Current database schema:
                {SCHEMA_CONTEXT}
                """);

        createPrompt("Caching Strategy Analysis", categories.get("PERFORMANCE"),
                "Evaluate caching implementation and optimization opportunities",
                """
                Evaluate caching implementation and optimization opportunities:

                REVIEW ASPECTS:
                1. Cache Configuration
                   - Cache provider selection
                   - TTL/TTI settings
                   - Eviction policies
                   - Cache sizing

                2. Cache Usage
                   - @Cacheable correctness
                   - Cache key strategy
                   - Conditional caching
                   - Cache synchronization

                3. Performance Impact
                   - Cache hit ratio analysis
                   - Memory usage
                   - Serialization overhead
                   - Network latency (distributed cache)

                4. Cache Invalidation
                   - @CacheEvict usage
                   - Cascade invalidation
                   - Scheduled refresh
                   - Event-based invalidation

                5. Distributed Caching
                   - Redis/Hazelcast configuration
                   - Cluster configuration
                   - Failover handling

                Provide:
                - Cache effectiveness score
                - Optimization recommendations
                - Memory impact analysis
                - Invalidation strategy improvements

                Cache provider: {CACHE_PROVIDER}
                Cache configuration: {CACHE_CONFIG}

                Code to review:
                {CODE}
                """);

        // Architecture prompts
        createPrompt("Microservice Architecture Review", categories.get("ARCHITECTURE"),
                "Review microservice code for architectural compliance and distributed system best practices",
                """
                Review this microservice code for architectural compliance and distributed system best practices:

                EVALUATION CRITERIA:
                1. Service Boundaries
                   - Domain-driven design adherence
                   - Bounded context violations
                   - Service coupling analysis

                2. Communication Patterns
                   - REST vs messaging appropriateness
                   - Circuit breaker implementation
                   - Retry logic and timeouts
                   - Idempotency guarantees

                3. Data Consistency
                   - Distributed transaction handling
                   - Saga pattern implementation
                   - Event sourcing correctness

                4. Service Discovery
                   - Eureka/Consul integration
                   - Load balancing configuration
                   - Health check implementation

                5. Observability
                   - Distributed tracing (Sleuth/Zipkin)
                   - Correlation ID propagation
                   - Metrics exposure
                   - Structured logging

                Analyze for:
                - Service coupling score
                - Failure resilience rating
                - Scalability bottlenecks
                - Data consistency risks

                Microservice context:
                - Service name: {SERVICE_NAME}
                - Communication protocol: {PROTOCOL}
                - Service mesh: {SERVICE_MESH}

                Code to review:
                {CODE}

                Service dependencies:
                {SERVICE_DEPENDENCIES}
                """);

        createPrompt("Event-Driven Architecture Analysis", categories.get("ARCHITECTURE"),
                "Analyze event-driven implementation for reliability and consistency",
                """
                Analyze event-driven implementation for reliability and consistency:

                EVALUATION CRITERIA:
                1. Event Design
                   - Event schema design
                   - Event versioning
                   - Event sourcing patterns
                   - CQRS implementation

                2. Message Handling
                   - Idempotency guarantees
                   - Message ordering
                   - Duplicate detection
                   - Dead letter handling

                3. Transaction Management
                   - Saga implementation
                   - Compensation logic
                   - Distributed transactions
                   - Eventual consistency

                4. Integration
                   - Kafka/RabbitMQ usage
                   - Spring Cloud Stream
                   - Message serialization
                   - Schema registry

                5. Monitoring
                   - Event tracking
                   - Latency metrics
                   - Error rates
                   - Message backlogs

                Assess:
                - Event flow correctness
                - Failure resilience
                - Consistency guarantees
                - Performance characteristics

                Message broker: {MESSAGE_BROKER}
                Event store: {EVENT_STORE}

                Code to review:
                {CODE}

                Event catalog:
                {EVENT_CATALOG}
                """);

        createPrompt("Cloud-Native Readiness Assessment", categories.get("ARCHITECTURE"),
                "Assess cloud-native readiness and Kubernetes compatibility",
                """
                Assess cloud-native readiness and Kubernetes compatibility:

                CLOUD-NATIVE CHECKLIST:
                1. Containerization
                   - Dockerfile optimization
                   - Image size analysis
                   - Layer caching
                   - Security scanning

                2. Configuration
                   - Environment variables
                   - ConfigMap/Secret usage
                   - Cloud config server
                   - Feature flags

                3. Scalability
                   - Stateless design
                   - Session management
                   - Horizontal scaling ready
                   - Resource limits

                4. Resilience
                   - Health checks
                   - Readiness probes
                   - Graceful shutdown
                   - Circuit breakers

                5. Observability
                   - Prometheus metrics
                   - Log aggregation
                   - Distributed tracing
                   - Service mesh ready

                Rate:
                - Cloud maturity level (1-5)
                - Kubernetes readiness score
                - Migration effort estimation
                - Risk assessment

                Target platform: {CLOUD_PLATFORM}
                Container orchestration: {ORCHESTRATION}

                Code to review:
                {CODE}

                Deployment configuration:
                {DEPLOYMENT_CONFIG}
                """);

        // Testing & Quality prompts
        createPrompt("Spring Boot Best Practices Review", categories.get("TESTING"),
                "Review Spring Boot code against enterprise best practices and Spring Boot 3.x standards",
                """
                Review this Spring Boot code against enterprise best practices and Spring Boot 3.x standards:

                EVALUATION CRITERIA:
                1. Dependency Injection
                   - Constructor vs field injection
                   - Circular dependencies
                   - @Autowired usage
                   - Qualifier usage

                2. Configuration Management
                   - @ConfigurationProperties vs @Value
                   - Profile-specific configurations
                   - Externalized configuration
                   - Property validation

                3. REST API Design
                   - RESTful principles adherence
                   - Proper HTTP status codes
                   - Request/Response DTOs
                   - API versioning strategy
                   - HATEOAS compliance

                4. Exception Handling
                   - Global exception handler usage
                   - Custom exceptions
                   - Error response structure
                   - Logging practices

                5. Spring Boot Starters
                   - Appropriate starter usage
                   - Version compatibility
                   - Unnecessary dependencies

                6. Actuator & Monitoring
                   - Health checks implementation
                   - Custom metrics
                   - Appropriate endpoint exposure

                Provide:
                - Compliance score (0-100)
                - Priority-ordered improvements
                - Migration path for deprecated features
                - Modern Spring Boot 3.x alternatives

                Spring Boot Version: {SPRING_BOOT_VERSION}
                Java Version: {JAVA_VERSION}

                Code to review:
                {CODE}

                Project conventions:
                {PROJECT_CONVENTIONS}
                """);

        createPrompt("Clean Code & SOLID Principles Analysis", categories.get("TESTING"),
                "Evaluate code quality using Clean Code principles and SOLID design patterns",
                """
                Evaluate code quality using Clean Code principles and SOLID design patterns:

                ANALYSIS FRAMEWORK:
                1. SOLID Principles
                   - Single Responsibility violations
                   - Open/Closed principle adherence
                   - Liskov Substitution issues
                   - Interface Segregation problems
                   - Dependency Inversion violations

                2. Clean Code Metrics
                   - Method complexity (Cyclomatic complexity > 10)
                   - Class cohesion
                   - Method/variable naming conventions
                   - Code duplication (DRY violations)
                   - Magic numbers/strings

                3. Design Patterns
                   - Appropriate pattern usage
                   - Anti-pattern detection
                   - Over-engineering assessment

                4. Readability
                   - Comment quality and necessity
                   - Self-documenting code
                   - Cognitive complexity

                Calculate and provide:
                - Cyclomatic complexity score
                - Maintainability index
                - Technical debt estimation (in hours)
                - Refactoring priority matrix

                Output format:
                - Issue type
                - Location (class:method:line)
                - Current code snippet
                - Suggested improvement
                - Effort estimate

                Code to review:
                {CODE}

                Team coding standards:
                {CODING_STANDARDS}
                """);

        createPrompt("Testing Quality Assessment", categories.get("TESTING"),
                "Evaluate test code quality, coverage, and testing strategies",
                """
                Evaluate test code quality, coverage, and testing strategies:

                ASSESSMENT CRITERIA:
                1. Test Coverage
                   - Line coverage percentage
                   - Branch coverage analysis
                   - Missing test scenarios
                   - Edge cases coverage

                2. Test Quality
                   - Test naming conventions
                   - AAA pattern compliance
                   - Test independence
                   - Assertion quality

                3. Test Types
                   - Unit vs Integration balance
                   - Missing @SpringBootTest
                   - @MockBean vs @Mock usage
                   - @DataJpaTest optimization

                4. Test Data Management
                   - Test fixture quality
                   - @Sql script usage
                   - Test data builders
                   - Database cleanup

                5. Test Performance
                   - Slow test identification
                   - Unnecessary context loading
                   - @DirtiesContext usage

                Provide:
                - Test quality score
                - Missing test scenarios
                - Test refactoring suggestions
                - Performance improvements

                Testing framework: {TEST_FRAMEWORK}
                Coverage threshold: {COVERAGE_THRESHOLD}

                Code to review:
                {CODE}

                Test execution metrics:
                {TEST_METRICS}
                """);

        createPrompt("Technical Debt Assessment", categories.get("TESTING"),
                "Perform comprehensive technical debt analysis and prioritization",
                """
                Perform comprehensive technical debt analysis and prioritization:

                ASSESSMENT DIMENSIONS:
                1. Code Debt
                   - Code smells
                   - Duplicated code
                   - Complex methods
                   - Dead code
                   - TODO/FIXME comments

                2. Design Debt
                   - Architecture violations
                   - Pattern misuse
                   - Coupling issues
                   - Missing abstractions

                3. Testing Debt
                   - Coverage gaps
                   - Flaky tests
                   - Missing test types
                   - Test maintenance burden

                4. Documentation Debt
                   - Missing documentation
                   - Outdated docs
                   - API documentation
                   - Architecture decisions

                5. Infrastructure Debt
                   - Outdated dependencies
                   - Security patches
                   - Performance bottlenecks
                   - Monitoring gaps

                Calculate:
                - Technical debt score
                - Remediation cost (hours)
                - Risk-based priority
                - ROI for fixes
                - Debt payment roadmap

                Code to review:
                {CODE}

                Current metrics:
                {CURRENT_METRICS}
                """);

        // Configuration Management prompts
        createPrompt("API Contract Validation", categories.get("CONFIG"),
                "Validate REST API implementation against OpenAPI/Swagger specifications and consumer contracts",
                """
                Validate REST API implementation against OpenAPI/Swagger specifications and consumer contracts:

                VALIDATION CHECKLIST:
                1. Contract Compliance
                   - Request/Response schema matching
                   - Required fields validation
                   - Data type consistency
                   - Enum value compliance

                2. Versioning Strategy
                   - Breaking change detection
                   - Backward compatibility
                   - Deprecation handling
                   - Version header management

                3. Documentation
                   - Swagger annotations completeness
                   - Example values provision
                   - Error response documentation
                   - Authentication documentation

                4. Consumer Contract Tests
                   - Pact/Spring Cloud Contract compliance
                   - Contract test coverage
                   - Provider state management

                Report:
                - Contract violations with severity
                - Breaking changes detected
                - Missing documentation elements
                - Consumer impact analysis

                API Specification:
                {OPENAPI_SPEC}

                Code to review:
                {CODE}

                Known consumers:
                {API_CONSUMERS}
                """);

        createPrompt("Dependency Management Analysis", categories.get("CONFIG"),
                "Analyze Maven/Gradle dependencies and dependency management",
                """
                Analyze Maven/Gradle dependencies and dependency management:

                CHECK FOR:
                1. Dependency Issues
                   - Version conflicts
                   - Transitive dependency problems
                   - Security vulnerabilities (CVEs)
                   - Deprecated libraries

                2. Optimization Opportunities
                   - Unnecessary dependencies
                   - Dependency scope issues
                   - Test dependency leakage
                   - BOM usage

                3. Spring Boot Compatibility
                   - Starter compatibility
                   - Version alignment
                   - Property overrides

                4. License Compliance
                   - License compatibility
                   - Commercial license usage
                   - Open source compliance

                Report:
                - Vulnerable dependencies with CVE scores
                - Version upgrade recommendations
                - Dependency optimization suggestions
                - License compliance issues

                Build tool: {BUILD_TOOL}
                Spring Boot version: {SPRING_BOOT_VERSION}

                Dependencies to review:
                {DEPENDENCIES}

                Security policy:
                {SECURITY_POLICY}
                """);

        createPrompt("Configuration Management Review", categories.get("CONFIG"),
                "Review application configuration and externalization strategies",
                """
                Review application configuration and externalization strategies:

                ANALYSIS POINTS:
                1. Configuration Structure
                   - Property naming conventions
                   - Configuration hierarchy
                   - Profile organization
                   - Environment-specific configs

                2. Security
                   - Sensitive data in configs
                   - Encryption needs
                   - Vault integration
                   - Config server security

                3. Validation
                   - @ConfigurationProperties validation
                   - Required properties
                   - Type safety
                   - Default values

                4. Documentation
                   - Property documentation
                   - Configuration examples
                   - Migration guides

                5. Best Practices
                   - Configuration as code
                   - Feature flags
                   - Dynamic configuration

                Identify:
                - Security risks
                - Configuration smells
                - Missing validations
                - Documentation gaps

                Configuration files:
                {CONFIG_FILES}

                Environment: {ENVIRONMENT}

                Code to review:
                {CODE}
                """);

        createPrompt("Database Migration Review", categories.get("CONFIG"),
                "Review database migration scripts (Flyway/Liquibase) for correctness and safety",
                """
                Review database migration scripts (Flyway/Liquibase) for correctness and safety:

                EVALUATION CRITERIA:
                1. Migration Safety
                   - Backward compatibility
                   - Data loss risks
                   - Rollback capability
                   - Idempotency

                2. Performance Impact
                   - Lock duration estimation
                   - Index creation strategy
                   - Large table migrations
                   - Batch processing

                3. Best Practices
                   - Naming conventions
                   - Version numbering
                   - Repeatable migrations
                   - Schema consistency

                4. Data Integrity
                   - Constraint violations
                   - Data transformation accuracy
                   - Null handling
                   - Default values

                Assess:
                - Migration risk level
                - Estimated execution time
                - Rollback strategy
                - Testing requirements

                Migration tool: {MIGRATION_TOOL}
                Database: {DATABASE_TYPE}
                Database size: {DATABASE_SIZE}

                Migration scripts:
                {MIGRATION_SCRIPTS}

                Current schema:
                {CURRENT_SCHEMA}
                """);

        // Specialized Technology prompts
        createPrompt("Reactive Programming Analysis", categories.get("SPECIALIZED"),
                "Analyze Spring WebFlux/Reactor code for reactive programming best practices",
                """
                Analyze Spring WebFlux/Reactor code for reactive programming best practices:

                REVIEW POINTS:
                1. Reactive Streams
                   - Proper Mono/Flux usage
                   - Backpressure handling
                   - Cold vs Hot streams

                2. Non-blocking Operations
                   - Blocking call detection
                   - Thread pool usage
                   - Scheduler selection

                3. Error Handling
                   - onError operators usage
                   - Retry strategies
                   - Circuit breaker integration

                4. Performance
                   - Operator efficiency
                   - Memory leaks in streams
                   - Context propagation

                5. Testing
                   - StepVerifier usage
                   - Async testing patterns

                Identify:
                - Blocking operations in reactive chain
                - Missing error handling
                - Performance bottlenecks
                - Memory leak risks

                Reactive stack: {REACTIVE_STACK}

                Code to review:
                {CODE}

                Performance requirements:
                {PERFORMANCE_REQUIREMENTS}
                """);

        createPrompt("Logging and Monitoring Review", categories.get("SPECIALIZED"),
                "Review logging, monitoring, and observability implementation",
                """
                Review logging, monitoring, and observability implementation:

                EVALUATION AREAS:
                1. Logging Practices
                   - Log levels appropriateness
                   - Structured logging (JSON)
                   - PII/sensitive data in logs
                   - Correlation ID usage
                   - Performance impact

                2. Metrics Collection
                   - Micrometer metrics usage
                   - Custom metrics relevance
                   - Metric naming conventions
                   - Cardinality issues

                3. Distributed Tracing
                   - Span creation
                   - Trace context propagation
                   - Sampling configuration

                4. Error Tracking
                   - Exception logging quality
                   - Stack trace management
                   - Error aggregation

                5. Audit Logging
                   - Compliance requirements
                   - Audit event completeness

                Provide:
                - Logging improvement suggestions
                - Missing metrics identification
                - Performance impact analysis
                - Compliance gaps

                Logging framework: {LOGGING_FRAMEWORK}
                Monitoring stack: {MONITORING_STACK}

                Code to review:
                {CODE}

                Compliance requirements:
                {COMPLIANCE_REQUIREMENTS}
                """);

        createPrompt("Spring Batch Processing Review", categories.get("SPECIALIZED"),
                "Review Spring Batch implementation for reliability and performance",
                """
                Review Spring Batch implementation for reliability and performance:

                ANALYSIS FRAMEWORK:
                1. Job Configuration
                   - Step configuration
                   - Chunk size optimization
                   - Skip/retry policies
                   - Transaction boundaries

                2. Performance
                   - Parallel processing
                   - Partitioning strategy
                   - Reader/processor/writer efficiency
                   - Database connection pooling

                3. Error Handling
                   - Skip logic appropriateness
                   - Retry configuration
                   - Error logging
                   - Failed record handling

                4. Monitoring
                   - Job metrics
                   - Progress tracking
                   - Failure alerting
                   - Job history

                5. Restartability
                   - Job restart configuration
                   - State management
                   - Idempotency guarantees

                Calculate:
                - Throughput estimation
                - Error tolerance rating
                - Scalability assessment
                - Recovery strategy score

                Batch requirements:
                - Volume: {DATA_VOLUME}
                - Frequency: {JOB_FREQUENCY}
                - SLA: {BATCH_SLA}

                Code to review:
                {CODE}
                """);

        createPrompt("GraphQL Implementation Review", categories.get("SPECIALIZED"),
                "Review GraphQL implementation for performance and security",
                """
                Review GraphQL implementation for performance and security:

                ANALYSIS POINTS:
                1. Schema Design
                   - Type definitions
                   - Nullable fields
                   - Naming conventions
                   - Schema organization

                2. Performance
                   - N+1 query problems
                   - DataLoader implementation
                   - Query complexity limits
                   - Pagination strategy

                3. Security
                   - Authentication/authorization
                   - Query depth limiting
                   - Rate limiting
                   - Field-level security

                4. Error Handling
                   - Error formatting
                   - Partial success handling
                   - Validation errors
                   - Exception mapping

                5. Best Practices
                   - Resolver organization
                   - Schema stitching
                   - Subscription handling
                   - Caching strategy

                Provide:
                - Performance bottlenecks
                - Security vulnerabilities
                - Schema improvements
                - Query optimization suggestions

                GraphQL library: {GRAPHQL_LIBRARY}

                Code to review:
                {CODE}

                Schema definition:
                {GRAPHQL_SCHEMA}
                """);

        // Documentation & README prompts
        createPrompt("Comprehensive README Generator", categories.get("DOCUMENTATION"),
                "Generate comprehensive README.md files for any project type",
                """
                You are an expert technical writer specializing in creating comprehensive README files.

                Based on the project analysis provided, create a professional README.md file that includes:

                ## Essential Sections:
                1. **Project Title & Description**: Clear, concise project overview
                2. **Features**: Key functionality and capabilities
                3. **Installation**: Step-by-step setup instructions
                4. **Usage**: Code examples and basic usage patterns
                5. **API Documentation**: Endpoints and methods (if applicable)
                6. **Configuration**: Environment variables and configuration options
                7. **Contributing**: Guidelines for contributors
                8. **License**: License information

                ## Quality Standards:
                - Use clear, professional language
                - Include code examples with proper syntax highlighting
                - Add badges for build status, version, license where appropriate
                - Structure information hierarchically with proper headings
                - Include troubleshooting section if relevant
                - Add links to documentation, demos, or related resources

                ## Markdown Best Practices:
                - Use consistent heading levels
                - Include a table of contents for long READMEs
                - Use code blocks with language specification
                - Add screenshots or diagrams where helpful
                - Use tables for structured data
                - Include emojis sparingly for visual appeal

                Make the README informative, professional, and user-friendly. Focus on what developers need to know to understand, install, and use the project effectively.
                """);

        createPrompt("API Documentation README", categories.get("DOCUMENTATION"),
                "Generate API-focused README with endpoint documentation",
                """
                You are an expert API documentation writer. Create a README.md focused on API documentation.

                Structure the README with these sections:

                ## API Documentation Focus:
                1. **API Overview**: Purpose and core functionality
                2. **Authentication**: How to authenticate with the API
                3. **Base URL & Versioning**: API base URL and version information
                4. **Endpoints**: Complete endpoint documentation with:
                   - HTTP methods
                   - Request/response examples
                   - Parameters and data types
                   - Response codes and error handling
                5. **Rate Limiting**: Usage limits and throttling
                6. **SDK/Client Libraries**: Available client libraries
                7. **Testing**: How to test the API (Postman, curl examples)
                8. **Changelog**: API version changes

                ## Documentation Standards:
                - Provide complete request/response examples in JSON
                - Include curl command examples
                - Document all parameters with types and descriptions
                - Show error responses with proper HTTP status codes
                - Include authentication examples
                - Use consistent formatting for endpoints
                - Add interactive elements where possible

                Focus on making the API easy to understand and integrate with clear, complete examples.
                """);

        createPrompt("User Guide README", categories.get("DOCUMENTATION"),
                "Generate user-focused README with tutorials and guides",
                """
                You are a technical writer specializing in user-friendly documentation. Create a README.md focused on end-users.

                Structure the README for maximum user friendliness:

                ## User-Centric Sections:
                1. **What This Does**: Plain-language explanation of the project
                2. **Quick Start**: Get up and running in 5 minutes or less
                3. **Step-by-Step Tutorial**: Detailed walkthrough with examples
                4. **Common Use Cases**: Real-world scenarios and solutions
                5. **Configuration Guide**: How to customize for different needs
                6. **Troubleshooting**: Solutions to common problems
                7. **FAQ**: Frequently asked questions
                8. **Getting Help**: Support channels and resources

                ## User Experience Focus:
                - Use simple, non-technical language where possible
                - Include screenshots and visual guides
                - Provide copy-paste code examples
                - Anticipate user questions and pain points
                - Include success indicators ("You should see...")
                - Offer multiple paths for different user types
                - Add tips and best practices

                ## Tutorial Quality:
                - Start with the simplest possible example
                - Build complexity gradually
                - Explain why, not just how
                - Include expected outputs
                - Provide links to deeper documentation

                Make the README approachable for users of all skill levels while being comprehensive enough for advanced users.
                """);

        createPrompt("Project Analysis README", categories.get("DOCUMENTATION"),
                "Generate README based on comprehensive project analysis",
                """
                You are a technical analyst and documentation expert. Based on the comprehensive project analysis provided, create a README.md that accurately reflects the project's architecture, technologies, and purpose.

                ## Analysis-Driven Documentation:
                1. **Project Overview**: Based on file structure and key files analysis
                2. **Architecture**: Describe the identified patterns and structure
                3. **Technology Stack**: List all detected technologies and frameworks
                4. **Project Structure**: Explain the directory layout and organization
                5. **Dependencies**: Key dependencies from package files
                6. **Build & Deployment**: Based on build files and configurations
                7. **Development**: Setup for contributors based on project structure
                8. **Testing**: Testing strategy based on detected test files

                ## Technical Analysis Integration:
                - Identify the primary programming language and frameworks
                - Detect architectural patterns (MVC, microservices, etc.)
                - Analyze configuration files for setup requirements
                - Extract dependency information from package managers
                - Identify build tools and deployment strategies
                - Recognize testing frameworks and strategies
                - Understand project conventions and standards

                ## Accuracy Standards:
                - Only document what can be verified from the project structure
                - Infer reasonable setup steps from configuration files
                - Explain the purpose based on file organization
                - Highlight unique aspects of the project architecture
                - Provide accurate technology versions where detected

                Create documentation that serves as both an introduction and technical reference, grounded in actual project analysis rather than assumptions.
                """);

        logger.info("Initialized {} prompts", promptRepository.count());
    }

    private void createPrompt(String title, Category category, String description, String content) {
        Prompt prompt = new Prompt(title, content, description, category);
        prompt.setIsActive(true);
        promptRepository.save(prompt);
    }

    private void initializeTeamsAndProjects() {
        logger.info("Initializing teams and projects...");

        // Create teams
        Team developmentTeam = createAndSaveTeam("Development Team",
                "Main development team responsible for core application development",
                "tech.lead@company.com", "dev-notifications@company.com,team-lead@company.com");

        Team qaTeam = createAndSaveTeam("QA Team",
                "Quality Assurance team focused on testing and quality control",
                "qa.lead@company.com", "qa-notifications@company.com");

        Team devopsTeam = createAndSaveTeam("DevOps Team",
                "DevOps and infrastructure team managing deployments and operations",
                "devops.lead@company.com", "devops-alerts@company.com");

        // Create projects for Development Team
        createAndSaveProject("Code Review Manager",
                "Web application for managing code reviews with AI assistance",
                "https://github.com/company/code-review-manager",
                "main", developmentTeam);

        createAndSaveProject("User Management System",
                "Microservice for user authentication and authorization",
                "https://github.com/company/user-management",
                "develop", developmentTeam);

        createAndSaveProject("API Gateway",
                "Central API gateway for microservices architecture",
                "https://github.com/company/api-gateway",
                "main", developmentTeam);

        // Create projects for QA Team
        createAndSaveProject("Automated Testing Suite",
                "Comprehensive automated testing framework",
                "https://github.com/company/test-automation",
                "master", qaTeam);

        // Create projects for DevOps Team
        createAndSaveProject("Infrastructure as Code",
                "Terraform and Ansible configurations for infrastructure",
                "https://github.com/company/infrastructure",
                "main", devopsTeam);

        logger.info("Created {} teams and {} projects", teamRepository.count(), projectRepository.count());
    }

    private Team createAndSaveTeam(String name, String description, String teamLeadEmail, String notificationEmails) {
        Team team = new Team(name, description);
        team.setTeamLeadEmail(teamLeadEmail);
        team.setNotificationEmails(notificationEmails);
        team.setActive(true);
        return teamRepository.save(team);
    }

    private Project createAndSaveProject(String name, String description, String repositoryUrl,
                                       String branchName, Team team) {
        Project project = new Project(name, description, team);
        project.setRepositoryUrl(repositoryUrl);
        project.setBranchName(branchName);
        project.setActive(true);
        return projectRepository.save(project);
    }

    private void initializeCodeReviewSubmissions() {
        logger.info("Initializing sample code review submissions...");

        // Get projects for creating submissions
        Project codeReviewProject = projectRepository.findByName("Code Review Manager").orElse(null);
        Project userMgmtProject = projectRepository.findByName("User Management System").orElse(null);
        Project apiGatewayProject = projectRepository.findByName("API Gateway").orElse(null);

        if (codeReviewProject != null) {
            // Sample Java code submission
            createCodeReviewSubmission(
                "abc123def456",
                "john.developer@company.com",
                "John Developer",
                codeReviewProject,
                "src/main/java/com/example/UserService.java",
                "Java",
                getSampleJavaCode(),
                CodeReviewSubmission.Priority.HIGH,
                CodeReviewSubmission.ReviewStatus.PENDING
            );

            // Sample JavaScript code submission
            createCodeReviewSubmission(
                "xyz789abc123",
                "jane.frontend@company.com",
                "Jane Frontend",
                codeReviewProject,
                "frontend/src/components/TeamManager.js",
                "JavaScript",
                getSampleJavaScriptCode(),
                CodeReviewSubmission.Priority.MEDIUM,
                CodeReviewSubmission.ReviewStatus.IN_PROGRESS
            );
        }

        if (userMgmtProject != null) {
            // Sample Spring Security configuration
            createCodeReviewSubmission(
                "def456ghi789",
                "security.expert@company.com",
                "Security Expert",
                userMgmtProject,
                "src/main/java/com/auth/SecurityConfig.java",
                "Java",
                getSampleSecurityCode(),
                CodeReviewSubmission.Priority.URGENT,
                CodeReviewSubmission.ReviewStatus.COMPLETED
            );
        }

        if (apiGatewayProject != null) {
            // Sample API Gateway configuration
            createCodeReviewSubmission(
                "ghi789jkl012",
                "api.developer@company.com",
                "API Developer",
                apiGatewayProject,
                "src/main/java/com/gateway/GatewayConfig.java",
                "Java",
                getSampleGatewayCode(),
                CodeReviewSubmission.Priority.LOW,
                CodeReviewSubmission.ReviewStatus.FAILED
            );
        }

        logger.info("Created {} code review submissions", submissionRepository.count());
    }

    private void createCodeReviewSubmission(String commitHash, String submitterEmail, String submitterName,
                                           Project project, String filePath, String language, String codeContent,
                                           CodeReviewSubmission.Priority priority,
                                           CodeReviewSubmission.ReviewStatus status) {
        CodeReviewSubmission submission = new CodeReviewSubmission(commitHash, submitterEmail, project, codeContent);
        submission.setSubmitterName(submitterName);
        submission.setFilePath(filePath);
        submission.setProgrammingLanguage(language);
        submission.setPriority(priority);
        submission.setReviewStatus(status);
        submission.generateContextualReviewId();

        // Set review dates based on status
        if (status == CodeReviewSubmission.ReviewStatus.IN_PROGRESS ||
            status == CodeReviewSubmission.ReviewStatus.COMPLETED ||
            status == CodeReviewSubmission.ReviewStatus.FAILED) {
            submission.setReviewStartedDate(submission.getSubmittedDate().plusMinutes(10));
        }

        if (status == CodeReviewSubmission.ReviewStatus.COMPLETED) {
            submission.setReviewCompletedDate(submission.getSubmittedDate().plusHours(2));
            submission.setReviewReport("Code review completed successfully. Found 2 minor issues and 1 suggestion for improvement.");
            submission.setNotificationSent(true);
        } else if (status == CodeReviewSubmission.ReviewStatus.FAILED) {
            submission.setReviewCompletedDate(submission.getSubmittedDate().plusMinutes(30));
            submission.setReviewReport("Review failed due to compilation errors. Please fix syntax errors and resubmit.");
            submission.setNotificationSent(true);
        }

        submissionRepository.save(submission);
    }

    private String getSampleJavaCode() {
        return "@Service\n" +
               "public class UserService {\n" +
               "    \n" +
               "    @Autowired\n" +
               "    private UserRepository userRepository;\n" +
               "    \n" +
               "    public User createUser(UserDto userDto) {\n" +
               "        // TODO: Add validation\n" +
               "        User user = new User();\n" +
               "        user.setUsername(userDto.getUsername());\n" +
               "        user.setEmail(userDto.getEmail());\n" +
               "        user.setPassword(userDto.getPassword()); // Security issue: plain text password!\n" +
               "        \n" +
               "        return userRepository.save(user);\n" +
               "    }\n" +
               "    \n" +
               "    public List<User> getAllUsers() {\n" +
               "        return userRepository.findAll();\n" +
               "    }\n" +
               "}";
    }

    private String getSampleJavaScriptCode() {
        return "function loadTeams() {\n" +
               "    fetch('/api/teams')\n" +
               "        .then(response => response.json())\n" +
               "        .then(teams => {\n" +
               "            const teamList = document.getElementById('team-list');\n" +
               "            teamList.innerHTML = '';\n" +
               "            \n" +
               "            teams.forEach(team => {\n" +
               "                const teamElement = document.createElement('div');\n" +
               "                teamElement.className = 'team-card';\n" +
               "                teamElement.innerHTML = `\n" +
               "                    <h3>${team.name}</h3>\n" +
               "                    <p>${team.description}</p>\n" +
               "                    <span class=\"status ${team.active ? 'active' : 'inactive'}\">\n" +
               "                        ${team.active ? 'Active' : 'Inactive'}\n" +
               "                    </span>\n" +
               "                `;\n" +
               "                teamList.appendChild(teamElement);\n" +
               "            });\n" +
               "        })\n" +
               "        .catch(error => {\n" +
               "            console.error('Error loading teams:', error);\n" +
               "        });\n" +
               "}";
    }

    private String getSampleSecurityCode() {
        return "@Configuration\n" +
               "@EnableWebSecurity\n" +
               "public class SecurityConfig {\n" +
               "    \n" +
               "    @Bean\n" +
               "    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n" +
               "        http\n" +
               "            .authorizeHttpRequests(authz -> authz\n" +
               "                .requestMatchers(\"/api/public/**\").permitAll()\n" +
               "                .requestMatchers(\"/api/admin/**\").hasRole(\"ADMIN\")\n" +
               "                .anyRequest().authenticated()\n" +
               "            )\n" +
               "            .oauth2ResourceServer(oauth2 -> oauth2\n" +
               "                .jwt(jwt -> jwt.jwtAuthenticationConverter(jwtAuthConverter()))\n" +
               "            )\n" +
               "            .csrf(csrf -> csrf.disable()); // Consider CSRF protection\n" +
               "            \n" +
               "        return http.build();\n" +
               "    }\n" +
               "}";
    }

    private String getSampleGatewayCode() {
        return "@Configuration\n" +
               "public class GatewayConfig {\n" +
               "    \n" +
               "    @Bean\n" +
               "    public RouteLocator customRouteLocator(RouteLocatorBuilder builder) {\n" +
               "        return builder.routes()\n" +
               "            .route(\"user-service\", r -> r.path(\"/api/users/**\")\n" +
               "                .uri(\"http://user-service:8080\"))\n" +
               "            .route(\"order-service\", r -> r.path(\"/api/orders/**\")\n" +
               "                .filters(f -> f.addRequestHeader(\"X-Gateway\", \"true\"))\n" +
               "                .uri(\"http://order-service:8080\"))\n" +
               "            .build();\n" +
               "    }\n" +
               "    \n" +
               "    @Bean\n" +
               "    public CorsGlobalConfig corsGlobalConfig() {\n" +
               "        // CORS configuration needed\n" +
               "        return new CorsGlobalConfig();\n" +
               "    }\n" +
               "}";
    }
}
------------------------------------
package com.codereview.manager.controller;

import com.codereview.manager.service.ClaudeApiService;
import com.codereview.manager.service.PromptService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import reactor.core.publisher.Mono;

import jakarta.validation.Valid;
import jakarta.validation.constraints.NotBlank;
import java.time.LocalDateTime;

/**
 * REST Controller for AI-powered code review and prompt testing features
 */
@RestController
@RequestMapping("/ai-review")
@CrossOrigin(origins = "*")
public class AIReviewController {

    private static final Logger logger = LoggerFactory.getLogger(AIReviewController.class);

    private final ClaudeApiService claudeApiService;
    private final PromptService promptService;

    @Autowired
    public AIReviewController(ClaudeApiService claudeApiService, PromptService promptService) {
        this.claudeApiService = claudeApiService;
        this.promptService = promptService;
    }

    /**
     * Execute a live code review with Claude AI
     * POST /api/ai-review/execute
     */
    @PostMapping("/execute")
    public Mono<ResponseEntity<Object>> executeCodeReview(@Valid @RequestBody CodeReviewRequest request) {
        logger.info("Executing code review with prompt ID: {} and code length: {}",
                   request.promptId, request.code.length());

        if (!claudeApiService.isApiKeyConfigured()) {
            return Mono.just(ResponseEntity.badRequest()
                .body(new ErrorResponse("Anthropic API key is not configured. Please set ANTHROPIC_API_KEY environment variable.")));
        }

        try {
            var prompt = promptService.getPromptById(request.promptId);
            if (prompt.isEmpty()) {
                return Mono.just(ResponseEntity.badRequest()
                    .body(new ErrorResponse("Prompt not found with ID: " + request.promptId)));
            }

            String promptContent = prompt.get().getContent();

            return claudeApiService.executeCodeReview(promptContent, request.code)
                .map(aiReview -> {
                    CodeReviewResponse response = new CodeReviewResponse();
                    response.promptId = request.promptId;
                    response.promptTitle = prompt.get().getTitle();
                    response.aiReview = aiReview;
                    response.timestamp = LocalDateTime.now();
                    response.model = "Claude 4.5 Sonnet (Spring AI)";
                    return ResponseEntity.ok((Object) response);
                })
                .onErrorReturn(ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body((Object) new ErrorResponse("Failed to execute code review. Please try again.")));

        } catch (Exception e) {
            logger.error("Error executing code review", e);
            return Mono.just(ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(new ErrorResponse("Failed to execute code review: " + e.getMessage())));
        }
    }

    /**
     * Test a prompt against sample code
     * POST /api/ai-review/test-prompt
     */
    @PostMapping("/test-prompt")
    public Mono<ResponseEntity<Object>> testPrompt(@Valid @RequestBody PromptTestRequest request) {
        logger.info("Testing prompt ID: {} with sample code length: {}",
                   request.promptId, request.sampleCode.length());

        if (!claudeApiService.isApiKeyConfigured()) {
            return Mono.just(ResponseEntity.badRequest()
                .body(new ErrorResponse("Anthropic API key is not configured. Please set ANTHROPIC_API_KEY environment variable.")));
        }

        try {
            var prompt = promptService.getPromptById(request.promptId);
            if (prompt.isEmpty()) {
                return Mono.just(ResponseEntity.badRequest()
                    .body(new ErrorResponse("Prompt not found with ID: " + request.promptId)));
            }

            String promptContent = prompt.get().getContent();

            return claudeApiService.testPrompt(promptContent, request.sampleCode)
                .map(testResult -> {
                    PromptTestResponse response = new PromptTestResponse();
                    response.promptId = request.promptId;
                    response.promptTitle = prompt.get().getTitle();
                    response.sampleCode = request.sampleCode;
                    response.testResult = testResult;
                    response.timestamp = LocalDateTime.now();
                    response.model = "Claude 4.5 Sonnet (Spring AI)";
                    return ResponseEntity.ok((Object) response);
                })
                .onErrorReturn(ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body((Object) new ErrorResponse("Failed to test prompt. Please try again.")));

        } catch (Exception e) {
            logger.error("Error testing prompt", e);
            return Mono.just(ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(new ErrorResponse("Failed to test prompt: " + e.getMessage())));
        }
    }

    /**
     * Check if Claude API is configured and available
     * GET /api/ai-review/status
     */
    @GetMapping("/status")
    public ResponseEntity<ApiStatusResponse> getApiStatus() {
        ApiStatusResponse status = new ApiStatusResponse();
        status.claudeApiConfigured = claudeApiService.isApiKeyConfigured();
        status.message = status.claudeApiConfigured ?
            "Claude AI is configured and ready (using Spring AI)" :
            "Anthropic API key is not configured. Please set ANTHROPIC_API_KEY environment variable.";
        return ResponseEntity.ok(status);
    }

    // Request/Response DTOs

    public static class CodeReviewRequest {
        @NotBlank(message = "Code is required")
        public String code;

        public Long promptId;

        // Optional context variables
        public String applicationType;
        public String springBootVersion;
        public String javaVersion;
        public String databaseType;
    }

    public static class PromptTestRequest {
        public Long promptId;

        @NotBlank(message = "Sample code is required")
        public String sampleCode;
    }

    public static class CodeReviewResponse {
        public Long promptId;
        public String promptTitle;
        public String aiReview;
        public LocalDateTime timestamp;
        public String model;
    }

    public static class PromptTestResponse {
        public Long promptId;
        public String promptTitle;
        public String sampleCode;
        public String testResult;
        public LocalDateTime timestamp;
        public String model;
    }

    public static class ApiStatusResponse {
        public boolean claudeApiConfigured;
        public String message;
    }

    public static class ErrorResponse {
        private String error;

        public ErrorResponse(String error) {
            this.error = error;
        }

        public String getError() {
            return error;
        }

        public void setError(String error) {
            this.error = error;
        }
    }
}
-------------------------
package com.codereview.manager.controller;

import com.codereview.manager.model.Category;
import com.codereview.manager.service.CategoryService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import jakarta.validation.Valid;
import java.util.List;
import java.util.Optional;

/**
 * REST Controller for Category operations
 * Provides HTTP endpoints for managing categories
 */
@RestController
@RequestMapping("/categories")
@CrossOrigin(origins = "*") // Allow CORS for frontend communication
public class CategoryController {

    private final CategoryService categoryService;

    @Autowired
    public CategoryController(CategoryService categoryService) {
        this.categoryService = categoryService;
    }

    /**
     * Get all categories
     * GET /api/categories
     */
    @GetMapping
    public ResponseEntity<List<Category>> getAllCategories() {
        List<Category> categories = categoryService.getAllCategories();
        return ResponseEntity.ok(categories);
    }

    /**
     * Get a category by ID
     * GET /api/categories/{id}
     */
    @GetMapping("/{id}")
    public ResponseEntity<Category> getCategoryById(@PathVariable Long id) {
        Optional<Category> category = categoryService.getCategoryById(id);

        if (category.isPresent()) {
            return ResponseEntity.ok(category.get());
        } else {
            return ResponseEntity.notFound().build();
        }
    }

    /**
     * Create a new category
     * POST /api/categories
     */
    @PostMapping
    public ResponseEntity<?> createCategory(@Valid @RequestBody Category category) {
        try {
            Category createdCategory = categoryService.createCategory(category);
            return ResponseEntity.status(HttpStatus.CREATED).body(createdCategory);
        } catch (IllegalArgumentException e) {
            return ResponseEntity.badRequest().body(new ErrorResponse(e.getMessage()));
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(new ErrorResponse("Failed to create category: " + e.getMessage()));
        }
    }

    /**
     * Update an existing category
     * PUT /api/categories/{id}
     */
    @PutMapping("/{id}")
    public ResponseEntity<?> updateCategory(@PathVariable Long id, @Valid @RequestBody Category category) {
        try {
            Category updatedCategory = categoryService.updateCategory(id, category);
            return ResponseEntity.ok(updatedCategory);
        } catch (IllegalArgumentException e) {
            return ResponseEntity.badRequest().body(new ErrorResponse(e.getMessage()));
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(new ErrorResponse("Failed to update category: " + e.getMessage()));
        }
    }

    /**
     * Delete a category
     * DELETE /api/categories/{id}
     */
    @DeleteMapping("/{id}")
    public ResponseEntity<?> deleteCategory(@PathVariable Long id) {
        try {
            categoryService.deleteCategory(id);
            return ResponseEntity.ok(new SuccessResponse("Category deleted successfully"));
        } catch (IllegalArgumentException e) {
            return ResponseEntity.badRequest().body(new ErrorResponse(e.getMessage()));
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(new ErrorResponse("Failed to delete category: " + e.getMessage()));
        }
    }

    /**
     * Search categories by name or description
     * GET /api/categories/search?q={searchText}
     */
    @GetMapping("/search")
    public ResponseEntity<List<Category>> searchCategories(@RequestParam(value = "q", required = false) String searchText) {
        List<Category> categories = categoryService.searchCategories(searchText);
        return ResponseEntity.ok(categories);
    }

    /**
     * Simple response class for success messages
     */
    public static class SuccessResponse {
        private String message;

        public SuccessResponse(String message) {
            this.message = message;
        }

        public String getMessage() {
            return message;
        }

        public void setMessage(String message) {
            this.message = message;
        }
    }

    /**
     * Simple response class for error messages
     */
    public static class ErrorResponse {
        private String error;

        public ErrorResponse(String error) {
            this.error = error;
        }

        public String getError() {
            return error;
        }

        public void setError(String error) {
            this.error = error;
        }
    }
}
----------------------
package com.codereview.manager.controller;

import com.codereview.manager.model.CodeReviewSubmission;
import com.codereview.manager.service.CodeReviewSubmissionService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import jakarta.validation.Valid;
import java.util.List;
import java.util.Optional;

/**
 * REST Controller for CodeReviewSubmission operations
 * Provides HTTP endpoints for managing code review submissions
 */
@RestController
@RequestMapping("/submissions")
@CrossOrigin(origins = "*")
public class CodeReviewSubmissionController {

    private final CodeReviewSubmissionService submissionService;

    @Autowired
    public CodeReviewSubmissionController(CodeReviewSubmissionService submissionService) {
        this.submissionService = submissionService;
    }

    /**
     * Get all submissions
     * GET /api/submissions
     */
    @GetMapping
    public ResponseEntity<List<CodeReviewSubmission>> getAllSubmissions() {
        List<CodeReviewSubmission> submissions = submissionService.searchSubmissions(null); // Returns all submissions
        return ResponseEntity.ok(submissions);
    }

    /**
     * Get a submission by ID
     * GET /api/submissions/{id}
     */
    @GetMapping("/{id}")
    public ResponseEntity<CodeReviewSubmission> getSubmissionById(@PathVariable Long id) {
        // Note: getSubmissionById method doesn't exist in service, using search as fallback
        List<CodeReviewSubmission> submissions = submissionService.searchSubmissions(id.toString());
        Optional<CodeReviewSubmission> submission = submissions.stream().findFirst();

        if (submission.isPresent()) {
            return ResponseEntity.ok(submission.get());
        } else {
            return ResponseEntity.notFound().build();
        }
    }

    /**
     * Get a submission by review ID
     * GET /api/submissions/review/{reviewId}
     */
    @GetMapping("/review/{reviewId}")
    public ResponseEntity<CodeReviewSubmission> getSubmissionByReviewId(@PathVariable String reviewId) {
        Optional<CodeReviewSubmission> submission = submissionService.getSubmissionByReviewId(reviewId);

        if (submission.isPresent()) {
            return ResponseEntity.ok(submission.get());
        } else {
            return ResponseEntity.notFound().build();
        }
    }

    /**
     * Get submissions by project ID
     * GET /api/submissions/project/{projectId}
     */
    @GetMapping("/project/{projectId}")
    public ResponseEntity<List<CodeReviewSubmission>> getSubmissionsByProject(@PathVariable Long projectId) {
        List<CodeReviewSubmission> submissions = submissionService.getSubmissionsByProject(projectId);
        return ResponseEntity.ok(submissions);
    }

    /**
     * Get submissions by status
     * GET /api/submissions/status/{status}
     */
    @GetMapping("/status/{status}")
    public ResponseEntity<List<CodeReviewSubmission>> getSubmissionsByStatus(@PathVariable String status) {
        try {
            CodeReviewSubmission.ReviewStatus reviewStatus = CodeReviewSubmission.ReviewStatus.valueOf(status.toUpperCase());
            List<CodeReviewSubmission> submissions = submissionService.getSubmissionsByStatus(reviewStatus);
            return ResponseEntity.ok(submissions);
        } catch (IllegalArgumentException e) {
            return ResponseEntity.badRequest().build();
        }
    }

    /**
     * Create a new submission
     * POST /api/submissions
     */
    @PostMapping
    public ResponseEntity<?> createSubmission(@Valid @RequestBody SubmissionRequest submissionRequest) {
        try {
            // Create CodeReviewSubmission from request
            CodeReviewSubmission submission = new CodeReviewSubmission();
            submission.setSubmitterName(submissionRequest.getSubmitterName());
            submission.setSubmitterEmail(submissionRequest.getSubmitterEmail());
            submission.setCodeContent(submissionRequest.getCodeContent());
            submission.setFilePath(submissionRequest.getFilePath());
            submission.setCommitHash(submissionRequest.getCommitHash());
            submission.setProgrammingLanguage(submissionRequest.getProgrammingLanguage());

            // Set priority
            if (submissionRequest.getPriority() != null) {
                submission.setPriority(CodeReviewSubmission.Priority.valueOf(submissionRequest.getPriority().toUpperCase()));
            }

            // Set project
            com.codereview.manager.model.Project project = new com.codereview.manager.model.Project();
            project.setId(submissionRequest.getProjectId());
            submission.setProject(project);

            CodeReviewSubmission createdSubmission = submissionService.submitCodeForReview(submission);
            return ResponseEntity.status(HttpStatus.CREATED).body(createdSubmission);
        } catch (IllegalArgumentException e) {
            return ResponseEntity.badRequest().body(new ErrorResponse(e.getMessage()));
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(new ErrorResponse("Failed to create submission: " + e.getMessage()));
        }
    }

    /**
     * Update submission status
     * PATCH /api/submissions/{id}/status
     */
    @PatchMapping("/{id}/status")
    public ResponseEntity<?> updateSubmissionStatus(@PathVariable Long id, @RequestBody StatusUpdateRequest request) {
        try {
            CodeReviewSubmission.ReviewStatus status = CodeReviewSubmission.ReviewStatus.valueOf(request.getStatus().toUpperCase());
            // For now, manually update the submission since updateSubmissionStatus doesn't exist
            List<CodeReviewSubmission> submissions = submissionService.searchSubmissions(id.toString());
            if (submissions.isEmpty()) {
                throw new IllegalArgumentException("Submission not found with ID: " + id);
            }
            // Note: This is a simplified implementation. In a real scenario, you'd implement proper status updates
            CodeReviewSubmission updatedSubmission = submissions.get(0);
            // Status update logic would go here
            return ResponseEntity.ok(updatedSubmission);
        } catch (IllegalArgumentException e) {
            return ResponseEntity.badRequest().body(new ErrorResponse(e.getMessage()));
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(new ErrorResponse("Failed to update submission status: " + e.getMessage()));
        }
    }

    /**
     * Cancel a submission
     * DELETE /api/submissions/{id}
     */
    @DeleteMapping("/{id}")
    public ResponseEntity<?> cancelSubmission(@PathVariable Long id) {
        try {
            // Use the actual cancelSubmission method with reviewId and reason
            List<CodeReviewSubmission> submissions = submissionService.searchSubmissions(id.toString());
            if (submissions.isEmpty()) {
                throw new IllegalArgumentException("Submission not found with ID: " + id);
            }
            String reviewId = submissions.get(0).getReviewId();
            submissionService.cancelSubmission(reviewId, "Cancelled by user");
            return ResponseEntity.ok(new SuccessResponse("Submission cancelled successfully"));
        } catch (IllegalArgumentException e) {
            return ResponseEntity.badRequest().body(new ErrorResponse(e.getMessage()));
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(new ErrorResponse("Failed to cancel submission: " + e.getMessage()));
        }
    }

    /**
     * Search submissions by submitter email or project name
     * GET /api/submissions/search?q={searchText}
     */
    @GetMapping("/search")
    public ResponseEntity<List<CodeReviewSubmission>> searchSubmissions(@RequestParam(value = "q", required = false) String searchText) {
        List<CodeReviewSubmission> submissions = submissionService.searchSubmissions(searchText);
        return ResponseEntity.ok(submissions);
    }

    /**
     * Get submission statistics
     * GET /api/submissions/stats
     */
    @GetMapping("/stats")
    public ResponseEntity<StatsResponse> getSubmissionStats() {
        // Get counts by status
        long totalCount = submissionService.searchSubmissions(null).size();
        long pendingCount = submissionService.getSubmissionsByStatus(CodeReviewSubmission.ReviewStatus.PENDING).size();
        long inProgressCount = submissionService.getSubmissionsByStatus(CodeReviewSubmission.ReviewStatus.IN_PROGRESS).size();
        long completedCount = submissionService.getSubmissionsByStatus(CodeReviewSubmission.ReviewStatus.COMPLETED).size();

        StatsResponse stats = new StatsResponse(totalCount, pendingCount, inProgressCount, completedCount);
        return ResponseEntity.ok(stats);
    }

    /**
     * Request class for creating submissions
     */
    public static class SubmissionRequest {
        private Long projectId;
        private String submitterName;
        private String submitterEmail;
        private String codeContent;
        private String filePath;
        private String commitHash;
        private String programmingLanguage;
        private String priority;

        // Getters and setters
        public Long getProjectId() {
            return projectId;
        }

        public void setProjectId(Long projectId) {
            this.projectId = projectId;
        }

        public String getSubmitterName() {
            return submitterName;
        }

        public void setSubmitterName(String submitterName) {
            this.submitterName = submitterName;
        }

        public String getSubmitterEmail() {
            return submitterEmail;
        }

        public void setSubmitterEmail(String submitterEmail) {
            this.submitterEmail = submitterEmail;
        }

        public String getCodeContent() {
            return codeContent;
        }

        public void setCodeContent(String codeContent) {
            this.codeContent = codeContent;
        }

        public String getFilePath() {
            return filePath;
        }

        public void setFilePath(String filePath) {
            this.filePath = filePath;
        }

        public String getCommitHash() {
            return commitHash;
        }

        public void setCommitHash(String commitHash) {
            this.commitHash = commitHash;
        }

        public String getProgrammingLanguage() {
            return programmingLanguage;
        }

        public void setProgrammingLanguage(String programmingLanguage) {
            this.programmingLanguage = programmingLanguage;
        }

        public String getPriority() {
            return priority;
        }

        public void setPriority(String priority) {
            this.priority = priority;
        }
    }

    /**
     * Request class for status updates
     */
    public static class StatusUpdateRequest {
        private String status;
        private String reviewReport;

        public String getStatus() {
            return status;
        }

        public void setStatus(String status) {
            this.status = status;
        }

        public String getReviewReport() {
            return reviewReport;
        }

        public void setReviewReport(String reviewReport) {
            this.reviewReport = reviewReport;
        }
    }

    /**
     * Response class for statistics
     */
    public static class StatsResponse {
        private long count;
        private long totalCount;
        private long pendingCount;
        private long inProgressCount;
        private long completedCount;

        public StatsResponse(long totalCount, long pendingCount, long inProgressCount, long completedCount) {
            this.totalCount = totalCount;
            this.pendingCount = pendingCount;
            this.inProgressCount = inProgressCount;
            this.completedCount = completedCount;
            this.count = totalCount; // For backward compatibility
        }

        public long getCount() {
            return count;
        }

        public void setCount(long count) {
            this.count = count;
        }

        public long getTotalCount() {
            return totalCount;
        }

        public void setTotalCount(long totalCount) {
            this.totalCount = totalCount;
        }

        public long getPendingCount() {
            return pendingCount;
        }

        public void setPendingCount(long pendingCount) {
            this.pendingCount = pendingCount;
        }

        public long getInProgressCount() {
            return inProgressCount;
        }

        public void setInProgressCount(long inProgressCount) {
            this.inProgressCount = inProgressCount;
        }

        public long getCompletedCount() {
            return completedCount;
        }

        public void setCompletedCount(long completedCount) {
            this.completedCount = completedCount;
        }
    }

    /**
     * Simple response class for success messages
     */
    public static class SuccessResponse {
        private String message;

        public SuccessResponse(String message) {
            this.message = message;
        }

        public String getMessage() {
            return message;
        }

        public void setMessage(String message) {
            this.message = message;
        }
    }

    /**
     * Simple response class for error messages
     */
    public static class ErrorResponse {
        private String error;

        public ErrorResponse(String error) {
            this.error = error;
        }

        public String getError() {
            return error;
        }

        public void setError(String error) {
            this.error = error;
        }
    }
}
----------------------
package com.codereview.manager.controller;

import com.codereview.manager.service.ProjectAnalysisService;
import com.codereview.manager.service.ProjectAnalysisService.ProjectAnalysisResult;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import reactor.core.publisher.Mono;

import jakarta.validation.Valid;
import jakarta.validation.constraints.NotBlank;
import java.time.LocalDateTime;

/**
 * REST Controller for project analysis and README generation features
 */
@RestController
@RequestMapping("/project-analysis")
@CrossOrigin(origins = "*")
public class ProjectAnalysisController {

    private static final Logger logger = LoggerFactory.getLogger(ProjectAnalysisController.class);

    private final ProjectAnalysisService projectAnalysisService;

    @Autowired
    public ProjectAnalysisController(ProjectAnalysisService projectAnalysisService) {
        this.projectAnalysisService = projectAnalysisService;
    }

    /**
     * Analyze project structure and get overview
     * POST /api/project-analysis/analyze
     */
    @PostMapping("/analyze")
    public Mono<ResponseEntity<Object>> analyzeProject(@Valid @RequestBody ProjectAnalysisRequest request) {
        logger.info("Analyzing project at path: {}", request.projectPath);

        try {
            return projectAnalysisService.analyzeProject(request.projectPath, "overview")
                .map(analysis -> {
                    ProjectAnalysisResponse response = new ProjectAnalysisResponse();
                    response.projectPath = analysis.projectPath;
                    response.analysisType = analysis.analysisType;
                    response.totalFiles = (Integer) analysis.projectStructure.statistics.get("totalFiles");
                    response.fileTypes = analysis.projectStructure.fileTypeCount;
                    response.projectStructure = analysis.projectStructure.fileTree;
                    response.keyFiles = analysis.keyFiles.keySet();
                    response.timestamp = LocalDateTime.now();
                    return ResponseEntity.ok((Object) response);
                })
                .onErrorReturn(ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body((Object) new ErrorResponse("Failed to analyze project: " + request.projectPath)));

        } catch (Exception e) {
            logger.error("Error analyzing project", e);
            return Mono.just(ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body((Object) new ErrorResponse("Failed to analyze project: " + e.getMessage())));
        }
    }

    /**
     * Generate README for a project
     * POST /api/project-analysis/generate-readme
     */
    @PostMapping("/generate-readme")
    public Mono<ResponseEntity<Object>> generateReadme(@Valid @RequestBody ReadmeGenerationRequest request) {
        logger.info("Generating README for project: {} with type: {}", request.projectPath, request.readmeType);

        try {
            return projectAnalysisService.generateProjectReadme(request.projectPath, request.readmeType)
                .map(readme -> {
                    ReadmeGenerationResponse response = new ReadmeGenerationResponse();
                    response.projectPath = request.projectPath;
                    response.readmeType = request.readmeType;
                    response.readmeContent = readme;
                    response.timestamp = LocalDateTime.now();
                    response.model = "Claude 4.5 Sonnet (Spring AI)";
                    return ResponseEntity.ok((Object) response);
                })
                .onErrorReturn(ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body((Object) new ErrorResponse("Failed to generate README. Please try again.")));

        } catch (Exception e) {
            logger.error("Error generating README", e);
            return Mono.just(ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body((Object) new ErrorResponse("Failed to generate README: " + e.getMessage())));
        }
    }

    /**
     * Perform comprehensive project review
     * POST /api/project-analysis/review-project
     */
    @PostMapping("/review-project")
    public Mono<ResponseEntity<Object>> reviewProject(@Valid @RequestBody ProjectReviewRequest request) {
        logger.info("Performing comprehensive review for project: {}", request.projectPath);

        try {
            return projectAnalysisService.reviewEntireProject(request.projectPath, request.promptId)
                .map(review -> {
                    ProjectReviewResponse response = new ProjectReviewResponse();
                    response.projectPath = request.projectPath;
                    response.reviewContent = review;
                    response.promptId = request.promptId;
                    response.timestamp = LocalDateTime.now();
                    response.model = "Claude 4.5 Sonnet (Spring AI)";
                    return ResponseEntity.ok((Object) response);
                })
                .onErrorReturn(ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body((Object) new ErrorResponse("Failed to review project. Please try again.")));

        } catch (Exception e) {
            logger.error("Error reviewing project", e);
            return Mono.just(ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body((Object) new ErrorResponse("Failed to review project: " + e.getMessage())));
        }
    }

    // Request/Response DTOs

    public static class ProjectAnalysisRequest {
        @NotBlank(message = "Project path is required")
        public String projectPath;
    }

    public static class ReadmeGenerationRequest {
        @NotBlank(message = "Project path is required")
        public String projectPath;

        public String readmeType = "comprehensive"; // comprehensive, api-focused, user-guide
    }

    public static class ProjectReviewRequest {
        @NotBlank(message = "Project path is required")
        public String projectPath;

        public Long promptId; // Optional: specific prompt for review
    }

    public static class ProjectAnalysisResponse {
        public String projectPath;
        public String analysisType;
        public Integer totalFiles;
        public java.util.Map<String, Integer> fileTypes;
        public java.util.List<ProjectAnalysisService.FileInfo> projectStructure;
        public java.util.Set<String> keyFiles;
        public LocalDateTime timestamp;
    }

    public static class ReadmeGenerationResponse {
        public String projectPath;
        public String readmeType;
        public String readmeContent;
        public LocalDateTime timestamp;
        public String model;
    }

    public static class ProjectReviewResponse {
        public String projectPath;
        public String reviewContent;
        public Long promptId;
        public LocalDateTime timestamp;
        public String model;
    }

    public static class ErrorResponse {
        private String error;

        public ErrorResponse(String error) {
            this.error = error;
        }

        public String getError() {
            return error;
        }

        public void setError(String error) {
            this.error = error;
        }
    }
}
----------------------------
package com.codereview.manager.controller;

import com.codereview.manager.model.Project;
import com.codereview.manager.service.ProjectService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import jakarta.validation.Valid;
import java.util.List;
import java.util.Optional;

/**
 * REST Controller for Project operations
 * Provides HTTP endpoints for managing development projects
 */
@RestController
@RequestMapping("/projects")
@CrossOrigin(origins = "*")
public class ProjectController {

    private final ProjectService projectService;

    @Autowired
    public ProjectController(ProjectService projectService) {
        this.projectService = projectService;
    }

    /**
     * Get all active projects
     * GET /api/projects
     */
    @GetMapping
    public ResponseEntity<List<Project>> getAllActiveProjects() {
        List<Project> projects = projectService.getAllActiveProjects();
        return ResponseEntity.ok(projects);
    }

    /**
     * Get all projects (including inactive)
     * GET /api/projects/all
     */
    @GetMapping("/all")
    public ResponseEntity<List<Project>> getAllProjects() {
        List<Project> projects = projectService.getAllActiveProjects(); // For now, return active projects only
        return ResponseEntity.ok(projects);
    }

    /**
     * Get a project by ID
     * GET /api/projects/{id}
     */
    @GetMapping("/{id}")
    public ResponseEntity<Project> getProjectById(@PathVariable Long id) {
        Optional<Project> project = projectService.getProjectById(id);

        if (project.isPresent()) {
            return ResponseEntity.ok(project.get());
        } else {
            return ResponseEntity.notFound().build();
        }
    }

    /**
     * Get projects by team ID
     * GET /api/projects/team/{teamId}
     */
    @GetMapping("/team/{teamId}")
    public ResponseEntity<List<Project>> getProjectsByTeam(@PathVariable Long teamId) {
        List<Project> projects = projectService.getProjectsByTeamId(teamId);
        return ResponseEntity.ok(projects);
    }

    /**
     * Create a new project
     * POST /api/projects
     */
    @PostMapping
    public ResponseEntity<?> createProject(@Valid @RequestBody ProjectRequest projectRequest) {
        try {
            // Create Project object from request
            Project project = new Project();
            project.setName(projectRequest.getName());
            project.setDescription(projectRequest.getDescription());
            project.setRepositoryUrl(projectRequest.getRepositoryUrl());
            project.setBranchName(projectRequest.getBranchName());
            project.setActive(projectRequest.getActive() != null ? projectRequest.getActive() : true);

            // Set team (create a team object with just the ID for now)
            com.codereview.manager.model.Team team = new com.codereview.manager.model.Team();
            team.setId(projectRequest.getTeamId());
            project.setTeam(team);

            Project createdProject = projectService.createProject(project);
            return ResponseEntity.status(HttpStatus.CREATED).body(createdProject);
        } catch (IllegalArgumentException e) {
            return ResponseEntity.badRequest().body(new ErrorResponse(e.getMessage()));
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(new ErrorResponse("Failed to create project: " + e.getMessage()));
        }
    }

    /**
     * Update an existing project
     * PUT /api/projects/{id}
     */
    @PutMapping("/{id}")
    public ResponseEntity<?> updateProject(@PathVariable Long id, @Valid @RequestBody ProjectRequest projectRequest) {
        try {
            // Create Project object from request
            Project project = new Project();
            project.setName(projectRequest.getName());
            project.setDescription(projectRequest.getDescription());
            project.setRepositoryUrl(projectRequest.getRepositoryUrl());
            project.setBranchName(projectRequest.getBranchName());
            project.setActive(projectRequest.getActive() != null ? projectRequest.getActive() : true);

            Project updatedProject = projectService.updateProject(id, project);
            return ResponseEntity.ok(updatedProject);
        } catch (IllegalArgumentException e) {
            return ResponseEntity.badRequest().body(new ErrorResponse(e.getMessage()));
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(new ErrorResponse("Failed to update project: " + e.getMessage()));
        }
    }

    /**
     * Delete a project
     * DELETE /api/projects/{id}
     */
    @DeleteMapping("/{id}")
    public ResponseEntity<?> deleteProject(@PathVariable Long id) {
        try {
            projectService.deleteProject(id);
            return ResponseEntity.ok(new SuccessResponse("Project deleted successfully"));
        } catch (IllegalArgumentException e) {
            return ResponseEntity.badRequest().body(new ErrorResponse(e.getMessage()));
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(new ErrorResponse("Failed to delete project: " + e.getMessage()));
        }
    }

    /**
     * Activate or deactivate a project
     * PATCH /api/projects/{id}/status
     */
    @PatchMapping("/{id}/status")
    public ResponseEntity<?> setProjectStatus(@PathVariable Long id, @RequestBody StatusRequest statusRequest) {
        try {
            Project project = projectService.getProjectById(id)
                    .orElseThrow(() -> new IllegalArgumentException("Project not found with ID: " + id));
            project.setActive(statusRequest.isActive());
            Project updatedProject = projectService.updateProject(id, project);
            return ResponseEntity.ok(updatedProject);
        } catch (IllegalArgumentException e) {
            return ResponseEntity.badRequest().body(new ErrorResponse(e.getMessage()));
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(new ErrorResponse("Failed to update project status: " + e.getMessage()));
        }
    }

    /**
     * Search projects by name or description
     * GET /api/projects/search?q={searchText}
     */
    @GetMapping("/search")
    public ResponseEntity<List<Project>> searchProjects(@RequestParam(value = "q", required = false) String searchText) {
        List<Project> projects = projectService.searchProjects(searchText);
        return ResponseEntity.ok(projects);
    }

    /**
     * Get project statistics
     * GET /api/projects/stats
     */
    @GetMapping("/stats")
    public ResponseEntity<StatsResponse> getProjectStats() {
        long activeCount = projectService.getActiveProjectsCount();
        long totalCount = activeCount; // For now, use active count as total
        StatsResponse stats = new StatsResponse(totalCount, activeCount);
        return ResponseEntity.ok(stats);
    }

    /**
     * Request class for creating/updating projects
     */
    public static class ProjectRequest {
        private String name;
        private String description;
        private Long teamId;
        private String repositoryUrl;
        private String branchName;
        private Boolean active;

        // Getters and setters
        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }

        public String getDescription() {
            return description;
        }

        public void setDescription(String description) {
            this.description = description;
        }

        public Long getTeamId() {
            return teamId;
        }

        public void setTeamId(Long teamId) {
            this.teamId = teamId;
        }

        public String getRepositoryUrl() {
            return repositoryUrl;
        }

        public void setRepositoryUrl(String repositoryUrl) {
            this.repositoryUrl = repositoryUrl;
        }

        public String getBranchName() {
            return branchName;
        }

        public void setBranchName(String branchName) {
            this.branchName = branchName;
        }

        public Boolean getActive() {
            return active;
        }

        public void setActive(Boolean active) {
            this.active = active;
        }
    }

    /**
     * Request class for status updates
     */
    public static class StatusRequest {
        private boolean active;

        public boolean isActive() {
            return active;
        }

        public void setActive(boolean active) {
            this.active = active;
        }
    }

    /**
     * Response class for statistics
     */
    public static class StatsResponse {
        private long count;
        private long totalCount;
        private long activeCount;

        public StatsResponse(long totalCount, long activeCount) {
            this.totalCount = totalCount;
            this.activeCount = activeCount;
            this.count = totalCount; // For backward compatibility
        }

        public long getCount() {
            return count;
        }

        public void setCount(long count) {
            this.count = count;
        }

        public long getTotalCount() {
            return totalCount;
        }

        public void setTotalCount(long totalCount) {
            this.totalCount = totalCount;
        }

        public long getActiveCount() {
            return activeCount;
        }

        public void setActiveCount(long activeCount) {
            this.activeCount = activeCount;
        }
    }

    /**
     * Simple response class for success messages
     */
    public static class SuccessResponse {
        private String message;

        public SuccessResponse(String message) {
            this.message = message;
        }

        public String getMessage() {
            return message;
        }

        public void setMessage(String message) {
            this.message = message;
        }
    }

    /**
     * Simple response class for error messages
     */
    public static class ErrorResponse {
        private String error;

        public ErrorResponse(String error) {
            this.error = error;
        }

        public String getError() {
            return error;
        }

        public void setError(String error) {
            this.error = error;
        }
    }
}
-------------------------
package com.codereview.manager.controller;

import com.codereview.manager.model.Prompt;
import com.codereview.manager.service.PromptService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import jakarta.validation.Valid;
import java.util.List;
import java.util.Optional;

/**
 * REST Controller for Prompt operations
 * Provides HTTP endpoints for managing prompts
 */
@RestController
@RequestMapping("/prompts")
@CrossOrigin(origins = "*") // Allow CORS for frontend communication
public class PromptController {

    private final PromptService promptService;

    @Autowired
    public PromptController(PromptService promptService) {
        this.promptService = promptService;
    }

    /**
     * Get all active prompts
     * GET /api/prompts
     */
    @GetMapping
    public ResponseEntity<List<Prompt>> getAllActivePrompts() {
        List<Prompt> prompts = promptService.getAllActivePrompts();
        return ResponseEntity.ok(prompts);
    }

    /**
     * Get all prompts (including inactive)
     * GET /api/prompts/all
     */
    @GetMapping("/all")
    public ResponseEntity<List<Prompt>> getAllPrompts() {
        List<Prompt> prompts = promptService.getAllPrompts();
        return ResponseEntity.ok(prompts);
    }

    /**
     * Get a prompt by ID
     * GET /api/prompts/{id}
     */
    @GetMapping("/{id}")
    public ResponseEntity<Prompt> getPromptById(@PathVariable Long id) {
        Optional<Prompt> prompt = promptService.getPromptById(id);

        if (prompt.isPresent()) {
            return ResponseEntity.ok(prompt.get());
        } else {
            return ResponseEntity.notFound().build();
        }
    }

    /**
     * Get active prompts by category
     * GET /api/prompts/category/{categoryId}
     */
    @GetMapping("/category/{categoryId}")
    public ResponseEntity<List<Prompt>> getActivePromptsByCategory(@PathVariable Long categoryId) {
        List<Prompt> prompts = promptService.getActivePromptsByCategory(categoryId);
        return ResponseEntity.ok(prompts);
    }

    /**
     * Get all prompts by category (including inactive)
     * GET /api/prompts/category/{categoryId}/all
     */
    @GetMapping("/category/{categoryId}/all")
    public ResponseEntity<List<Prompt>> getAllPromptsByCategory(@PathVariable Long categoryId) {
        List<Prompt> prompts = promptService.getPromptsByCategory(categoryId);
        return ResponseEntity.ok(prompts);
    }

    /**
     * Create a new prompt
     * POST /api/prompts
     */
    @PostMapping
    public ResponseEntity<?> createPrompt(@Valid @RequestBody Prompt prompt) {
        try {
            Prompt createdPrompt = promptService.createPrompt(prompt);
            return ResponseEntity.status(HttpStatus.CREATED).body(createdPrompt);
        } catch (IllegalArgumentException e) {
            return ResponseEntity.badRequest().body(new ErrorResponse(e.getMessage()));
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(new ErrorResponse("Failed to create prompt: " + e.getMessage()));
        }
    }

    /**
     * Update an existing prompt
     * PUT /api/prompts/{id}
     */
    @PutMapping("/{id}")
    public ResponseEntity<?> updatePrompt(@PathVariable Long id, @Valid @RequestBody Prompt prompt) {
        try {
            Prompt updatedPrompt = promptService.updatePrompt(id, prompt);
            return ResponseEntity.ok(updatedPrompt);
        } catch (IllegalArgumentException e) {
            return ResponseEntity.badRequest().body(new ErrorResponse(e.getMessage()));
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(new ErrorResponse("Failed to update prompt: " + e.getMessage()));
        }
    }

    /**
     * Delete a prompt
     * DELETE /api/prompts/{id}
     */
    @DeleteMapping("/{id}")
    public ResponseEntity<?> deletePrompt(@PathVariable Long id) {
        try {
            promptService.deletePrompt(id);
            return ResponseEntity.ok(new SuccessResponse("Prompt deleted successfully"));
        } catch (IllegalArgumentException e) {
            return ResponseEntity.badRequest().body(new ErrorResponse(e.getMessage()));
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(new ErrorResponse("Failed to delete prompt: " + e.getMessage()));
        }
    }

    /**
     * Activate or deactivate a prompt
     * PATCH /api/prompts/{id}/status
     */
    @PatchMapping("/{id}/status")
    public ResponseEntity<?> setPromptStatus(@PathVariable Long id, @RequestBody StatusRequest statusRequest) {
        try {
            Prompt updatedPrompt = promptService.setPromptActive(id, statusRequest.isActive());
            return ResponseEntity.ok(updatedPrompt);
        } catch (IllegalArgumentException e) {
            return ResponseEntity.badRequest().body(new ErrorResponse(e.getMessage()));
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(new ErrorResponse("Failed to update prompt status: " + e.getMessage()));
        }
    }

    /**
     * Search active prompts by text
     * GET /api/prompts/search?q={searchText}
     */
    @GetMapping("/search")
    public ResponseEntity<List<Prompt>> searchActivePrompts(@RequestParam(value = "q", required = false) String searchText) {
        List<Prompt> prompts = promptService.searchActivePrompts(searchText);
        return ResponseEntity.ok(prompts);
    }

    /**
     * Get statistics about prompts
     * GET /api/prompts/stats
     */
    @GetMapping("/stats")
    public ResponseEntity<StatsResponse> getPromptStats() {
        long activeCount = promptService.getActivePromptCount();
        StatsResponse stats = new StatsResponse(activeCount);
        return ResponseEntity.ok(stats);
    }

    /**
     * Request class for status updates
     */
    public static class StatusRequest {
        private boolean active;

        public boolean isActive() {
            return active;
        }

        public void setActive(boolean active) {
            this.active = active;
        }
    }

    /**
     * Response class for statistics
     */
    public static class StatsResponse {
        private long activePromptCount;

        public StatsResponse(long activePromptCount) {
            this.activePromptCount = activePromptCount;
        }

        public long getActivePromptCount() {
            return activePromptCount;
        }

        public void setActivePromptCount(long activePromptCount) {
            this.activePromptCount = activePromptCount;
        }
    }

    /**
     * Simple response class for success messages
     */
    public static class SuccessResponse {
        private String message;

        public SuccessResponse(String message) {
            this.message = message;
        }

        public String getMessage() {
            return message;
        }

        public void setMessage(String message) {
            this.message = message;
        }
    }

    /**
     * Simple response class for error messages
     */
    public static class ErrorResponse {
        private String error;

        public ErrorResponse(String error) {
            this.error = error;
        }

        public String getError() {
            return error;
        }

        public void setError(String error) {
            this.error = error;
        }
    }
}
--------------------------
package com.codereview.manager.controller;

import com.codereview.manager.service.TeamService;
import com.codereview.manager.service.ProjectService;
import com.codereview.manager.service.CodeReviewSubmissionService;
import com.codereview.manager.service.PromptService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * REST Controller for System operations
 * Provides health checks, activity feeds, and general system information
 */
@RestController
@RequestMapping("/")
@CrossOrigin(origins = "*")
public class SystemController {

    private final TeamService teamService;
    private final ProjectService projectService;
    private final CodeReviewSubmissionService submissionService;
    private final PromptService promptService;

    @Autowired
    public SystemController(TeamService teamService, ProjectService projectService,
                          CodeReviewSubmissionService submissionService, PromptService promptService) {
        this.teamService = teamService;
        this.projectService = projectService;
        this.submissionService = submissionService;
        this.promptService = promptService;
    }

    /**
     * Health check endpoint
     * GET /api/health
     */
    @GetMapping("/health")
    public ResponseEntity<HealthResponse> health() {
        HealthResponse health = new HealthResponse("UP", LocalDateTime.now());
        return ResponseEntity.ok(health);
    }

    /**
     * Get recent activity feed
     * GET /api/activity/recent
     */
    @GetMapping("/activity/recent")
    public ResponseEntity<List<ActivityItem>> getRecentActivity() {
        List<ActivityItem> activities = new ArrayList<>();

        // Note: In a real implementation, you would have an ActivityService
        // that tracks all system activities. For now, we return empty list
        // to show proper empty state handling in frontend

        return ResponseEntity.ok(activities);
    }

    /**
     * Get AI service status
     * GET /api/ai/status
     */
    @GetMapping("/ai/status")
    public ResponseEntity<AIStatusResponse> getAIStatus() {
        // Simple implementation - check if AI service key is configured
        boolean available = System.getenv("ANTHROPIC_API_KEY") != null &&
                           !System.getenv("ANTHROPIC_API_KEY").equals("your-anthropic-api-key-here");

        AIStatusResponse status = new AIStatusResponse(available,
            available ? "AI Service Available" : "AI Service Not Configured");
        return ResponseEntity.ok(status);
    }

    /**
     * Get comprehensive system statistics
     * GET /api/system/stats
     */
    @GetMapping("/system/stats")
    public ResponseEntity<SystemStatsResponse> getSystemStats() {
        long activeTeams = teamService.getActiveTeamsCount();
        long totalTeams = activeTeams; // For now, use active count as total
        long activeProjects = projectService.getActiveProjectsCount();
        long totalProjects = activeProjects; // For now, use active count as total
        long totalSubmissions = submissionService.searchSubmissions(null).size();
        long activePrompts = promptService.getActivePromptCount();
        long totalPrompts = promptService.getAllPrompts().size();

        SystemStatsResponse stats = new SystemStatsResponse(
            totalTeams, activeTeams, totalProjects, activeProjects,
            totalSubmissions, totalPrompts, activePrompts);

        return ResponseEntity.ok(stats);
    }

    /**
     * Get prompts count for dashboard compatibility
     * GET /api/prompts/count
     */
    @GetMapping("/prompts/count")
    public ResponseEntity<Long> getPromptsCount() {
        long count = promptService.getActivePromptCount();
        return ResponseEntity.ok(count);
    }

    /**
     * Health response class
     */
    public static class HealthResponse {
        private String status;
        private LocalDateTime timestamp;

        public HealthResponse(String status, LocalDateTime timestamp) {
            this.status = status;
            this.timestamp = timestamp;
        }

        public String getStatus() {
            return status;
        }

        public void setStatus(String status) {
            this.status = status;
        }

        public LocalDateTime getTimestamp() {
            return timestamp;
        }

        public void setTimestamp(LocalDateTime timestamp) {
            this.timestamp = timestamp;
        }
    }

    /**
     * Activity item class
     */
    public static class ActivityItem {
        private Long id;
        private String type;
        private String icon;
        private String title;
        private String description;
        private LocalDateTime timestamp;

        public ActivityItem() {}

        public ActivityItem(Long id, String type, String icon, String title, String description, LocalDateTime timestamp) {
            this.id = id;
            this.type = type;
            this.icon = icon;
            this.title = title;
            this.description = description;
            this.timestamp = timestamp;
        }

        // Getters and setters
        public Long getId() {
            return id;
        }

        public void setId(Long id) {
            this.id = id;
        }

        public String getType() {
            return type;
        }

        public void setType(String type) {
            this.type = type;
        }

        public String getIcon() {
            return icon;
        }

        public void setIcon(String icon) {
            this.icon = icon;
        }

        public String getTitle() {
            return title;
        }

        public void setTitle(String title) {
            this.title = title;
        }

        public String getDescription() {
            return description;
        }

        public void setDescription(String description) {
            this.description = description;
        }

        public LocalDateTime getTimestamp() {
            return timestamp;
        }

        public void setTimestamp(LocalDateTime timestamp) {
            this.timestamp = timestamp;
        }
    }

    /**
     * AI status response class
     */
    public static class AIStatusResponse {
        private boolean available;
        private String message;

        public AIStatusResponse(boolean available, String message) {
            this.available = available;
            this.message = message;
        }

        public boolean isAvailable() {
            return available;
        }

        public void setAvailable(boolean available) {
            this.available = available;
        }

        public String getMessage() {
            return message;
        }

        public void setMessage(String message) {
            this.message = message;
        }
    }

    /**
     * System statistics response class
     */
    public static class SystemStatsResponse {
        private long totalTeams;
        private long activeTeams;
        private long totalProjects;
        private long activeProjects;
        private long totalSubmissions;
        private long totalPrompts;
        private long activePrompts;

        public SystemStatsResponse(long totalTeams, long activeTeams, long totalProjects,
                                 long activeProjects, long totalSubmissions,
                                 long totalPrompts, long activePrompts) {
            this.totalTeams = totalTeams;
            this.activeTeams = activeTeams;
            this.totalProjects = totalProjects;
            this.activeProjects = activeProjects;
            this.totalSubmissions = totalSubmissions;
            this.totalPrompts = totalPrompts;
            this.activePrompts = activePrompts;
        }

        // Getters and setters
        public long getTotalTeams() {
            return totalTeams;
        }

        public void setTotalTeams(long totalTeams) {
            this.totalTeams = totalTeams;
        }

        public long getActiveTeams() {
            return activeTeams;
        }

        public void setActiveTeams(long activeTeams) {
            this.activeTeams = activeTeams;
        }

        public long getTotalProjects() {
            return totalProjects;
        }

        public void setTotalProjects(long totalProjects) {
            this.totalProjects = totalProjects;
        }

        public long getActiveProjects() {
            return activeProjects;
        }

        public void setActiveProjects(long activeProjects) {
            this.activeProjects = activeProjects;
        }

        public long getTotalSubmissions() {
            return totalSubmissions;
        }

        public void setTotalSubmissions(long totalSubmissions) {
            this.totalSubmissions = totalSubmissions;
        }

        public long getTotalPrompts() {
            return totalPrompts;
        }

        public void setTotalPrompts(long totalPrompts) {
            this.totalPrompts = totalPrompts;
        }

        public long getActivePrompts() {
            return activePrompts;
        }

        public void setActivePrompts(long activePrompts) {
            this.activePrompts = activePrompts;
        }
    }
}
--------
package com.codereview.manager.controller;

import com.codereview.manager.model.Team;
import com.codereview.manager.service.TeamService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import jakarta.validation.Valid;
import java.util.List;
import java.util.Optional;

/**
 * REST Controller for Team operations
 * Provides HTTP endpoints for managing development teams
 */
@RestController
@RequestMapping("/teams")
@CrossOrigin(origins = "*")
public class TeamController {

    private final TeamService teamService;

    @Autowired
    public TeamController(TeamService teamService) {
        this.teamService = teamService;
    }

    /**
     * Get all active teams
     * GET /api/teams
     */
    @GetMapping
    public ResponseEntity<List<Team>> getAllActiveTeams() {
        List<Team> teams = teamService.getAllActiveTeams();
        return ResponseEntity.ok(teams);
    }

    /**
     * Get all teams (including inactive)
     * GET /api/teams/all
     */
    @GetMapping("/all")
    public ResponseEntity<List<Team>> getAllTeams() {
        List<Team> teams = teamService.getAllActiveTeams(); // For now, return active teams only
        return ResponseEntity.ok(teams);
    }

    /**
     * Get a team by ID
     * GET /api/teams/{id}
     */
    @GetMapping("/{id}")
    public ResponseEntity<Team> getTeamById(@PathVariable Long id) {
        Optional<Team> team = teamService.getTeamById(id);

        if (team.isPresent()) {
            return ResponseEntity.ok(team.get());
        } else {
            return ResponseEntity.notFound().build();
        }
    }

    /**
     * Create a new team
     * POST /api/teams
     */
    @PostMapping
    public ResponseEntity<?> createTeam(@Valid @RequestBody Team team) {
        try {
            Team createdTeam = teamService.createTeam(team);
            return ResponseEntity.status(HttpStatus.CREATED).body(createdTeam);
        } catch (IllegalArgumentException e) {
            return ResponseEntity.badRequest().body(new ErrorResponse(e.getMessage()));
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(new ErrorResponse("Failed to create team: " + e.getMessage()));
        }
    }

    /**
     * Update an existing team
     * PUT /api/teams/{id}
     */
    @PutMapping("/{id}")
    public ResponseEntity<?> updateTeam(@PathVariable Long id, @Valid @RequestBody Team team) {
        try {
            Team updatedTeam = teamService.updateTeam(id, team);
            return ResponseEntity.ok(updatedTeam);
        } catch (IllegalArgumentException e) {
            return ResponseEntity.badRequest().body(new ErrorResponse(e.getMessage()));
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(new ErrorResponse("Failed to update team: " + e.getMessage()));
        }
    }

    /**
     * Delete a team
     * DELETE /api/teams/{id}
     */
    @DeleteMapping("/{id}")
    public ResponseEntity<?> deleteTeam(@PathVariable Long id) {
        try {
            teamService.deleteTeam(id);
            return ResponseEntity.ok(new SuccessResponse("Team deleted successfully"));
        } catch (IllegalArgumentException e) {
            return ResponseEntity.badRequest().body(new ErrorResponse(e.getMessage()));
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(new ErrorResponse("Failed to delete team: " + e.getMessage()));
        }
    }

    /**
     * Activate or deactivate a team
     * PATCH /api/teams/{id}/status
     */
    @PatchMapping("/{id}/status")
    public ResponseEntity<?> setTeamStatus(@PathVariable Long id, @RequestBody StatusRequest statusRequest) {
        try {
            Team team = teamService.getTeamById(id)
                    .orElseThrow(() -> new IllegalArgumentException("Team not found with ID: " + id));
            team.setActive(statusRequest.isActive());
            Team updatedTeam = teamService.updateTeam(id, team);
            return ResponseEntity.ok(updatedTeam);
        } catch (IllegalArgumentException e) {
            return ResponseEntity.badRequest().body(new ErrorResponse(e.getMessage()));
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(new ErrorResponse("Failed to update team status: " + e.getMessage()));
        }
    }

    /**
     * Search teams by name or description
     * GET /api/teams/search?q={searchText}
     */
    @GetMapping("/search")
    public ResponseEntity<List<Team>> searchTeams(@RequestParam(value = "q", required = false) String searchText) {
        List<Team> teams = teamService.searchTeams(searchText);
        return ResponseEntity.ok(teams);
    }

    /**
     * Get team statistics
     * GET /api/teams/stats
     */
    @GetMapping("/stats")
    public ResponseEntity<StatsResponse> getTeamStats() {
        long activeCount = teamService.getActiveTeamsCount();
        long totalCount = activeCount; // For now, use active count as total
        StatsResponse stats = new StatsResponse(totalCount, activeCount);
        return ResponseEntity.ok(stats);
    }

    /**
     * Request class for status updates
     */
    public static class StatusRequest {
        private boolean active;

        public boolean isActive() {
            return active;
        }

        public void setActive(boolean active) {
            this.active = active;
        }
    }

    /**
     * Response class for statistics
     */
    public static class StatsResponse {
        private long count;
        private long totalCount;
        private long activeCount;

        public StatsResponse(long totalCount, long activeCount) {
            this.totalCount = totalCount;
            this.activeCount = activeCount;
            this.count = totalCount; // For backward compatibility
        }

        public long getCount() {
            return count;
        }

        public void setCount(long count) {
            this.count = count;
        }

        public long getTotalCount() {
            return totalCount;
        }

        public void setTotalCount(long totalCount) {
            this.totalCount = totalCount;
        }

        public long getActiveCount() {
            return activeCount;
        }

        public void setActiveCount(long activeCount) {
            this.activeCount = activeCount;
        }
    }

    /**
     * Simple response class for success messages
     */
    public static class SuccessResponse {
        private String message;

        public SuccessResponse(String message) {
            this.message = message;
        }

        public String getMessage() {
            return message;
        }

        public void setMessage(String message) {
            this.message = message;
        }
    }

    /**
     * Simple response class for error messages
     */
    public static class ErrorResponse {
        private String error;

        public ErrorResponse(String error) {
            this.error = error;
        }

        public String getError() {
            return error;
        }

        public void setError(String error) {
            this.error = error;
        }
    }
}
--------------------
package com.codereview.manager.model;

import jakarta.persistence.*;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import com.fasterxml.jackson.annotation.JsonIgnore;
import java.time.LocalDateTime;
import java.util.List;

/**
 * Entity representing a category for organizing prompts
 * Categories help group related prompts together (e.g., "Code Review", "Best Practices", etc.)
 */
@Entity
@Table(name = "categories")
public class Category {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @NotBlank(message = "Category name is required")
    @Size(max = 100, message = "Category name must not exceed 100 characters")
    @Column(name = "name", nullable = false, unique = true)
    private String name;

    @Size(max = 500, message = "Description must not exceed 500 characters")
    @Column(name = "description")
    private String description;

    @Column(name = "created_at", updatable = false)
    private LocalDateTime createdAt;

    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

    // One category can have many prompts
    @OneToMany(mappedBy = "category", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    @JsonIgnore // Prevent circular reference during JSON serialization
    private List<Prompt> prompts;

    // Default constructor (required by JPA)
    public Category() {
    }

    // Constructor with name and description
    public Category(String name, String description) {
        this.name = name;
        this.description = description;
    }

    // Automatically set timestamps before persisting
    @PrePersist
    protected void onCreate() {
        this.createdAt = LocalDateTime.now();
        this.updatedAt = LocalDateTime.now();
    }

    // Automatically update timestamp before updating
    @PreUpdate
    protected void onUpdate() {
        this.updatedAt = LocalDateTime.now();
    }

    // Getters and setters
    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    public LocalDateTime getCreatedAt() {
        return createdAt;
    }

    public void setCreatedAt(LocalDateTime createdAt) {
        this.createdAt = createdAt;
    }

    public LocalDateTime getUpdatedAt() {
        return updatedAt;
    }

    public void setUpdatedAt(LocalDateTime updatedAt) {
        this.updatedAt = updatedAt;
    }

    public List<Prompt> getPrompts() {
        return prompts;
    }

    public void setPrompts(List<Prompt> prompts) {
        this.prompts = prompts;
    }

    @Override
    public String toString() {
        return "Category{" +
                "id=" + id +
                ", name='" + name + '\'' +
                ", description='" + description + '\'' +
                ", createdAt=" + createdAt +
                ", updatedAt=" + updatedAt +
                '}';
    }
}
--------------------------
package com.codereview.manager.model;

import com.fasterxml.jackson.annotation.JsonBackReference;
import jakarta.persistence.*;
import java.time.LocalDateTime;
import java.util.UUID;

/**
 * CodeReviewSubmission entity for tracking code submissions and reviews
 */
@Entity
@Table(name = "code_review_submissions")
public class CodeReviewSubmission {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "review_id", unique = true, nullable = false)
    private String reviewId;

    @Column(name = "commit_hash", nullable = false)
    private String commitHash;

    @Column(name = "submitter_email", nullable = false)
    private String submitterEmail;

    @Column(name = "submitter_name")
    private String submitterName;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "project_id", nullable = false)
    @JsonBackReference
    private Project project;

    @Column(name = "code_content", columnDefinition = "LONGTEXT")
    private String codeContent;

    @Column(name = "file_path")
    private String filePath;

    @Column(name = "programming_language")
    private String programmingLanguage;

    @Column(name = "review_status")
    @Enumerated(EnumType.STRING)
    private ReviewStatus reviewStatus = ReviewStatus.PENDING;

    @Column(name = "review_report", columnDefinition = "LONGTEXT")
    private String reviewReport;

    @Column(name = "priority")
    @Enumerated(EnumType.STRING)
    private Priority priority = Priority.MEDIUM;

    @Column(name = "submitted_date")
    private LocalDateTime submittedDate;

    @Column(name = "review_started_date")
    private LocalDateTime reviewStartedDate;

    @Column(name = "review_completed_date")
    private LocalDateTime reviewCompletedDate;

    @Column(name = "notification_sent")
    private Boolean notificationSent = false;

    @Column(name = "created_date")
    private LocalDateTime createdDate;

    @Column(name = "last_modified")
    private LocalDateTime lastModified;

    // Enums
    public enum ReviewStatus {
        PENDING("Pending Review"),
        IN_PROGRESS("Review In Progress"),
        COMPLETED("Review Completed"),
        FAILED("Review Failed"),
        CANCELLED("Review Cancelled");

        private final String displayName;

        ReviewStatus(String displayName) {
            this.displayName = displayName;
        }

        public String getDisplayName() {
            return displayName;
        }
    }

    public enum Priority {
        LOW("Low"),
        MEDIUM("Medium"),
        HIGH("High"),
        URGENT("Urgent");

        private final String displayName;

        Priority(String displayName) {
            this.displayName = displayName;
        }

        public String getDisplayName() {
            return displayName;
        }
    }

    // Default constructor
    public CodeReviewSubmission() {
        this.reviewId = generateReviewId();
        this.submittedDate = LocalDateTime.now();
        this.createdDate = LocalDateTime.now();
        this.lastModified = LocalDateTime.now();
    }

    // Constructor with required fields
    public CodeReviewSubmission(String commitHash, String submitterEmail, Project project, String codeContent) {
        this();
        this.commitHash = commitHash;
        this.submitterEmail = submitterEmail;
        this.project = project;
        this.codeContent = codeContent;
    }

    // Generate unique review ID based on team, project, and commit
    private String generateReviewId() {
        return "REV-" + UUID.randomUUID().toString().substring(0, 8).toUpperCase();
    }

    // Generate review ID with team and project context
    public void generateContextualReviewId() {
        if (project != null && project.getTeam() != null) {
            String teamPrefix = project.getTeam().getName().replaceAll("[^A-Za-z0-9]", "").substring(0,
                Math.min(3, project.getTeam().getName().length())).toUpperCase();
            String projectPrefix = project.getName().replaceAll("[^A-Za-z0-9]", "").substring(0,
                Math.min(3, project.getName().length())).toUpperCase();
            String commitPrefix = commitHash != null ? commitHash.substring(0, Math.min(8, commitHash.length())) :
                UUID.randomUUID().toString().substring(0, 8);

            this.reviewId = String.format("REV-%s-%s-%s", teamPrefix, projectPrefix, commitPrefix).toUpperCase();
        }
    }

    // Getters and Setters
    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getReviewId() {
        return reviewId;
    }

    public void setReviewId(String reviewId) {
        this.reviewId = reviewId;
        this.lastModified = LocalDateTime.now();
    }

    public String getCommitHash() {
        return commitHash;
    }

    public void setCommitHash(String commitHash) {
        this.commitHash = commitHash;
        this.lastModified = LocalDateTime.now();
    }

    public String getSubmitterEmail() {
        return submitterEmail;
    }

    public void setSubmitterEmail(String submitterEmail) {
        this.submitterEmail = submitterEmail;
        this.lastModified = LocalDateTime.now();
    }

    public String getSubmitterName() {
        return submitterName;
    }

    public void setSubmitterName(String submitterName) {
        this.submitterName = submitterName;
        this.lastModified = LocalDateTime.now();
    }

    public Project getProject() {
        return project;
    }

    public void setProject(Project project) {
        this.project = project;
        this.lastModified = LocalDateTime.now();
    }

    public String getCodeContent() {
        return codeContent;
    }

    public void setCodeContent(String codeContent) {
        this.codeContent = codeContent;
        this.lastModified = LocalDateTime.now();
    }

    public String getFilePath() {
        return filePath;
    }

    public void setFilePath(String filePath) {
        this.filePath = filePath;
        this.lastModified = LocalDateTime.now();
    }

    public String getProgrammingLanguage() {
        return programmingLanguage;
    }

    public void setProgrammingLanguage(String programmingLanguage) {
        this.programmingLanguage = programmingLanguage;
        this.lastModified = LocalDateTime.now();
    }

    public ReviewStatus getReviewStatus() {
        return reviewStatus;
    }

    public void setReviewStatus(ReviewStatus reviewStatus) {
        this.reviewStatus = reviewStatus;
        this.lastModified = LocalDateTime.now();

        // Update timestamps based on status
        if (reviewStatus == ReviewStatus.IN_PROGRESS && reviewStartedDate == null) {
            this.reviewStartedDate = LocalDateTime.now();
        } else if (reviewStatus == ReviewStatus.COMPLETED && reviewCompletedDate == null) {
            this.reviewCompletedDate = LocalDateTime.now();
        }
    }

    public String getReviewReport() {
        return reviewReport;
    }

    public void setReviewReport(String reviewReport) {
        this.reviewReport = reviewReport;
        this.lastModified = LocalDateTime.now();
    }

    public Priority getPriority() {
        return priority;
    }

    public void setPriority(Priority priority) {
        this.priority = priority;
        this.lastModified = LocalDateTime.now();
    }

    public LocalDateTime getSubmittedDate() {
        return submittedDate;
    }

    public void setSubmittedDate(LocalDateTime submittedDate) {
        this.submittedDate = submittedDate;
    }

    public LocalDateTime getReviewStartedDate() {
        return reviewStartedDate;
    }

    public void setReviewStartedDate(LocalDateTime reviewStartedDate) {
        this.reviewStartedDate = reviewStartedDate;
    }

    public LocalDateTime getReviewCompletedDate() {
        return reviewCompletedDate;
    }

    public void setReviewCompletedDate(LocalDateTime reviewCompletedDate) {
        this.reviewCompletedDate = reviewCompletedDate;
    }

    public Boolean getNotificationSent() {
        return notificationSent;
    }

    public void setNotificationSent(Boolean notificationSent) {
        this.notificationSent = notificationSent;
        this.lastModified = LocalDateTime.now();
    }

    public LocalDateTime getCreatedDate() {
        return createdDate;
    }

    public void setCreatedDate(LocalDateTime createdDate) {
        this.createdDate = createdDate;
    }

    public LocalDateTime getLastModified() {
        return lastModified;
    }

    public void setLastModified(LocalDateTime lastModified) {
        this.lastModified = lastModified;
    }

    @Override
    public String toString() {
        return "CodeReviewSubmission{" +
                "id=" + id +
                ", reviewId='" + reviewId + '\'' +
                ", commitHash='" + commitHash + '\'' +
                ", submitterEmail='" + submitterEmail + '\'' +
                ", reviewStatus=" + reviewStatus +
                ", priority=" + priority +
                ", submittedDate=" + submittedDate +
                '}';
    }
}
-------------------------------------
package com.codereview.manager.model;

import com.fasterxml.jackson.annotation.JsonBackReference;
import com.fasterxml.jackson.annotation.JsonManagedReference;
import jakarta.persistence.*;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

/**
 * Project entity representing projects within teams
 */
@Entity
@Table(name = "projects")
public class Project {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "name", nullable = false)
    private String name;

    @Column(name = "description", length = 1000)
    private String description;

    @Column(name = "repository_url")
    private String repositoryUrl;

    @Column(name = "branch_name")
    private String branchName = "main";

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "team_id", nullable = false)
    @JsonBackReference
    private Team team;

    @Column(name = "active")
    private Boolean active = true;

    @Column(name = "created_date")
    private LocalDateTime createdDate;

    @Column(name = "last_modified")
    private LocalDateTime lastModified;

    @OneToMany(mappedBy = "project", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    @JsonManagedReference
    private List<CodeReviewSubmission> submissions = new ArrayList<>();

    // Default constructor
    public Project() {
        this.createdDate = LocalDateTime.now();
        this.lastModified = LocalDateTime.now();
    }

    // Constructor with required fields
    public Project(String name, String description, Team team) {
        this();
        this.name = name;
        this.description = description;
        this.team = team;
    }

    // Getters and Setters
    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
        this.lastModified = LocalDateTime.now();
    }

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
        this.lastModified = LocalDateTime.now();
    }

    public String getRepositoryUrl() {
        return repositoryUrl;
    }

    public void setRepositoryUrl(String repositoryUrl) {
        this.repositoryUrl = repositoryUrl;
        this.lastModified = LocalDateTime.now();
    }

    public String getBranchName() {
        return branchName;
    }

    public void setBranchName(String branchName) {
        this.branchName = branchName;
        this.lastModified = LocalDateTime.now();
    }

    public Team getTeam() {
        return team;
    }

    public void setTeam(Team team) {
        this.team = team;
        this.lastModified = LocalDateTime.now();
    }

    public Boolean getActive() {
        return active;
    }

    public void setActive(Boolean active) {
        this.active = active;
        this.lastModified = LocalDateTime.now();
    }

    public LocalDateTime getCreatedDate() {
        return createdDate;
    }

    public void setCreatedDate(LocalDateTime createdDate) {
        this.createdDate = createdDate;
    }

    public LocalDateTime getLastModified() {
        return lastModified;
    }

    public void setLastModified(LocalDateTime lastModified) {
        this.lastModified = lastModified;
    }

    public List<CodeReviewSubmission> getSubmissions() {
        return submissions;
    }

    public void setSubmissions(List<CodeReviewSubmission> submissions) {
        this.submissions = submissions;
    }

    // Helper methods
    public void addSubmission(CodeReviewSubmission submission) {
        submissions.add(submission);
        submission.setProject(this);
    }

    public void removeSubmission(CodeReviewSubmission submission) {
        submissions.remove(submission);
        submission.setProject(null);
    }

    @Override
    public String toString() {
        return "Project{" +
                "id=" + id +
                ", name='" + name + '\'' +
                ", description='" + description + '\'' +
                ", repositoryUrl='" + repositoryUrl + '\'' +
                ", branchName='" + branchName + '\'' +
                ", active=" + active +
                ", createdDate=" + createdDate +
                '}';
    }
}
------------------
package com.codereview.manager.model;

import jakarta.persistence.*;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import java.time.LocalDateTime;

/**
 * Entity representing a prompt for code review or best practices
 * This stores the actual prompt content that will be used by code experts and architects
 */
@Entity
@Table(name = "prompts")
public class Prompt {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @NotBlank(message = "Prompt title is required")
    @Size(max = 200, message = "Title must not exceed 200 characters")
    @Column(name = "title", nullable = false)
    private String title;

    @NotBlank(message = "Prompt content is required")
    @Size(max = 5000, message = "Content must not exceed 5000 characters")
    @Column(name = "content", nullable = false, columnDefinition = "TEXT")
    private String content;

    @Size(max = 1000, message = "Description must not exceed 1000 characters")
    @Column(name = "description")
    private String description;

    // Many prompts can belong to one category
    @ManyToOne(fetch = FetchType.EAGER)
    @JoinColumn(name = "category_id", nullable = false)
    private Category category;

    @Column(name = "is_active", nullable = false)
    private Boolean isActive = true;

    @Size(max = 100, message = "Created by field must not exceed 100 characters")
    @Column(name = "created_by")
    private String createdBy;

    @Size(max = 100, message = "Updated by field must not exceed 100 characters")
    @Column(name = "updated_by")
    private String updatedBy;

    @Column(name = "created_at", updatable = false)
    private LocalDateTime createdAt;

    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

    // Default constructor (required by JPA)
    public Prompt() {
    }

    // Constructor with essential fields
    public Prompt(String title, String content, String description, Category category) {
        this.title = title;
        this.content = content;
        this.description = description;
        this.category = category;
        this.isActive = true;
    }

    // Automatically set timestamps before persisting
    @PrePersist
    protected void onCreate() {
        this.createdAt = LocalDateTime.now();
        this.updatedAt = LocalDateTime.now();
    }

    // Automatically update timestamp before updating
    @PreUpdate
    protected void onUpdate() {
        this.updatedAt = LocalDateTime.now();
    }

    // Getters and setters
    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public String getContent() {
        return content;
    }

    public void setContent(String content) {
        this.content = content;
    }

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    public Category getCategory() {
        return category;
    }

    public void setCategory(Category category) {
        this.category = category;
    }

    public Boolean getIsActive() {
        return isActive;
    }

    public void setIsActive(Boolean isActive) {
        this.isActive = isActive;
    }

    public String getCreatedBy() {
        return createdBy;
    }

    public void setCreatedBy(String createdBy) {
        this.createdBy = createdBy;
    }

    public String getUpdatedBy() {
        return updatedBy;
    }

    public void setUpdatedBy(String updatedBy) {
        this.updatedBy = updatedBy;
    }

    public LocalDateTime getCreatedAt() {
        return createdAt;
    }

    public void setCreatedAt(LocalDateTime createdAt) {
        this.createdAt = createdAt;
    }

    public LocalDateTime getUpdatedAt() {
        return updatedAt;
    }

    public void setUpdatedAt(LocalDateTime updatedAt) {
        this.updatedAt = updatedAt;
    }

    @Override
    public String toString() {
        return "Prompt{" +
                "id=" + id +
                ", title='" + title + '\'' +
                ", description='" + description + '\'' +
                ", categoryId=" + (category != null ? category.getId() : null) +
                ", isActive=" + isActive +
                ", createdBy='" + createdBy + '\'' +
                ", createdAt=" + createdAt +
                '}';
    }
}
----------------
package com.codereview.manager.model;

import com.fasterxml.jackson.annotation.JsonManagedReference;
import jakarta.persistence.*;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

/**
 * Team entity representing development teams
 */
@Entity
@Table(name = "teams")
public class Team {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "name", nullable = false, unique = true)
    private String name;

    @Column(name = "description", length = 1000)
    private String description;

    @Column(name = "team_lead_email")
    private String teamLeadEmail;

    @Column(name = "notification_emails", length = 2000)
    private String notificationEmails; // Comma-separated list

    @Column(name = "active")
    private Boolean active = true;

    @Column(name = "created_date")
    private LocalDateTime createdDate;

    @Column(name = "last_modified")
    private LocalDateTime lastModified;

    @OneToMany(mappedBy = "team", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    @JsonManagedReference
    private List<Project> projects = new ArrayList<>();

    // Default constructor
    public Team() {
        this.createdDate = LocalDateTime.now();
        this.lastModified = LocalDateTime.now();
    }

    // Constructor with required fields
    public Team(String name, String description) {
        this();
        this.name = name;
        this.description = description;
    }

    // Getters and Setters
    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
        this.lastModified = LocalDateTime.now();
    }

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
        this.lastModified = LocalDateTime.now();
    }

    public String getTeamLeadEmail() {
        return teamLeadEmail;
    }

    public void setTeamLeadEmail(String teamLeadEmail) {
        this.teamLeadEmail = teamLeadEmail;
        this.lastModified = LocalDateTime.now();
    }

    public String getNotificationEmails() {
        return notificationEmails;
    }

    public void setNotificationEmails(String notificationEmails) {
        this.notificationEmails = notificationEmails;
        this.lastModified = LocalDateTime.now();
    }

    public Boolean getActive() {
        return active;
    }

    public void setActive(Boolean active) {
        this.active = active;
        this.lastModified = LocalDateTime.now();
    }

    public LocalDateTime getCreatedDate() {
        return createdDate;
    }

    public void setCreatedDate(LocalDateTime createdDate) {
        this.createdDate = createdDate;
    }

    public LocalDateTime getLastModified() {
        return lastModified;
    }

    public void setLastModified(LocalDateTime lastModified) {
        this.lastModified = lastModified;
    }

    public List<Project> getProjects() {
        return projects;
    }

    public void setProjects(List<Project> projects) {
        this.projects = projects;
    }

    // Helper methods
    public void addProject(Project project) {
        projects.add(project);
        project.setTeam(this);
    }

    public void removeProject(Project project) {
        projects.remove(project);
        project.setTeam(null);
    }

    // Get notification emails as list
    public List<String> getNotificationEmailsList() {
        List<String> emails = new ArrayList<>();
        if (notificationEmails != null && !notificationEmails.trim().isEmpty()) {
            String[] emailArray = notificationEmails.split(",");
            for (String email : emailArray) {
                String trimmedEmail = email.trim();
                if (!trimmedEmail.isEmpty()) {
                    emails.add(trimmedEmail);
                }
            }
        }
        return emails;
    }

    @Override
    public String toString() {
        return "Team{" +
                "id=" + id +
                ", name='" + name + '\'' +
                ", description='" + description + '\'' +
                ", teamLeadEmail='" + teamLeadEmail + '\'' +
                ", active=" + active +
                ", createdDate=" + createdDate +
                '}';
    }
}
--------------------
package com.codereview.manager.repository;

import com.codereview.manager.model.Category;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

/**
 * Repository interface for Category entity
 * Provides data access methods for managing categories
 */
@Repository
public interface CategoryRepository extends JpaRepository<Category, Long> {

    /**
     * Find a category by its name (case-insensitive)
     * @param name the category name
     * @return Optional containing the category if found
     */
    Optional<Category> findByNameIgnoreCase(String name);

    /**
     * Check if a category exists with the given name (case-insensitive)
     * @param name the category name
     * @return true if category exists, false otherwise
     */
    boolean existsByNameIgnoreCase(String name);

    /**
     * Find all categories ordered by name
     * @return list of categories ordered by name
     */
    List<Category> findAllByOrderByName();

    /**
     * Find categories containing the specified text in name or description
     * @param searchText the text to search for
     * @return list of matching categories
     */
    @Query("SELECT c FROM Category c WHERE " +
           "LOWER(c.name) LIKE LOWER(CONCAT('%', :searchText, '%')) OR " +
           "LOWER(c.description) LIKE LOWER(CONCAT('%', :searchText, '%'))")
    List<Category> findByNameOrDescriptionContainingIgnoreCase(String searchText);
}
----------------------------
package com.codereview.manager.repository;

import com.codereview.manager.model.CodeReviewSubmission;
import com.codereview.manager.model.Project;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

/**
 * Repository interface for CodeReviewSubmission entity
 */
@Repository
public interface CodeReviewSubmissionRepository extends JpaRepository<CodeReviewSubmission, Long> {

    /**
     * Find submission by review ID
     */
    Optional<CodeReviewSubmission> findByReviewId(String reviewId);

    /**
     * Find submissions by project
     */
    List<CodeReviewSubmission> findByProject(Project project);

    /**
     * Find submissions by project and status
     */
    List<CodeReviewSubmission> findByProjectAndReviewStatus(Project project, CodeReviewSubmission.ReviewStatus status);

    /**
     * Find submissions by submitter email
     */
    List<CodeReviewSubmission> findBySubmitterEmailOrderBySubmittedDateDesc(String submitterEmail);

    /**
     * Find submissions by status
     */
    List<CodeReviewSubmission> findByReviewStatusOrderBySubmittedDateDesc(CodeReviewSubmission.ReviewStatus status);

    /**
     * Find submissions by team (through project)
     */
    @Query("SELECT s FROM CodeReviewSubmission s WHERE s.project.team.id = :teamId ORDER BY s.submittedDate DESC")
    List<CodeReviewSubmission> findByTeamId(@Param("teamId") Long teamId);

    /**
     * Find pending submissions for notification
     */
    List<CodeReviewSubmission> findByNotificationSentFalseAndReviewStatus(CodeReviewSubmission.ReviewStatus status);

    /**
     * Find submissions by commit hash and project
     */
    List<CodeReviewSubmission> findByCommitHashAndProject(String commitHash, Project project);

    /**
     * Find submissions within date range
     */
    @Query("SELECT s FROM CodeReviewSubmission s WHERE s.submittedDate >= :startDate AND s.submittedDate <= :endDate ORDER BY s.submittedDate DESC")
    List<CodeReviewSubmission> findBySubmittedDateBetween(@Param("startDate") LocalDateTime startDate, @Param("endDate") LocalDateTime endDate);

    /**
     * Count submissions by status
     */
    long countByReviewStatus(CodeReviewSubmission.ReviewStatus status);

    /**
     * Count submissions by project
     */
    long countByProject(Project project);

    /**
     * Count submissions by team
     */
    @Query("SELECT COUNT(s) FROM CodeReviewSubmission s WHERE s.project.team.id = :teamId")
    long countByTeamId(@Param("teamId") Long teamId);

    /**
     * Find recent submissions (last 7 days)
     */
    @Query("SELECT s FROM CodeReviewSubmission s WHERE s.submittedDate >= :sevenDaysAgo ORDER BY s.submittedDate DESC")
    List<CodeReviewSubmission> findRecentSubmissions(@Param("sevenDaysAgo") LocalDateTime sevenDaysAgo);

    /**
     * Find submissions by priority
     */
    List<CodeReviewSubmission> findByPriorityOrderBySubmittedDateDesc(CodeReviewSubmission.Priority priority);

    /**
     * Find high priority pending submissions
     */
    @Query("SELECT s FROM CodeReviewSubmission s WHERE s.priority IN :priorities AND s.reviewStatus = :status ORDER BY s.priority DESC, s.submittedDate ASC")
    List<CodeReviewSubmission> findHighPriorityPendingSubmissions(
        @Param("priorities") List<CodeReviewSubmission.Priority> priorities,
        @Param("status") CodeReviewSubmission.ReviewStatus status
    );

    /**
     * Search submissions
     */
    @Query("SELECT s FROM CodeReviewSubmission s WHERE " +
           "LOWER(s.reviewId) LIKE LOWER(CONCAT('%', :searchTerm, '%')) OR " +
           "LOWER(s.submitterEmail) LIKE LOWER(CONCAT('%', :searchTerm, '%')) OR " +
           "LOWER(s.submitterName) LIKE LOWER(CONCAT('%', :searchTerm, '%')) OR " +
           "LOWER(s.commitHash) LIKE LOWER(CONCAT('%', :searchTerm, '%'))")
    List<CodeReviewSubmission> searchSubmissions(@Param("searchTerm") String searchTerm);

    /**
     * Get submission statistics
     */
    @Query("SELECT s.reviewStatus, COUNT(s) FROM CodeReviewSubmission s GROUP BY s.reviewStatus")
    List<Object[]> getSubmissionStatistics();

    /**
     * Get team submission statistics
     */
    @Query("SELECT t.name, COUNT(s) FROM Team t LEFT JOIN t.projects p LEFT JOIN p.submissions s GROUP BY t.name ORDER BY COUNT(s) DESC")
    List<Object[]> getTeamSubmissionStatistics();
}
--------------------------------------
package com.codereview.manager.repository;

import com.codereview.manager.model.Project;
import com.codereview.manager.model.Team;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

/**
 * Repository interface for Project entity
 */
@Repository
public interface ProjectRepository extends JpaRepository<Project, Long> {

    /**
     * Find project by name
     */
    Optional<Project> findByName(String name);

    /**
     * Find project by name and team
     */
    Optional<Project> findByNameAndTeam(String name, Team team);

    /**
     * Find all active projects
     */
    List<Project> findByActiveTrue();

    /**
     * Find active projects by team
     */
    List<Project> findByTeamAndActiveTrue(Team team);

    /**
     * Find projects by team ID
     */
    List<Project> findByTeamIdAndActiveTrue(Long teamId);

    /**
     * Find projects by name containing search term
     */
    List<Project> findByNameContainingIgnoreCaseAndActiveTrue(String searchTerm);

    /**
     * Check if project name exists within team
     */
    boolean existsByNameAndTeam(String name, Team team);

    /**
     * Count active projects by team
     */
    @Query("SELECT COUNT(p) FROM Project p WHERE p.team = :team AND p.active = true")
    long countActiveProjectsByTeam(@Param("team") Team team);

    /**
     * Count all active projects
     */
    @Query("SELECT COUNT(p) FROM Project p WHERE p.active = true")
    long countActiveProjects();

    /**
     * Find projects with submission counts
     */
    @Query("SELECT p, COUNT(s) as submissionCount FROM Project p LEFT JOIN p.submissions s " +
           "WHERE p.active = true GROUP BY p ORDER BY submissionCount DESC")
    List<Object[]> findProjectsWithSubmissionCount();

    /**
     * Search projects by name or description
     */
    @Query("SELECT p FROM Project p WHERE p.active = true AND " +
           "(LOWER(p.name) LIKE LOWER(CONCAT('%', :searchTerm, '%')) OR " +
           "LOWER(p.description) LIKE LOWER(CONCAT('%', :searchTerm, '%')))")
    List<Project> searchProjects(@Param("searchTerm") String searchTerm);

    /**
     * Find projects by team and search term
     */
    @Query("SELECT p FROM Project p WHERE p.team.id = :teamId AND p.active = true AND " +
           "(LOWER(p.name) LIKE LOWER(CONCAT('%', :searchTerm, '%')) OR " +
           "LOWER(p.description) LIKE LOWER(CONCAT('%', :searchTerm, '%')))")
    List<Project> searchProjectsByTeam(@Param("teamId") Long teamId, @Param("searchTerm") String searchTerm);
}
-----------------
package com.codereview.manager.repository;

import com.codereview.manager.model.Prompt;
import com.codereview.manager.model.Category;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.stereotype.Repository;

import java.util.List;

/**
 * Repository interface for Prompt entity
 * Provides data access methods for managing prompts
 */
@Repository
public interface PromptRepository extends JpaRepository<Prompt, Long> {

    /**
     * Find all active prompts ordered by creation date (newest first)
     * @return list of active prompts
     */
    List<Prompt> findByIsActiveTrueOrderByCreatedAtDesc();

    /**
     * Find all prompts in a specific category
     * @param category the category to search in
     * @return list of prompts in the category
     */
    List<Prompt> findByCategoryOrderByCreatedAtDesc(Category category);

    /**
     * Find all active prompts in a specific category
     * @param category the category to search in
     * @return list of active prompts in the category
     */
    List<Prompt> findByCategoryAndIsActiveTrueOrderByCreatedAtDesc(Category category);

    /**
     * Find prompts by category ID
     * @param categoryId the category ID
     * @return list of prompts in the category
     */
    List<Prompt> findByCategoryIdOrderByCreatedAtDesc(Long categoryId);

    /**
     * Find active prompts by category ID
     * @param categoryId the category ID
     * @return list of active prompts in the category
     */
    List<Prompt> findByCategoryIdAndIsActiveTrueOrderByCreatedAtDesc(Long categoryId);

    /**
     * Search prompts by title or content (case-insensitive)
     * @param searchText the text to search for
     * @return list of matching prompts
     */
    @Query("SELECT p FROM Prompt p WHERE " +
           "p.isActive = true AND (" +
           "LOWER(p.title) LIKE LOWER(CONCAT('%', :searchText, '%')) OR " +
           "LOWER(p.content) LIKE LOWER(CONCAT('%', :searchText, '%')) OR " +
           "LOWER(p.description) LIKE LOWER(CONCAT('%', :searchText, '%'))" +
           ") ORDER BY p.createdAt DESC")
    List<Prompt> searchActivePrompts(String searchText);

    /**
     * Find all prompts ordered by creation date (newest first)
     * @return list of all prompts
     */
    List<Prompt> findAllByOrderByCreatedAtDesc();

    /**
     * Count active prompts
     * @return number of active prompts
     */
    long countByIsActiveTrue();

    /**
     * Count prompts in a specific category
     * @param category the category
     * @return number of prompts in the category
     */
    long countByCategory(Category category);
}
-----------------------------------
package com.codereview.manager.repository;

import com.codereview.manager.model.Team;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

/**
 * Repository interface for Team entity
 */
@Repository
public interface TeamRepository extends JpaRepository<Team, Long> {

    /**
     * Find team by name (case-insensitive)
     */
    Optional<Team> findByNameIgnoreCase(String name);

    /**
     * Find all active teams
     */
    List<Team> findByActiveTrue();

    /**
     * Find teams by name containing search term (case-insensitive)
     */
    List<Team> findByNameContainingIgnoreCaseAndActiveTrue(String searchTerm);

    /**
     * Find teams by team lead email
     */
    List<Team> findByTeamLeadEmailAndActiveTrue(String teamLeadEmail);

    /**
     * Check if team name exists (case-insensitive)
     */
    boolean existsByNameIgnoreCase(String name);

    /**
     * Count active teams
     */
    @Query("SELECT COUNT(t) FROM Team t WHERE t.active = true")
    long countActiveTeams();

    /**
     * Find teams with their projects count
     */
    @Query("SELECT t, COUNT(p) as projectCount FROM Team t LEFT JOIN t.projects p WHERE t.active = true GROUP BY t")
    List<Object[]> findTeamsWithProjectCount();

    /**
     * Search teams by name or description
     */
    @Query("SELECT t FROM Team t WHERE t.active = true AND " +
           "(LOWER(t.name) LIKE LOWER(CONCAT('%', :searchTerm, '%')) OR " +
           "LOWER(t.description) LIKE LOWER(CONCAT('%', :searchTerm, '%')))")
    List<Team> searchTeams(@Param("searchTerm") String searchTerm);
}
-------------------------------
package com.codereview.manager.service;

import com.codereview.manager.model.Category;
import com.codereview.manager.repository.CategoryRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Optional;

/**
 * Service class for managing Category operations
 * Contains business logic for category management
 */
@Service
public class CategoryService {

    private final CategoryRepository categoryRepository;

    @Autowired
    public CategoryService(CategoryRepository categoryRepository) {
        this.categoryRepository = categoryRepository;
    }

    /**
     * Get all categories ordered by name
     * @return list of all categories
     */
    public List<Category> getAllCategories() {
        return categoryRepository.findAllByOrderByName();
    }

    /**
     * Get a category by ID
     * @param id the category ID
     * @return Optional containing the category if found
     */
    public Optional<Category> getCategoryById(Long id) {
        return categoryRepository.findById(id);
    }

    /**
     * Get a category by name (case-insensitive)
     * @param name the category name
     * @return Optional containing the category if found
     */
    public Optional<Category> getCategoryByName(String name) {
        return categoryRepository.findByNameIgnoreCase(name);
    }

    /**
     * Create a new category
     * @param category the category to create
     * @return the created category
     * @throws IllegalArgumentException if category name already exists
     */
    public Category createCategory(Category category) {
        // Check if category name already exists
        if (categoryRepository.existsByNameIgnoreCase(category.getName())) {
            throw new IllegalArgumentException("Category with name '" + category.getName() + "' already exists");
        }

        return categoryRepository.save(category);
    }

    /**
     * Update an existing category
     * @param id the category ID
     * @param updatedCategory the updated category data
     * @return the updated category
     * @throws IllegalArgumentException if category not found or name conflicts
     */
    public Category updateCategory(Long id, Category updatedCategory) {
        Optional<Category> existingCategory = categoryRepository.findById(id);

        if (existingCategory.isEmpty()) {
            throw new IllegalArgumentException("Category with ID " + id + " not found");
        }

        Category category = existingCategory.get();

        // Check if new name conflicts with existing categories (excluding current one)
        Optional<Category> categoryWithSameName = categoryRepository.findByNameIgnoreCase(updatedCategory.getName());
        if (categoryWithSameName.isPresent() && !categoryWithSameName.get().getId().equals(id)) {
            throw new IllegalArgumentException("Category with name '" + updatedCategory.getName() + "' already exists");
        }

        // Update category fields
        category.setName(updatedCategory.getName());
        category.setDescription(updatedCategory.getDescription());

        return categoryRepository.save(category);
    }

    /**
     * Delete a category by ID
     * @param id the category ID
     * @throws IllegalArgumentException if category not found
     */
    public void deleteCategory(Long id) {
        if (!categoryRepository.existsById(id)) {
            throw new IllegalArgumentException("Category with ID " + id + " not found");
        }

        categoryRepository.deleteById(id);
    }

    /**
     * Search categories by name or description
     * @param searchText the text to search for
     * @return list of matching categories
     */
    public List<Category> searchCategories(String searchText) {
        if (searchText == null || searchText.trim().isEmpty()) {
            return getAllCategories();
        }

        return categoryRepository.findByNameOrDescriptionContainingIgnoreCase(searchText.trim());
    }

    /**
     * Check if a category exists by ID
     * @param id the category ID
     * @return true if category exists, false otherwise
     */
    public boolean existsById(Long id) {
        return categoryRepository.existsById(id);
    }

    /**
     * Check if a category exists by name
     * @param name the category name
     * @return true if category exists, false otherwise
     */
    public boolean existsByName(String name) {
        return categoryRepository.existsByNameIgnoreCase(name);
    }
}
---------------------------
package com.codereview.manager.service;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.ai.anthropic.AnthropicChatModel;
import org.springframework.ai.chat.model.ChatResponse;
import org.springframework.ai.chat.prompt.Prompt;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Mono;

/**
 * Service for integrating with Claude AI API to perform code reviews using Spring AI
 */
@Service
public class ClaudeApiService {

    private static final Logger logger = LoggerFactory.getLogger(ClaudeApiService.class);

    private final AnthropicChatModel chatModel;
    private final String apiKey;

    @Autowired
    public ClaudeApiService(AnthropicChatModel chatModel,
                           @Value("${spring.ai.anthropic.api-key:}") String apiKey) {
        this.chatModel = chatModel;
        this.apiKey = apiKey;
    }

    /**
     * Execute a code review using Claude AI
     * @param prompt The review prompt/instructions
     * @param code The code to review
     * @return AI-generated code review
     */
    public Mono<String> executeCodeReview(String prompt, String code) {
        if (apiKey == null || apiKey.trim().isEmpty() || "your-anthropic-api-key-here".equals(apiKey)) {
            return Mono.error(new IllegalStateException(
                "Anthropic API key not configured. Please set ANTHROPIC_API_KEY environment variable."));
        }

        return Mono.fromCallable(() -> {
            String fullPrompt = buildFullPrompt(prompt, code);
            logger.info("Sending code review request to Claude AI via Spring AI");

            try {
                Prompt aiPrompt = new Prompt(fullPrompt);
                ChatResponse response = chatModel.call(aiPrompt);

                String result = response.getResult().getOutput().getContent();
                logger.info("Successfully received code review from Claude AI");
                return result;

            } catch (Exception e) {
                logger.error("Error calling Claude AI: {}", e.getMessage());
                throw new RuntimeException("Failed to get code review from Claude: " + e.getMessage(), e);
            }
        });
    }

    /**
     * Test a prompt with sample code
     * @param prompt The prompt to test
     * @param sampleCode Sample code for testing
     * @return Test result with AI analysis
     */
    public Mono<String> testPrompt(String prompt, String sampleCode) {
        String testingPrompt = """
            This is a PROMPT TESTING session. Please evaluate the effectiveness of this code review prompt:

            PROMPT TO TEST:
            %s

            SAMPLE CODE FOR TESTING:
            %s

            Please provide:
            1. Analysis of the prompt's effectiveness
            2. What the prompt would catch in this sample code
            3. Suggestions for improving the prompt
            4. A sample review output showing how the prompt would work
            """.formatted(prompt, sampleCode);

        return executeCodeReview(testingPrompt, "");
    }

    private String buildFullPrompt(String prompt, String code) {
        return """
            You are an expert code reviewer. Please analyze the following code using the given prompt/instructions.

            REVIEW INSTRUCTIONS:
            %s

            CODE TO REVIEW:
            ```
            %s
            ```

            Please provide a thorough code review following the instructions above. Be specific, actionable, and constructive in your feedback.
            """.formatted(prompt, code);
    }

    public boolean isApiKeyConfigured() {
        return apiKey != null && !apiKey.trim().isEmpty() && !"your-anthropic-api-key-here".equals(apiKey);
    }
}
---------------------------
package com.codereview.manager.service;

import com.codereview.manager.model.CodeReviewSubmission;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.ai.anthropic.AnthropicChatModel;
import org.springframework.ai.chat.messages.UserMessage;
import org.springframework.ai.chat.model.ChatResponse;
import org.springframework.ai.chat.prompt.Prompt;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.List;

/**
 * Service for processing code reviews using AI
 */
@Service
public class CodeReviewProcessingService {

    private static final Logger logger = LoggerFactory.getLogger(CodeReviewProcessingService.class);

    @Autowired(required = false)
    private AnthropicChatModel chatModel;

    /**
     * Process code review using AI analysis
     */
    public String processCodeReview(CodeReviewSubmission submission) {
        logger.info("Processing code review for submission: {}", submission.getReviewId());

        try {
            // Update the review started date
            submission.setReviewStartedDate(LocalDateTime.now());

            if (chatModel == null) {
                logger.warn("AI chat model not available, using fallback processing");
                return generateFallbackReview(submission);
            }

            // Build the review prompt
            String reviewPrompt = buildReviewPrompt(submission);
            logger.debug("Generated review prompt for: {}", submission.getReviewId());

            // Execute AI review
            Prompt prompt = new Prompt(new UserMessage(reviewPrompt));
            ChatResponse response = chatModel.call(prompt);

            String reviewReport = response.getResult().getOutput().getContent();
            logger.info("AI code review completed for: {}", submission.getReviewId());

            return enhanceReviewReport(reviewReport, submission);

        } catch (Exception e) {
            logger.error("Error processing code review for: {}", submission.getReviewId(), e);
            throw new RuntimeException("Failed to process code review: " + e.getMessage(), e);
        }
    }

    /**
     * Build comprehensive review prompt for AI
     */
    private String buildReviewPrompt(CodeReviewSubmission submission) {
        StringBuilder prompt = new StringBuilder();

        prompt.append("Please conduct a comprehensive code review of the following code submission:\n\n");

        // Submission context
        prompt.append("## Submission Details\n");
        prompt.append("- Review ID: ").append(submission.getReviewId()).append("\n");
        prompt.append("- Programming Language: ").append(submission.getProgrammingLanguage()).append("\n");
        prompt.append("- File Path: ").append(submission.getFilePath()).append("\n");
        prompt.append("- Priority: ").append(submission.getPriority().getDisplayName()).append("\n");

        if (submission.getProject() != null) {
            prompt.append("- Project: ").append(submission.getProject().getName()).append("\n");
            if (submission.getProject().getTeam() != null) {
                prompt.append("- Team: ").append(submission.getProject().getTeam().getName()).append("\n");
            }
        }

        prompt.append("\n## Code to Review\n");
        prompt.append("```").append(submission.getProgrammingLanguage()).append("\n");
        prompt.append(submission.getCodeContent()).append("\n");
        prompt.append("```\n\n");

        // Review criteria
        prompt.append("## Review Criteria\n");
        prompt.append("Please analyze the code for:\n");
        prompt.append("1. **Code Quality**: Clean code principles, readability, maintainability\n");
        prompt.append("2. **Best Practices**: Language-specific best practices and conventions\n");
        prompt.append("3. **Performance**: Potential performance issues and optimizations\n");
        prompt.append("4. **Security**: Security vulnerabilities and concerns\n");
        prompt.append("5. **Error Handling**: Proper exception handling and edge cases\n");
        prompt.append("6. **Documentation**: Code comments and documentation quality\n");
        prompt.append("7. **Testing**: Testability and potential test cases\n");
        prompt.append("8. **Architecture**: Design patterns and architectural considerations\n\n");

        // Output format
        prompt.append("## Required Output Format\n");
        prompt.append("Please provide your review in the following structured format:\n\n");
        prompt.append("###  OVERALL ASSESSMENT\n");
        prompt.append("- **Rating**: [1-10 scale]\n");
        prompt.append("- **Status**: [APPROVED/NEEDS_MINOR_CHANGES/NEEDS_MAJOR_CHANGES/REJECTED]\n");
        prompt.append("- **Summary**: [Brief overall assessment]\n\n");

        prompt.append("###  POSITIVE ASPECTS\n");
        prompt.append("[List what was done well]\n\n");

        prompt.append("###  ISSUES FOUND\n");
        prompt.append("#### High Priority\n");
        prompt.append("[Critical issues that must be fixed]\n\n");
        prompt.append("#### Medium Priority\n");
        prompt.append("[Important improvements recommended]\n\n");
        prompt.append("#### Low Priority\n");
        prompt.append("[Minor suggestions and style improvements]\n\n");

        prompt.append("###  RECOMMENDATIONS\n");
        prompt.append("[Specific actionable recommendations]\n\n");

        prompt.append("###  NEXT STEPS\n");
        prompt.append("[Clear next steps for the developer]\n");

        return prompt.toString();
    }

    /**
     * Generate fallback review when AI is not available
     */
    private String generateFallbackReview(CodeReviewSubmission submission) {
        StringBuilder review = new StringBuilder();

        review.append("# Code Review Report\n\n");
        review.append("##  Automated Review Notice\n");
        review.append("This review was generated automatically as AI services are currently unavailable.\n\n");

        review.append("##  OVERALL ASSESSMENT\n");
        review.append("- **Rating**: 7/10 (Automated)\n");
        review.append("- **Status**: NEEDS_MANUAL_REVIEW\n");
        review.append("- **Summary**: Code submitted successfully but requires manual review by team member\n\n");

        review.append("##  SUBMISSION DETAILS\n");
        review.append("- **Review ID**: ").append(submission.getReviewId()).append("\n");
        review.append("- **Language**: ").append(submission.getProgrammingLanguage()).append("\n");
        review.append("- **File**: ").append(submission.getFilePath()).append("\n");
        review.append("- **Lines of Code**: ").append(countLinesOfCode(submission.getCodeContent())).append("\n");
        review.append("- **Submitted**: ").append(submission.getSubmittedDate()).append("\n\n");

        review.append("##  AUTOMATED CHECKS\n");
        review.append("- Code format: Valid ").append(submission.getProgrammingLanguage()).append(" syntax\n");
        review.append("- File structure: Standard file extension detected\n");
        review.append("- Content length: ").append(submission.getCodeContent().length()).append(" characters\n\n");

        review.append("##  MANUAL REVIEW REQUIRED\n");
        review.append("Please have a team member manually review this code for:\n");
        review.append("- Logic correctness and business requirements\n");
        review.append("- Code quality and best practices\n");
        review.append("- Security considerations\n");
        review.append("- Performance implications\n");
        review.append("- Integration with existing codebase\n\n");

        review.append("##  NEXT STEPS\n");
        review.append("1. Assign this review to a senior team member\n");
        review.append("2. Schedule a code review session if needed\n");
        review.append("3. Update the review status once manual review is complete\n");

        return review.toString();
    }

    /**
     * Enhance the AI review report with additional metadata
     */
    private String enhanceReviewReport(String aiReview, CodeReviewSubmission submission) {
        StringBuilder enhanced = new StringBuilder();

        // Add header with metadata
        enhanced.append("# Code Review Report - ").append(submission.getReviewId()).append("\n\n");
        enhanced.append("##  Review Metadata\n");
        enhanced.append("- **Generated**: ").append(LocalDateTime.now()).append("\n");
        enhanced.append("- **Reviewer**: AI Code Analysis System\n");
        enhanced.append("- **Language**: ").append(submission.getProgrammingLanguage()).append("\n");
        enhanced.append("- **Priority**: ").append(submission.getPriority().getDisplayName()).append("\n");
        enhanced.append("- **Lines**: ").append(countLinesOfCode(submission.getCodeContent())).append("\n");

        if (submission.getProject() != null) {
            enhanced.append("- **Project**: ").append(submission.getProject().getName()).append("\n");
        }

        enhanced.append("\n---\n\n");

        // Add the AI review content
        enhanced.append(aiReview);

        // Add footer
        enhanced.append("\n\n---\n");
        enhanced.append("*This review was generated automatically using AI analysis. ");
        enhanced.append("Please validate recommendations and consult with team members for complex decisions.*\n");

        return enhanced.toString();
    }

    /**
     * Count lines of code (excluding empty lines)
     */
    private int countLinesOfCode(String code) {
        if (code == null || code.isEmpty()) {
            return 0;
        }

        return (int) code.lines()
            .map(String::trim)
            .filter(line -> !line.isEmpty())
            .count();
    }

    /**
     * Validate code syntax (basic validation)
     */
    private boolean validateCodeSyntax(String code, String language) {
        if (code == null || code.isEmpty()) {
            return false;
        }

        // Basic syntax validation based on language
        switch (language.toLowerCase()) {
            case "java":
                return code.contains("{") && code.contains("}");
            case "javascript":
            case "typescript":
                return !code.contains("SyntaxError");
            case "python":
                // Basic Python syntax check
                return !code.contains("IndentationError");
            default:
                return true; // Assume valid for unknown languages
        }
    }
}
---------------------------
package com.codereview.manager.service;

import com.codereview.manager.model.CodeReviewSubmission;
import com.codereview.manager.model.Project;
import com.codereview.manager.repository.CodeReviewSubmissionRepository;
import com.codereview.manager.repository.ProjectRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.Arrays;
import java.util.List;
import java.util.Optional;
import java.util.concurrent.CompletableFuture;

/**
 * Service class for managing code review submissions with async processing
 */
@Service
@Transactional
public class CodeReviewSubmissionService {

    private static final Logger logger = LoggerFactory.getLogger(CodeReviewSubmissionService.class);

    @Autowired
    private CodeReviewSubmissionRepository submissionRepository;

    @Autowired
    private ProjectRepository projectRepository;

    @Autowired
    private EmailNotificationService emailService;

    @Autowired
    private CodeReviewProcessingService reviewProcessingService;

    /**
     * Submit code for review
     */
    public CodeReviewSubmission submitCodeForReview(CodeReviewSubmission submission) {
        logger.info("Submitting code for review: project={}, submitter={}, commit={}",
            submission.getProject().getId(), submission.getSubmitterEmail(), submission.getCommitHash());

        // Validate project exists and is active
        Project project = projectRepository.findById(submission.getProject().getId())
            .orElseThrow(() -> new IllegalArgumentException("Project not found with ID: " + submission.getProject().getId()));

        if (!project.getActive()) {
            throw new IllegalArgumentException("Cannot submit code for inactive project: " + project.getName());
        }

        submission.setProject(project);

        // Generate contextual review ID
        submission.generateContextualReviewId();

        // Set initial status
        submission.setReviewStatus(CodeReviewSubmission.ReviewStatus.PENDING);
        submission.setSubmittedDate(LocalDateTime.now());
        submission.setCreatedDate(LocalDateTime.now());
        submission.setLastModified(LocalDateTime.now());

        // Auto-detect programming language if not provided
        if (submission.getProgrammingLanguage() == null || submission.getProgrammingLanguage().isEmpty()) {
            submission.setProgrammingLanguage(detectProgrammingLanguage(submission.getFilePath(), submission.getCodeContent()));
        }

        // Save submission
        CodeReviewSubmission savedSubmission = submissionRepository.save(submission);
        logger.info("Code submission saved with review ID: {}", savedSubmission.getReviewId());

        // Trigger async code review process
        triggerAsyncCodeReview(savedSubmission.getId());

        // Send initial notification
        sendSubmissionNotification(savedSubmission);

        return savedSubmission;
    }

    /**
     * Trigger async code review processing
     */
    @Async
    public CompletableFuture<Void> triggerAsyncCodeReview(Long submissionId) {
        try {
            logger.info("Starting async code review for submission ID: {}", submissionId);

            Optional<CodeReviewSubmission> optionalSubmission = submissionRepository.findById(submissionId);
            if (optionalSubmission.isEmpty()) {
                logger.error("Submission not found for ID: {}", submissionId);
                return CompletableFuture.completedFuture(null);
            }

            CodeReviewSubmission submission = optionalSubmission.get();

            // Update status to IN_PROGRESS
            submission.setReviewStatus(CodeReviewSubmission.ReviewStatus.IN_PROGRESS);
            submissionRepository.save(submission);

            // Process the code review
            String reviewReport = reviewProcessingService.processCodeReview(submission);

            // Update submission with results
            submission.setReviewReport(reviewReport);
            submission.setReviewStatus(CodeReviewSubmission.ReviewStatus.COMPLETED);
            submission.setReviewCompletedDate(LocalDateTime.now());
            submissionRepository.save(submission);

            logger.info("Code review completed for submission: {}", submission.getReviewId());

            // Send completion notification
            sendCompletionNotification(submission);

        } catch (Exception e) {
            logger.error("Error during async code review for submission ID: {}", submissionId, e);

            // Update submission status to FAILED
            Optional<CodeReviewSubmission> optionalSubmission = submissionRepository.findById(submissionId);
            if (optionalSubmission.isPresent()) {
                CodeReviewSubmission submission = optionalSubmission.get();
                submission.setReviewStatus(CodeReviewSubmission.ReviewStatus.FAILED);
                submission.setReviewReport("Review failed due to system error: " + e.getMessage());
                submissionRepository.save(submission);

                // Send failure notification
                sendFailureNotification(submission);
            }
        }

        return CompletableFuture.completedFuture(null);
    }

    /**
     * Get submission by review ID
     */
    @Transactional(readOnly = true)
    public Optional<CodeReviewSubmission> getSubmissionByReviewId(String reviewId) {
        logger.debug("Fetching submission by review ID: {}", reviewId);
        return submissionRepository.findByReviewId(reviewId);
    }

    /**
     * Get submissions by project
     */
    @Transactional(readOnly = true)
    public List<CodeReviewSubmission> getSubmissionsByProject(Long projectId) {
        logger.debug("Fetching submissions for project ID: {}", projectId);
        Project project = projectRepository.findById(projectId)
            .orElseThrow(() -> new IllegalArgumentException("Project not found with ID: " + projectId));
        return submissionRepository.findByProject(project);
    }

    /**
     * Get submissions by team
     */
    @Transactional(readOnly = true)
    public List<CodeReviewSubmission> getSubmissionsByTeam(Long teamId) {
        logger.debug("Fetching submissions for team ID: {}", teamId);
        return submissionRepository.findByTeamId(teamId);
    }

    /**
     * Get submissions by submitter
     */
    @Transactional(readOnly = true)
    public List<CodeReviewSubmission> getSubmissionsBySubmitter(String submitterEmail) {
        logger.debug("Fetching submissions for submitter: {}", submitterEmail);
        return submissionRepository.findBySubmitterEmailOrderBySubmittedDateDesc(submitterEmail);
    }

    /**
     * Get submissions by status
     */
    @Transactional(readOnly = true)
    public List<CodeReviewSubmission> getSubmissionsByStatus(CodeReviewSubmission.ReviewStatus status) {
        logger.debug("Fetching submissions with status: {}", status);
        return submissionRepository.findByReviewStatusOrderBySubmittedDateDesc(status);
    }

    /**
     * Get recent submissions (last 7 days)
     */
    @Transactional(readOnly = true)
    public List<CodeReviewSubmission> getRecentSubmissions() {
        LocalDateTime sevenDaysAgo = LocalDateTime.now().minusDays(7);
        return submissionRepository.findRecentSubmissions(sevenDaysAgo);
    }

    /**
     * Get high priority pending submissions
     */
    @Transactional(readOnly = true)
    public List<CodeReviewSubmission> getHighPriorityPendingSubmissions() {
        List<CodeReviewSubmission.Priority> highPriorities = Arrays.asList(
            CodeReviewSubmission.Priority.HIGH,
            CodeReviewSubmission.Priority.URGENT
        );
        return submissionRepository.findHighPriorityPendingSubmissions(
            highPriorities,
            CodeReviewSubmission.ReviewStatus.PENDING
        );
    }

    /**
     * Search submissions
     */
    @Transactional(readOnly = true)
    public List<CodeReviewSubmission> searchSubmissions(String searchTerm) {
        logger.debug("Searching submissions with term: {}", searchTerm);
        if (searchTerm == null || searchTerm.trim().isEmpty()) {
            return submissionRepository.findAll();
        }
        return submissionRepository.searchSubmissions(searchTerm);
    }

    /**
     * Get submission statistics
     */
    @Transactional(readOnly = true)
    public List<Object[]> getSubmissionStatistics() {
        return submissionRepository.getSubmissionStatistics();
    }

    /**
     * Get team submission statistics
     */
    @Transactional(readOnly = true)
    public List<Object[]> getTeamSubmissionStatistics() {
        return submissionRepository.getTeamSubmissionStatistics();
    }

    /**
     * Update submission priority
     */
    public CodeReviewSubmission updateSubmissionPriority(String reviewId, CodeReviewSubmission.Priority priority) {
        CodeReviewSubmission submission = submissionRepository.findByReviewId(reviewId)
            .orElseThrow(() -> new IllegalArgumentException("Submission not found with review ID: " + reviewId));

        submission.setPriority(priority);
        submission.setLastModified(LocalDateTime.now());

        CodeReviewSubmission updated = submissionRepository.save(submission);
        logger.info("Updated priority for submission {} to {}", reviewId, priority);

        return updated;
    }

    /**
     * Cancel submission
     */
    public CodeReviewSubmission cancelSubmission(String reviewId, String reason) {
        CodeReviewSubmission submission = submissionRepository.findByReviewId(reviewId)
            .orElseThrow(() -> new IllegalArgumentException("Submission not found with review ID: " + reviewId));

        if (submission.getReviewStatus() == CodeReviewSubmission.ReviewStatus.COMPLETED) {
            throw new IllegalStateException("Cannot cancel completed review: " + reviewId);
        }

        submission.setReviewStatus(CodeReviewSubmission.ReviewStatus.CANCELLED);
        submission.setReviewReport("Review cancelled: " + reason);
        submission.setLastModified(LocalDateTime.now());

        CodeReviewSubmission cancelled = submissionRepository.save(submission);
        logger.info("Cancelled submission: {}", reviewId);

        // Send cancellation notification
        sendCancellationNotification(cancelled, reason);

        return cancelled;
    }

    // Private helper methods

    private String detectProgrammingLanguage(String filePath, String codeContent) {
        if (filePath != null && !filePath.isEmpty()) {
            String extension = getFileExtension(filePath).toLowerCase();
            switch (extension) {
                case "java": return "java";
                case "js": case "jsx": return "javascript";
                case "ts": case "tsx": return "typescript";
                case "py": return "python";
                case "cs": return "csharp";
                case "cpp": case "cc": case "cxx": return "cpp";
                case "c": return "c";
                case "go": return "go";
                case "rb": return "ruby";
                case "php": return "php";
                default: return "text";
            }
        }

        // Fallback to content analysis
        if (codeContent != null) {
            if (codeContent.contains("public class") || codeContent.contains("@Override")) return "java";
            if (codeContent.contains("function") || codeContent.contains("const ") || codeContent.contains("let ")) return "javascript";
            if (codeContent.contains("def ") || codeContent.contains("import ")) return "python";
            if (codeContent.contains("using System") || codeContent.contains("namespace ")) return "csharp";
        }

        return "text";
    }

    private String getFileExtension(String filePath) {
        int lastDotIndex = filePath.lastIndexOf('.');
        return lastDotIndex > 0 ? filePath.substring(lastDotIndex + 1) : "";
    }

    private void sendSubmissionNotification(CodeReviewSubmission submission) {
        try {
            emailService.sendSubmissionNotification(submission);
        } catch (Exception e) {
            logger.error("Failed to send submission notification for: {}", submission.getReviewId(), e);
        }
    }

    private void sendCompletionNotification(CodeReviewSubmission submission) {
        try {
            emailService.sendCompletionNotification(submission);
            submission.setNotificationSent(true);
            submissionRepository.save(submission);
        } catch (Exception e) {
            logger.error("Failed to send completion notification for: {}", submission.getReviewId(), e);
        }
    }

    private void sendFailureNotification(CodeReviewSubmission submission) {
        try {
            emailService.sendFailureNotification(submission);
        } catch (Exception e) {
            logger.error("Failed to send failure notification for: {}", submission.getReviewId(), e);
        }
    }

    private void sendCancellationNotification(CodeReviewSubmission submission, String reason) {
        try {
            emailService.sendCancellationNotification(submission, reason);
        } catch (Exception e) {
            logger.error("Failed to send cancellation notification for: {}", submission.getReviewId(), e);
        }
    }
}
---------------------------------------
package com.codereview.manager.service;

import com.codereview.manager.model.CodeReviewSubmission;
import com.codereview.manager.model.Team;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.mail.javamail.MimeMessageHelper;
import org.springframework.stereotype.Service;

import jakarta.mail.internet.MimeMessage;
import java.time.format.DateTimeFormatter;
import java.util.List;
import java.util.stream.Collectors;

/**
 * Service for sending email notifications for code reviews
 */
@Service
public class EmailNotificationService {

    private static final Logger logger = LoggerFactory.getLogger(EmailNotificationService.class);

    @Autowired(required = false)
    private JavaMailSender mailSender;

    @Value("${app.mail.from:noreply@codereview.com}")
    private String fromEmail;

    @Value("${app.mail.enabled:false}")
    private boolean emailEnabled;

    @Value("${app.base.url:http://localhost:3000}")
    private String baseUrl;

    private static final DateTimeFormatter DATE_FORMATTER = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");

    /**
     * Send notification when code is submitted for review
     */
    public void sendSubmissionNotification(CodeReviewSubmission submission) {
        if (!emailEnabled || mailSender == null) {
            logger.info("Email notifications disabled or mail sender not configured");
            return;
        }

        try {
            Team team = submission.getProject().getTeam();
            List<String> recipients = getNotificationRecipients(team);

            if (recipients.isEmpty()) {
                logger.warn("No notification recipients found for team: {}", team.getName());
                return;
            }

            String subject = String.format("[Code Review] New Submission - %s", submission.getReviewId());
            String content = buildSubmissionEmailContent(submission);

            sendHtmlEmail(recipients, subject, content);
            logger.info("Submission notification sent for: {}", submission.getReviewId());

        } catch (Exception e) {
            logger.error("Failed to send submission notification for: {}", submission.getReviewId(), e);
            throw new RuntimeException("Failed to send submission notification", e);
        }
    }

    /**
     * Send notification when code review is completed
     */
    public void sendCompletionNotification(CodeReviewSubmission submission) {
        if (!emailEnabled || mailSender == null) {
            logger.info("Email notifications disabled or mail sender not configured");
            return;
        }

        try {
            Team team = submission.getProject().getTeam();
            List<String> recipients = getNotificationRecipients(team);

            // Add submitter to recipients
            if (!recipients.contains(submission.getSubmitterEmail())) {
                recipients.add(submission.getSubmitterEmail());
            }

            String subject = String.format("[Code Review] Review Completed - %s", submission.getReviewId());
            String content = buildCompletionEmailContent(submission);

            sendHtmlEmail(recipients, subject, content);
            logger.info("Completion notification sent for: {}", submission.getReviewId());

        } catch (Exception e) {
            logger.error("Failed to send completion notification for: {}", submission.getReviewId(), e);
            throw new RuntimeException("Failed to send completion notification", e);
        }
    }

    /**
     * Send notification when code review fails
     */
    public void sendFailureNotification(CodeReviewSubmission submission) {
        if (!emailEnabled || mailSender == null) {
            logger.info("Email notifications disabled or mail sender not configured");
            return;
        }

        try {
            Team team = submission.getProject().getTeam();
            List<String> recipients = getNotificationRecipients(team);

            // Add submitter to recipients
            if (!recipients.contains(submission.getSubmitterEmail())) {
                recipients.add(submission.getSubmitterEmail());
            }

            String subject = String.format("[Code Review] Review Failed - %s", submission.getReviewId());
            String content = buildFailureEmailContent(submission);

            sendHtmlEmail(recipients, subject, content);
            logger.info("Failure notification sent for: {}", submission.getReviewId());

        } catch (Exception e) {
            logger.error("Failed to send failure notification for: {}", submission.getReviewId(), e);
            throw new RuntimeException("Failed to send failure notification", e);
        }
    }

    /**
     * Send notification when code review is cancelled
     */
    public void sendCancellationNotification(CodeReviewSubmission submission, String reason) {
        if (!emailEnabled || mailSender == null) {
            logger.info("Email notifications disabled or mail sender not configured");
            return;
        }

        try {
            Team team = submission.getProject().getTeam();
            List<String> recipients = getNotificationRecipients(team);

            // Add submitter to recipients
            if (!recipients.contains(submission.getSubmitterEmail())) {
                recipients.add(submission.getSubmitterEmail());
            }

            String subject = String.format("[Code Review] Review Cancelled - %s", submission.getReviewId());
            String content = buildCancellationEmailContent(submission, reason);

            sendHtmlEmail(recipients, subject, content);
            logger.info("Cancellation notification sent for: {}", submission.getReviewId());

        } catch (Exception e) {
            logger.error("Failed to send cancellation notification for: {}", submission.getReviewId(), e);
            throw new RuntimeException("Failed to send cancellation notification", e);
        }
    }

    /**
     * Send high priority submission alert
     */
    public void sendHighPriorityAlert(CodeReviewSubmission submission) {
        if (!emailEnabled || mailSender == null) {
            return;
        }

        try {
            Team team = submission.getProject().getTeam();
            List<String> recipients = getNotificationRecipients(team);

            // For high priority, also notify team lead if available
            if (team.getTeamLeadEmail() != null && !team.getTeamLeadEmail().isEmpty()) {
                if (!recipients.contains(team.getTeamLeadEmail())) {
                    recipients.add(team.getTeamLeadEmail());
                }
            }

            String subject = String.format("[URGENT] High Priority Code Review - %s", submission.getReviewId());
            String content = buildHighPriorityAlertContent(submission);

            sendHtmlEmail(recipients, subject, content);
            logger.info("High priority alert sent for: {}", submission.getReviewId());

        } catch (Exception e) {
            logger.error("Failed to send high priority alert for: {}", submission.getReviewId(), e);
        }
    }

    // Private helper methods

    private List<String> getNotificationRecipients(Team team) {
        List<String> recipients = team.getNotificationEmailsList();

        // Add team lead email if not already included
        if (team.getTeamLeadEmail() != null && !team.getTeamLeadEmail().isEmpty()) {
            if (!recipients.contains(team.getTeamLeadEmail())) {
                recipients.add(team.getTeamLeadEmail());
            }
        }

        return recipients.stream()
            .filter(email -> email != null && !email.trim().isEmpty())
            .collect(Collectors.toList());
    }

    private void sendHtmlEmail(List<String> recipients, String subject, String htmlContent) throws Exception {
        MimeMessage message = mailSender.createMimeMessage();
        MimeMessageHelper helper = new MimeMessageHelper(message, true, "UTF-8");

        helper.setFrom(fromEmail);
        helper.setTo(recipients.toArray(new String[0]));
        helper.setSubject(subject);
        helper.setText(htmlContent, true);

        mailSender.send(message);
    }

    private String buildSubmissionEmailContent(CodeReviewSubmission submission) {
        return String.format("""
            <!DOCTYPE html>
            <html>
            <head>
                <meta charset="UTF-8">
                <style>
                    body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; }
                    .header { background-color: #667eea; color: white; padding: 20px; text-align: center; }
                    .content { padding: 20px; }
                    .details { background-color: #f8f9fa; padding: 15px; border-radius: 5px; margin: 15px 0; }
                    .button { display: inline-block; padding: 10px 20px; background-color: #667eea; color: white;
                             text-decoration: none; border-radius: 5px; margin: 10px 5px; }
                    .footer { background-color: #f8f9fa; padding: 15px; text-align: center; font-size: 12px; color: #666; }
                </style>
            </head>
            <body>
                <div class="header">
                    <h2> New Code Review Submission</h2>
                </div>

                <div class="content">
                    <p>Hello Team,</p>

                    <p>A new code review has been submitted and is now pending review.</p>

                    <div class="details">
                        <h3> Submission Details</h3>
                        <ul>
                            <li><strong>Review ID:</strong> %s</li>
                            <li><strong>Team:</strong> %s</li>
                            <li><strong>Project:</strong> %s</li>
                            <li><strong>Submitter:</strong> %s (%s)</li>
                            <li><strong>Commit Hash:</strong> %s</li>
                            <li><strong>Language:</strong> %s</li>
                            <li><strong>Priority:</strong> %s</li>
                            <li><strong>Submitted:</strong> %s</li>
                        </ul>
                    </div>

                    <p>The automated review process has been triggered and will be completed shortly.</p>

                    <div style="text-align: center; margin: 20px 0;">
                        <a href="%s/submissions/%s" class="button">View Submission Details</a>
                        <a href="%s/team/%s" class="button">Team Dashboard</a>
                    </div>
                </div>

                <div class="footer">
                    <p>This is an automated notification from Code Review Manager</p>
                    <p>Please do not reply to this email</p>
                </div>
            </body>
            </html>
            """,
            submission.getReviewId(),
            submission.getProject().getTeam().getName(),
            submission.getProject().getName(),
            submission.getSubmitterName() != null ? submission.getSubmitterName() : "Unknown",
            submission.getSubmitterEmail(),
            submission.getCommitHash(),
            submission.getProgrammingLanguage() != null ? submission.getProgrammingLanguage().toUpperCase() : "Unknown",
            submission.getPriority().getDisplayName(),
            submission.getSubmittedDate().format(DATE_FORMATTER),
            baseUrl, submission.getReviewId(),
            baseUrl, submission.getProject().getTeam().getId()
        );
    }

    private String buildCompletionEmailContent(CodeReviewSubmission submission) {
        return String.format("""
            <!DOCTYPE html>
            <html>
            <head>
                <meta charset="UTF-8">
                <style>
                    body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; }
                    .header { background-color: #28a745; color: white; padding: 20px; text-align: center; }
                    .content { padding: 20px; }
                    .details { background-color: #f8f9fa; padding: 15px; border-radius: 5px; margin: 15px 0; }
                    .success { background-color: #d4edda; border: 1px solid #c3e6cb; padding: 15px; border-radius: 5px; }
                    .button { display: inline-block; padding: 10px 20px; background-color: #28a745; color: white;
                             text-decoration: none; border-radius: 5px; margin: 10px 5px; }
                    .footer { background-color: #f8f9fa; padding: 15px; text-align: center; font-size: 12px; color: #666; }
                </style>
            </head>
            <body>
                <div class="header">
                    <h2> Code Review Completed</h2>
                </div>

                <div class="content">
                    <div class="success">
                        <h3> Review Successfully Completed!</h3>
                        <p>The automated code review for <strong>%s</strong> has been completed.</p>
                    </div>

                    <div class="details">
                        <h3> Review Summary</h3>
                        <ul>
                            <li><strong>Review ID:</strong> %s</li>
                            <li><strong>Team:</strong> %s</li>
                            <li><strong>Project:</strong> %s</li>
                            <li><strong>Submitter:</strong> %s</li>
                            <li><strong>Submitted:</strong> %s</li>
                            <li><strong>Completed:</strong> %s</li>
                            <li><strong>Processing Time:</strong> %s minutes</li>
                        </ul>
                    </div>

                    <p>The detailed review report is now available and includes analysis, recommendations, and any issues found.</p>

                    <div style="text-align: center; margin: 20px 0;">
                        <a href="%s/submissions/%s" class="button">View Review Report</a>
                        <a href="%s/submissions/%s/download" class="button">Download Report</a>
                    </div>
                </div>

                <div class="footer">
                    <p>This is an automated notification from Code Review Manager</p>
                    <p>Please do not reply to this email</p>
                </div>
            </body>
            </html>
            """,
            submission.getReviewId(),
            submission.getReviewId(),
            submission.getProject().getTeam().getName(),
            submission.getProject().getName(),
            submission.getSubmitterEmail(),
            submission.getSubmittedDate().format(DATE_FORMATTER),
            submission.getReviewCompletedDate().format(DATE_FORMATTER),
            calculateProcessingTimeMinutes(submission),
            baseUrl, submission.getReviewId(),
            baseUrl, submission.getReviewId()
        );
    }

    private String buildFailureEmailContent(CodeReviewSubmission submission) {
        return String.format("""
            <!DOCTYPE html>
            <html>
            <head>
                <meta charset="UTF-8">
                <style>
                    body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; }
                    .header { background-color: #dc3545; color: white; padding: 20px; text-align: center; }
                    .content { padding: 20px; }
                    .details { background-color: #f8f9fa; padding: 15px; border-radius: 5px; margin: 15px 0; }
                    .error { background-color: #f8d7da; border: 1px solid #f5c6cb; padding: 15px; border-radius: 5px; }
                    .button { display: inline-block; padding: 10px 20px; background-color: #dc3545; color: white;
                             text-decoration: none; border-radius: 5px; margin: 10px 5px; }
                    .footer { background-color: #f8f9fa; padding: 15px; text-align: center; font-size: 12px; color: #666; }
                </style>
            </head>
            <body>
                <div class="header">
                    <h2> Code Review Failed</h2>
                </div>

                <div class="content">
                    <div class="error">
                        <h3> Review Process Failed</h3>
                        <p>The automated code review for <strong>%s</strong> encountered an error and could not be completed.</p>
                    </div>

                    <div class="details">
                        <h3> Submission Details</h3>
                        <ul>
                            <li><strong>Review ID:</strong> %s</li>
                            <li><strong>Team:</strong> %s</li>
                            <li><strong>Project:</strong> %s</li>
                            <li><strong>Submitter:</strong> %s</li>
                            <li><strong>Submitted:</strong> %s</li>
                            <li><strong>Failed:</strong> %s</li>
                        </ul>
                    </div>

                    <p><strong>Next Steps:</strong></p>
                    <ul>
                        <li>Please try resubmitting the code</li>
                        <li>If the issue persists, contact the development team</li>
                        <li>Check the submission details for any specific error messages</li>
                    </ul>

                    <div style="text-align: center; margin: 20px 0;">
                        <a href="%s/submissions/%s" class="button">View Submission Details</a>
                        <a href="%s/submit" class="button">Submit New Review</a>
                    </div>
                </div>

                <div class="footer">
                    <p>This is an automated notification from Code Review Manager</p>
                    <p>Please do not reply to this email</p>
                </div>
            </body>
            </html>
            """,
            submission.getReviewId(),
            submission.getReviewId(),
            submission.getProject().getTeam().getName(),
            submission.getProject().getName(),
            submission.getSubmitterEmail(),
            submission.getSubmittedDate().format(DATE_FORMATTER),
            submission.getLastModified().format(DATE_FORMATTER),
            baseUrl, submission.getReviewId(),
            baseUrl
        );
    }

    private String buildCancellationEmailContent(CodeReviewSubmission submission, String reason) {
        return String.format("""
            <!DOCTYPE html>
            <html>
            <head>
                <meta charset="UTF-8">
                <style>
                    body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; }
                    .header { background-color: #ffc107; color: #212529; padding: 20px; text-align: center; }
                    .content { padding: 20px; }
                    .details { background-color: #f8f9fa; padding: 15px; border-radius: 5px; margin: 15px 0; }
                    .warning { background-color: #fff3cd; border: 1px solid #ffeaa7; padding: 15px; border-radius: 5px; }
                    .button { display: inline-block; padding: 10px 20px; background-color: #ffc107; color: #212529;
                             text-decoration: none; border-radius: 5px; margin: 10px 5px; }
                    .footer { background-color: #f8f9fa; padding: 15px; text-align: center; font-size: 12px; color: #666; }
                </style>
            </head>
            <body>
                <div class="header">
                    <h2> Code Review Cancelled</h2>
                </div>

                <div class="content">
                    <div class="warning">
                        <h3> Review Cancelled</h3>
                        <p>The code review for <strong>%s</strong> has been cancelled.</p>
                        %s
                    </div>

                    <div class="details">
                        <h3> Submission Details</h3>
                        <ul>
                            <li><strong>Review ID:</strong> %s</li>
                            <li><strong>Team:</strong> %s</li>
                            <li><strong>Project:</strong> %s</li>
                            <li><strong>Submitter:</strong> %s</li>
                            <li><strong>Submitted:</strong> %s</li>
                            <li><strong>Cancelled:</strong> %s</li>
                        </ul>
                    </div>

                    <p>If you need to review this code, please submit a new review request.</p>

                    <div style="text-align: center; margin: 20px 0;">
                        <a href="%s/submissions/%s" class="button">View Submission</a>
                        <a href="%s/submit" class="button">Submit New Review</a>
                    </div>
                </div>

                <div class="footer">
                    <p>This is an automated notification from Code Review Manager</p>
                    <p>Please do not reply to this email</p>
                </div>
            </body>
            </html>
            """,
            submission.getReviewId(),
            reason != null && !reason.trim().isEmpty() ?
                String.format("<p><strong>Reason:</strong> %s</p>", reason) : "",
            submission.getReviewId(),
            submission.getProject().getTeam().getName(),
            submission.getProject().getName(),
            submission.getSubmitterEmail(),
            submission.getSubmittedDate().format(DATE_FORMATTER),
            submission.getLastModified().format(DATE_FORMATTER),
            baseUrl, submission.getReviewId(),
            baseUrl
        );
    }

    private String buildHighPriorityAlertContent(CodeReviewSubmission submission) {
        return String.format("""
            <!DOCTYPE html>
            <html>
            <head>
                <meta charset="UTF-8">
                <style>
                    body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; }
                    .header { background-color: #e74c3c; color: white; padding: 20px; text-align: center; }
                    .content { padding: 20px; }
                    .details { background-color: #f8f9fa; padding: 15px; border-radius: 5px; margin: 15px 0; }
                    .urgent { background-color: #f8d7da; border: 2px solid #e74c3c; padding: 15px; border-radius: 5px;
                             animation: pulse 2s infinite; }
                    .button { display: inline-block; padding: 12px 24px; background-color: #e74c3c; color: white;
                             text-decoration: none; border-radius: 5px; margin: 10px 5px; font-weight: bold; }
                    .footer { background-color: #f8f9fa; padding: 15px; text-align: center; font-size: 12px; color: #666; }
                    @keyframes pulse { 0%% { opacity: 1; } 50%% { opacity: 0.5; } 100%% { opacity: 1; } }
                </style>
            </head>
            <body>
                <div class="header">
                    <h2> URGENT: High Priority Code Review</h2>
                </div>

                <div class="content">
                    <div class="urgent">
                        <h3> HIGH PRIORITY SUBMISSION</h3>
                        <p>A <strong>%s</strong> priority code review has been submitted and requires immediate attention!</p>
                    </div>

                    <div class="details">
                        <h3> Urgent Submission Details</h3>
                        <ul>
                            <li><strong>Review ID:</strong> %s</li>
                            <li><strong>Priority:</strong> <span style="color: #e74c3c; font-weight: bold;">%s</span></li>
                            <li><strong>Team:</strong> %s</li>
                            <li><strong>Project:</strong> %s</li>
                            <li><strong>Submitter:</strong> %s</li>
                            <li><strong>Submitted:</strong> %s</li>
                            <li><strong>Status:</strong> %s</li>
                        </ul>
                    </div>

                    <p><strong>Immediate Action Required:</strong></p>
                    <ul>
                        <li>Please review this submission as soon as possible</li>
                        <li>Check for any blocking issues or critical problems</li>
                        <li>Coordinate with the team if manual intervention is needed</li>
                    </ul>

                    <div style="text-align: center; margin: 20px 0;">
                        <a href="%s/submissions/%s" class="button"> REVIEW NOW</a>
                        <a href="%s/team/%s" class="button">Team Dashboard</a>
                    </div>
                </div>

                <div class="footer">
                    <p>This is an automated HIGH PRIORITY notification from Code Review Manager</p>
                    <p>Please do not reply to this email</p>
                </div>
            </body>
            </html>
            """,
            submission.getPriority().getDisplayName().toUpperCase(),
            submission.getReviewId(),
            submission.getPriority().getDisplayName().toUpperCase(),
            submission.getProject().getTeam().getName(),
            submission.getProject().getName(),
            submission.getSubmitterEmail(),
            submission.getSubmittedDate().format(DATE_FORMATTER),
            submission.getReviewStatus().getDisplayName(),
            baseUrl, submission.getReviewId(),
            baseUrl, submission.getProject().getTeam().getId()
        );
    }

    private long calculateProcessingTimeMinutes(CodeReviewSubmission submission) {
        if (submission.getReviewStartedDate() != null && submission.getReviewCompletedDate() != null) {
            return java.time.Duration.between(
                submission.getReviewStartedDate(),
                submission.getReviewCompletedDate()
            ).toMinutes();
        }
        return 0;
    }
}
-------------------------------
package com.codereview.manager.service;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.ai.anthropic.AnthropicChatModel;
import org.springframework.ai.chat.model.ChatResponse;
import org.springframework.ai.chat.prompt.Prompt;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Mono;

import java.io.IOException;
import java.nio.file.*;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.*;
import java.util.stream.Stream;

/**
 * Service for analyzing entire projects and generating comprehensive reviews and documentation
 */
@Service
public class ProjectAnalysisService {

    private static final Logger logger = LoggerFactory.getLogger(ProjectAnalysisService.class);

    private final AnthropicChatModel chatModel;
    private final ClaudeApiService claudeApiService;

    // File extensions to include in analysis
    private static final Set<String> CODE_EXTENSIONS = Set.of(
        ".java", ".js", ".ts", ".jsx", ".tsx", ".py", ".cs", ".cpp", ".c", ".h",
        ".php", ".rb", ".go", ".rs", ".kt", ".scala", ".swift", ".dart",
        ".html", ".css", ".scss", ".less", ".xml", ".json", ".yml", ".yaml",
        ".sql", ".sh", ".bat", ".ps1", ".dockerfile", ".md", ".txt"
    );

    // Directories to exclude from analysis
    private static final Set<String> EXCLUDED_DIRS = Set.of(
        "node_modules", "target", "build", "dist", "out", ".git", ".idea",
        ".vscode", "bin", "obj", "__pycache__", ".gradle", "vendor"
    );

    @Autowired
    public ProjectAnalysisService(AnthropicChatModel chatModel, ClaudeApiService claudeApiService) {
        this.chatModel = chatModel;
        this.claudeApiService = claudeApiService;
    }

    /**
     * Analyze an entire project directory
     */
    public Mono<ProjectAnalysisResult> analyzeProject(String projectPath, String analysisType) {
        return Mono.fromCallable(() -> {
            logger.info("Starting project analysis for path: {}", projectPath);

            Path path = Paths.get(projectPath);
            if (!Files.exists(path) || !Files.isDirectory(path)) {
                throw new IllegalArgumentException("Invalid project path: " + projectPath);
            }

            // Scan project structure
            ProjectStructure structure = scanProjectStructure(path);

            // Analyze key files
            Map<String, String> keyFileContents = analyzeKeyFiles(path);

            // Build analysis result
            ProjectAnalysisResult result = new ProjectAnalysisResult();
            result.projectPath = projectPath;
            result.projectStructure = structure;
            result.keyFiles = keyFileContents;
            result.analysisType = analysisType;
            result.timestamp = new Date();

            logger.info("Project analysis completed for: {}", projectPath);
            return result;
        });
    }

    /**
     * Generate README for a project
     */
    public Mono<String> generateProjectReadme(String projectPath, String readmeType) {
        return analyzeProject(projectPath, "readme")
            .flatMap(analysis -> {
                String readmePrompt = buildReadmePrompt(analysis, readmeType);
                return claudeApiService.executeCodeReview(readmePrompt, "");
            });
    }

    /**
     * Perform comprehensive project code review
     */
    public Mono<String> reviewEntireProject(String projectPath, Long promptId) {
        return analyzeProject(projectPath, "review")
            .flatMap(analysis -> {
                String reviewPrompt = buildProjectReviewPrompt(analysis);
                return claudeApiService.executeCodeReview(reviewPrompt, "");
            });
    }

    /**
     * Scan project directory structure
     */
    private ProjectStructure scanProjectStructure(Path projectPath) throws IOException {
        ProjectStructure structure = new ProjectStructure();
        structure.rootPath = projectPath.toString();
        structure.fileTree = new ArrayList<>();
        structure.statistics = new HashMap<>();

        Map<String, Integer> fileTypeCount = new HashMap<>();
        Map<String, Long> fileTypeSize = new HashMap<>();

        Files.walkFileTree(projectPath, EnumSet.noneOf(FileVisitOption.class), 10, new SimpleFileVisitor<Path>() {
            @Override
            public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) {
                String dirName = dir.getFileName().toString();
                if (EXCLUDED_DIRS.contains(dirName) || dirName.startsWith(".")) {
                    return FileVisitResult.SKIP_SUBTREE;
                }
                return FileVisitResult.CONTINUE;
            }

            @Override
            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) {
                String fileName = file.getFileName().toString();
                String relativePath = projectPath.relativize(file).toString();

                // Get file extension
                String extension = getFileExtension(fileName);

                if (CODE_EXTENSIONS.contains(extension.toLowerCase())) {
                    FileInfo fileInfo = new FileInfo();
                    fileInfo.path = relativePath;
                    fileInfo.name = fileName;
                    fileInfo.extension = extension;
                    fileInfo.size = attrs.size();
                    structure.fileTree.add(fileInfo);

                    // Update statistics
                    fileTypeCount.merge(extension, 1, Integer::sum);
                    fileTypeSize.merge(extension, attrs.size(), Long::sum);
                }

                return FileVisitResult.CONTINUE;
            }
        });

        structure.statistics.put("totalFiles", fileTypeCount.values().stream().mapToInt(Integer::intValue).sum());
        structure.statistics.put("fileTypes", fileTypeCount.size());
        structure.fileTypeCount = fileTypeCount;
        structure.fileTypeSize = fileTypeSize;

        return structure;
    }

    /**
     * Analyze key project files for context
     */
    private Map<String, String> analyzeKeyFiles(Path projectPath) {
        Map<String, String> keyFiles = new HashMap<>();

        // Common important files to analyze
        String[] importantFiles = {
            "README.md", "package.json", "pom.xml", "build.gradle", "requirements.txt",
            "Dockerfile", "docker-compose.yml", "application.yml", "application.properties",
            ".gitignore", "LICENSE", "CHANGELOG.md"
        };

        for (String fileName : importantFiles) {
            Path filePath = projectPath.resolve(fileName);
            if (Files.exists(filePath) && Files.isRegularFile(filePath)) {
                try {
                    String content = Files.readString(filePath);
                    // Limit content size for analysis
                    if (content.length() > 5000) {
                        content = content.substring(0, 5000) + "\n... (truncated)";
                    }
                    keyFiles.put(fileName, content);
                } catch (IOException e) {
                    logger.warn("Could not read file: {}", fileName, e);
                    keyFiles.put(fileName, "Error reading file: " + e.getMessage());
                }
            }
        }

        return keyFiles;
    }

    /**
     * Build README generation prompt
     */
    private String buildReadmePrompt(ProjectAnalysisResult analysis, String readmeType) {
        StringBuilder prompt = new StringBuilder();

        prompt.append("You are an expert technical writer. Generate a comprehensive README.md file for this project.\n\n");

        prompt.append("PROJECT ANALYSIS:\n");
        prompt.append("Path: ").append(analysis.projectPath).append("\n");
        prompt.append("Total Files: ").append(analysis.projectStructure.statistics.get("totalFiles")).append("\n");
        prompt.append("File Types: ").append(analysis.projectStructure.fileTypeCount.keySet()).append("\n\n");

        prompt.append("PROJECT STRUCTURE:\n");
        analysis.projectStructure.fileTree.stream()
            .limit(50) // Limit for prompt size
            .forEach(file -> prompt.append("- ").append(file.path).append("\n"));

        if (analysis.projectStructure.fileTree.size() > 50) {
            prompt.append("... and ").append(analysis.projectStructure.fileTree.size() - 50).append(" more files\n");
        }

        prompt.append("\nKEY FILES CONTENT:\n");
        analysis.keyFiles.forEach((fileName, content) -> {
            prompt.append("\n### ").append(fileName).append(":\n");
            prompt.append("```\n").append(content).append("\n```\n");
        });

        prompt.append("\nREADME TYPE: ").append(readmeType).append("\n");
        prompt.append("\nPlease generate a professional README.md with the following sections:\n");
        prompt.append("1. Project Title and Description\n");
        prompt.append("2. Features\n");
        prompt.append("3. Installation Instructions\n");
        prompt.append("4. Usage Examples\n");
        prompt.append("5. API Documentation (if applicable)\n");
        prompt.append("6. Contributing Guidelines\n");
        prompt.append("7. License Information\n\n");

        prompt.append("Make it comprehensive, professional, and user-friendly. Use proper Markdown formatting.\n");

        return prompt.toString();
    }

    /**
     * Build project review prompt
     */
    private String buildProjectReviewPrompt(ProjectAnalysisResult analysis) {
        StringBuilder prompt = new StringBuilder();

        prompt.append("You are an expert code reviewer. Perform a comprehensive analysis of this entire project.\n\n");

        prompt.append("PROJECT OVERVIEW:\n");
        prompt.append("Path: ").append(analysis.projectPath).append("\n");
        prompt.append("Total Files: ").append(analysis.projectStructure.statistics.get("totalFiles")).append("\n");
        prompt.append("Technologies: ").append(analysis.projectStructure.fileTypeCount.keySet()).append("\n\n");

        prompt.append("ARCHITECTURE ANALYSIS:\n");
        prompt.append("Please analyze the project structure and provide insights on:\n");
        prompt.append("1. Overall Architecture and Design Patterns\n");
        prompt.append("2. Code Organization and Structure\n");
        prompt.append("3. Technology Stack Assessment\n");
        prompt.append("4. Security Considerations\n");
        prompt.append("5. Performance Implications\n");
        prompt.append("6. Maintainability and Scalability\n");
        prompt.append("7. Best Practices Compliance\n");
        prompt.append("8. Potential Issues and Recommendations\n\n");

        prompt.append("PROJECT STRUCTURE:\n");
        analysis.projectStructure.fileTree.forEach(file ->
            prompt.append("- ").append(file.path).append(" (").append(file.extension).append(")\n"));

        prompt.append("\nKEY CONFIGURATION FILES:\n");
        analysis.keyFiles.forEach((fileName, content) -> {
            prompt.append("\n### ").append(fileName).append(":\n");
            prompt.append("```\n").append(content).append("\n```\n");
        });

        prompt.append("\nProvide a detailed analysis with specific recommendations for improvement.\n");

        return prompt.toString();
    }

    private String getFileExtension(String fileName) {
        int lastDotIndex = fileName.lastIndexOf('.');
        if (lastDotIndex > 0 && lastDotIndex < fileName.length() - 1) {
            return fileName.substring(lastDotIndex);
        }
        return "";
    }

    // Data classes for project analysis
    public static class ProjectAnalysisResult {
        public String projectPath;
        public ProjectStructure projectStructure;
        public Map<String, String> keyFiles;
        public String analysisType;
        public Date timestamp;
    }

    public static class ProjectStructure {
        public String rootPath;
        public List<FileInfo> fileTree;
        public Map<String, Object> statistics;
        public Map<String, Integer> fileTypeCount;
        public Map<String, Long> fileTypeSize;
    }

    public static class FileInfo {
        public String path;
        public String name;
        public String extension;
        public long size;
    }
}
---------------------
package com.codereview.manager.service;

import com.codereview.manager.model.Project;
import com.codereview.manager.model.Team;
import com.codereview.manager.repository.ProjectRepository;
import com.codereview.manager.repository.TeamRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

/**
 * Service class for managing projects within teams
 */
@Service
@Transactional
public class ProjectService {

    private static final Logger logger = LoggerFactory.getLogger(ProjectService.class);

    @Autowired
    private ProjectRepository projectRepository;

    @Autowired
    private TeamRepository teamRepository;

    /**
     * Get all active projects
     */
    @Transactional(readOnly = true)
    public List<Project> getAllActiveProjects() {
        logger.debug("Fetching all active projects");
        return projectRepository.findByActiveTrue();
    }

    /**
     * Get project by ID
     */
    @Transactional(readOnly = true)
    public Optional<Project> getProjectById(Long id) {
        logger.debug("Fetching project by ID: {}", id);
        return projectRepository.findById(id);
    }

    /**
     * Get projects by team ID
     */
    @Transactional(readOnly = true)
    public List<Project> getProjectsByTeamId(Long teamId) {
        logger.debug("Fetching projects for team ID: {}", teamId);
        return projectRepository.findByTeamIdAndActiveTrue(teamId);
    }

    /**
     * Get projects by team
     */
    @Transactional(readOnly = true)
    public List<Project> getProjectsByTeam(Team team) {
        logger.debug("Fetching projects for team: {}", team.getName());
        return projectRepository.findByTeamAndActiveTrue(team);
    }

    /**
     * Create a new project
     */
    public Project createProject(Project project) {
        logger.info("Creating new project: {} for team: {}", project.getName(), project.getTeam().getName());

        // Validate team exists and is active
        Team team = teamRepository.findById(project.getTeam().getId())
            .orElseThrow(() -> new IllegalArgumentException("Team not found with ID: " + project.getTeam().getId()));

        if (!team.getActive()) {
            throw new IllegalArgumentException("Cannot create project for inactive team: " + team.getName());
        }

        // Check if project name already exists within the team
        if (projectRepository.existsByNameAndTeam(project.getName(), team)) {
            throw new IllegalArgumentException("Project with name '" + project.getName() +
                "' already exists in team '" + team.getName() + "'");
        }

        project.setTeam(team);
        project.setCreatedDate(LocalDateTime.now());
        project.setLastModified(LocalDateTime.now());

        Project savedProject = projectRepository.save(project);
        logger.info("Project created successfully with ID: {}", savedProject.getId());
        return savedProject;
    }

    /**
     * Update an existing project
     */
    public Project updateProject(Long id, Project projectUpdate) {
        logger.info("Updating project with ID: {}", id);

        Project existingProject = projectRepository.findById(id)
            .orElseThrow(() -> new IllegalArgumentException("Project not found with ID: " + id));

        // Check if the new name conflicts with another project in the same team
        if (!existingProject.getName().equalsIgnoreCase(projectUpdate.getName()) &&
            projectRepository.existsByNameAndTeam(projectUpdate.getName(), existingProject.getTeam())) {
            throw new IllegalArgumentException("Project with name '" + projectUpdate.getName() +
                "' already exists in team '" + existingProject.getTeam().getName() + "'");
        }

        // Update fields
        existingProject.setName(projectUpdate.getName());
        existingProject.setDescription(projectUpdate.getDescription());
        existingProject.setRepositoryUrl(projectUpdate.getRepositoryUrl());
        existingProject.setBranchName(projectUpdate.getBranchName());
        existingProject.setActive(projectUpdate.getActive());
        existingProject.setLastModified(LocalDateTime.now());

        Project updatedProject = projectRepository.save(existingProject);
        logger.info("Project updated successfully: {}", updatedProject.getId());
        return updatedProject;
    }

    /**
     * Delete a project (soft delete - set active to false)
     */
    public void deleteProject(Long id) {
        logger.info("Deleting project with ID: {}", id);

        Project project = projectRepository.findById(id)
            .orElseThrow(() -> new IllegalArgumentException("Project not found with ID: " + id));

        project.setActive(false);
        project.setLastModified(LocalDateTime.now());
        projectRepository.save(project);

        logger.info("Project marked as inactive: {}", id);
    }

    /**
     * Search projects by name or description
     */
    @Transactional(readOnly = true)
    public List<Project> searchProjects(String searchTerm) {
        logger.debug("Searching projects with term: {}", searchTerm);
        if (searchTerm == null || searchTerm.trim().isEmpty()) {
            return getAllActiveProjects();
        }
        return projectRepository.searchProjects(searchTerm);
    }

    /**
     * Search projects within a team
     */
    @Transactional(readOnly = true)
    public List<Project> searchProjectsByTeam(Long teamId, String searchTerm) {
        logger.debug("Searching projects for team {} with term: {}", teamId, searchTerm);
        if (searchTerm == null || searchTerm.trim().isEmpty()) {
            return getProjectsByTeamId(teamId);
        }
        return projectRepository.searchProjectsByTeam(teamId, searchTerm);
    }

    /**
     * Get count of active projects
     */
    @Transactional(readOnly = true)
    public long getActiveProjectsCount() {
        return projectRepository.countActiveProjects();
    }

    /**
     * Get count of active projects by team
     */
    @Transactional(readOnly = true)
    public long getActiveProjectsCountByTeam(Team team) {
        return projectRepository.countActiveProjectsByTeam(team);
    }

    /**
     * Get projects with submission counts
     */
    @Transactional(readOnly = true)
    public List<Object[]> getProjectsWithSubmissionCounts() {
        logger.debug("Fetching projects with submission counts");
        return projectRepository.findProjectsWithSubmissionCount();
    }

    /**
     * Validate project data
     */
    public void validateProject(Project project) {
        if (project.getName() == null || project.getName().trim().isEmpty()) {
            throw new IllegalArgumentException("Project name is required");
        }

        if (project.getName().length() > 100) {
            throw new IllegalArgumentException("Project name cannot exceed 100 characters");
        }

        if (project.getDescription() != null && project.getDescription().length() > 1000) {
            throw new IllegalArgumentException("Project description cannot exceed 1000 characters");
        }

        if (project.getTeam() == null || project.getTeam().getId() == null) {
            throw new IllegalArgumentException("Project must be assigned to a team");
        }

        // Validate repository URL format if provided
        if (project.getRepositoryUrl() != null && !project.getRepositoryUrl().isEmpty()) {
            if (!isValidUrl(project.getRepositoryUrl())) {
                throw new IllegalArgumentException("Invalid repository URL format");
            }
        }

        // Validate branch name if provided
        if (project.getBranchName() != null && project.getBranchName().trim().isEmpty()) {
            project.setBranchName("main"); // Set default branch name
        }
    }

    /**
     * Simple URL validation
     */
    private boolean isValidUrl(String url) {
        try {
            new java.net.URL(url);
            return true;
        } catch (Exception e) {
            return false;
        }
    }

    /**
     * Get project by name and team
     */
    @Transactional(readOnly = true)
    public Optional<Project> getProjectByNameAndTeam(String projectName, String teamName) {
        logger.debug("Fetching project {} in team {}", projectName, teamName);

        Optional<Team> team = teamRepository.findByNameIgnoreCase(teamName);
        if (team.isEmpty()) {
            return Optional.empty();
        }

        return projectRepository.findByNameAndTeam(projectName, team.get());
    }
}
-----------------------
package com.codereview.manager.service;

import com.codereview.manager.model.Prompt;
import com.codereview.manager.model.Category;
import com.codereview.manager.repository.PromptRepository;
import com.codereview.manager.repository.CategoryRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Optional;

/**
 * Service class for managing Prompt operations
 * Contains business logic for prompt management
 */
@Service
public class PromptService {

    private final PromptRepository promptRepository;
    private final CategoryRepository categoryRepository;

    @Autowired
    public PromptService(PromptRepository promptRepository, CategoryRepository categoryRepository) {
        this.promptRepository = promptRepository;
        this.categoryRepository = categoryRepository;
    }

    /**
     * Get all active prompts ordered by creation date
     * @return list of active prompts
     */
    public List<Prompt> getAllActivePrompts() {
        return promptRepository.findByIsActiveTrueOrderByCreatedAtDesc();
    }

    /**
     * Get all prompts (including inactive) ordered by creation date
     * @return list of all prompts
     */
    public List<Prompt> getAllPrompts() {
        return promptRepository.findAllByOrderByCreatedAtDesc();
    }

    /**
     * Get a prompt by ID
     * @param id the prompt ID
     * @return Optional containing the prompt if found
     */
    public Optional<Prompt> getPromptById(Long id) {
        return promptRepository.findById(id);
    }

    /**
     * Get active prompts by category ID
     * @param categoryId the category ID
     * @return list of active prompts in the category
     */
    public List<Prompt> getActivePromptsByCategory(Long categoryId) {
        return promptRepository.findByCategoryIdAndIsActiveTrueOrderByCreatedAtDesc(categoryId);
    }

    /**
     * Get all prompts by category ID
     * @param categoryId the category ID
     * @return list of prompts in the category
     */
    public List<Prompt> getPromptsByCategory(Long categoryId) {
        return promptRepository.findByCategoryIdOrderByCreatedAtDesc(categoryId);
    }

    /**
     * Create a new prompt
     * @param prompt the prompt to create
     * @return the created prompt
     * @throws IllegalArgumentException if category doesn't exist
     */
    public Prompt createPrompt(Prompt prompt) {
        // Validate that category exists
        if (prompt.getCategory() != null && prompt.getCategory().getId() != null) {
            Optional<Category> category = categoryRepository.findById(prompt.getCategory().getId());
            if (category.isEmpty()) {
                throw new IllegalArgumentException("Category with ID " + prompt.getCategory().getId() + " not found");
            }
            prompt.setCategory(category.get());
        } else {
            throw new IllegalArgumentException("Category is required for creating a prompt");
        }

        return promptRepository.save(prompt);
    }

    /**
     * Update an existing prompt
     * @param id the prompt ID
     * @param updatedPrompt the updated prompt data
     * @return the updated prompt
     * @throws IllegalArgumentException if prompt or category not found
     */
    public Prompt updatePrompt(Long id, Prompt updatedPrompt) {
        Optional<Prompt> existingPrompt = promptRepository.findById(id);

        if (existingPrompt.isEmpty()) {
            throw new IllegalArgumentException("Prompt with ID " + id + " not found");
        }

        Prompt prompt = existingPrompt.get();

        // Validate that category exists if provided
        if (updatedPrompt.getCategory() != null && updatedPrompt.getCategory().getId() != null) {
            Optional<Category> category = categoryRepository.findById(updatedPrompt.getCategory().getId());
            if (category.isEmpty()) {
                throw new IllegalArgumentException("Category with ID " + updatedPrompt.getCategory().getId() + " not found");
            }
            prompt.setCategory(category.get());
        }

        // Update prompt fields
        prompt.setTitle(updatedPrompt.getTitle());
        prompt.setContent(updatedPrompt.getContent());
        prompt.setDescription(updatedPrompt.getDescription());

        if (updatedPrompt.getIsActive() != null) {
            prompt.setIsActive(updatedPrompt.getIsActive());
        }

        if (updatedPrompt.getUpdatedBy() != null) {
            prompt.setUpdatedBy(updatedPrompt.getUpdatedBy());
        }

        return promptRepository.save(prompt);
    }

    /**
     * Delete a prompt by ID
     * @param id the prompt ID
     * @throws IllegalArgumentException if prompt not found
     */
    public void deletePrompt(Long id) {
        if (!promptRepository.existsById(id)) {
            throw new IllegalArgumentException("Prompt with ID " + id + " not found");
        }

        promptRepository.deleteById(id);
    }

    /**
     * Activate or deactivate a prompt
     * @param id the prompt ID
     * @param active true to activate, false to deactivate
     * @return the updated prompt
     * @throws IllegalArgumentException if prompt not found
     */
    public Prompt setPromptActive(Long id, boolean active) {
        Optional<Prompt> existingPrompt = promptRepository.findById(id);

        if (existingPrompt.isEmpty()) {
            throw new IllegalArgumentException("Prompt with ID " + id + " not found");
        }

        Prompt prompt = existingPrompt.get();
        prompt.setIsActive(active);

        return promptRepository.save(prompt);
    }

    /**
     * Search active prompts by text
     * @param searchText the text to search for
     * @return list of matching active prompts
     */
    public List<Prompt> searchActivePrompts(String searchText) {
        if (searchText == null || searchText.trim().isEmpty()) {
            return getAllActivePrompts();
        }

        return promptRepository.searchActivePrompts(searchText.trim());
    }

    /**
     * Get count of active prompts
     * @return number of active prompts
     */
    public long getActivePromptCount() {
        return promptRepository.countByIsActiveTrue();
    }

    /**
     * Get count of prompts in a category
     * @param categoryId the category ID
     * @return number of prompts in the category
     */
    public long getPromptCountByCategory(Long categoryId) {
        Optional<Category> category = categoryRepository.findById(categoryId);
        if (category.isPresent()) {
            return promptRepository.countByCategory(category.get());
        }
        return 0;
    }
}
--------------------
package com.codereview.manager.service;

import com.codereview.manager.model.Team;
import com.codereview.manager.repository.TeamRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

/**
 * Service class for managing teams
 */
@Service
@Transactional
public class TeamService {

    private static final Logger logger = LoggerFactory.getLogger(TeamService.class);

    @Autowired
    private TeamRepository teamRepository;

    /**
     * Get all active teams
     */
    @Transactional(readOnly = true)
    public List<Team> getAllActiveTeams() {
        logger.debug("Fetching all active teams");
        return teamRepository.findByActiveTrue();
    }

    /**
     * Get team by ID
     */
    @Transactional(readOnly = true)
    public Optional<Team> getTeamById(Long id) {
        logger.debug("Fetching team by ID: {}", id);
        return teamRepository.findById(id);
    }

    /**
     * Get team by name
     */
    @Transactional(readOnly = true)
    public Optional<Team> getTeamByName(String name) {
        logger.debug("Fetching team by name: {}", name);
        return teamRepository.findByNameIgnoreCase(name);
    }

    /**
     * Create a new team
     */
    public Team createTeam(Team team) {
        logger.info("Creating new team: {}", team.getName());

        // Check if team name already exists
        if (teamRepository.existsByNameIgnoreCase(team.getName())) {
            throw new IllegalArgumentException("Team with name '" + team.getName() + "' already exists");
        }

        team.setCreatedDate(LocalDateTime.now());
        team.setLastModified(LocalDateTime.now());

        Team savedTeam = teamRepository.save(team);
        logger.info("Team created successfully with ID: {}", savedTeam.getId());
        return savedTeam;
    }

    /**
     * Update an existing team
     */
    public Team updateTeam(Long id, Team teamUpdate) {
        logger.info("Updating team with ID: {}", id);

        Team existingTeam = teamRepository.findById(id)
            .orElseThrow(() -> new IllegalArgumentException("Team not found with ID: " + id));

        // Check if the new name conflicts with another team
        if (!existingTeam.getName().equalsIgnoreCase(teamUpdate.getName()) &&
            teamRepository.existsByNameIgnoreCase(teamUpdate.getName())) {
            throw new IllegalArgumentException("Team with name '" + teamUpdate.getName() + "' already exists");
        }

        // Update fields
        existingTeam.setName(teamUpdate.getName());
        existingTeam.setDescription(teamUpdate.getDescription());
        existingTeam.setTeamLeadEmail(teamUpdate.getTeamLeadEmail());
        existingTeam.setNotificationEmails(teamUpdate.getNotificationEmails());
        existingTeam.setActive(teamUpdate.getActive());
        existingTeam.setLastModified(LocalDateTime.now());

        Team updatedTeam = teamRepository.save(existingTeam);
        logger.info("Team updated successfully: {}", updatedTeam.getId());
        return updatedTeam;
    }

    /**
     * Delete a team (soft delete - set active to false)
     */
    public void deleteTeam(Long id) {
        logger.info("Deleting team with ID: {}", id);

        Team team = teamRepository.findById(id)
            .orElseThrow(() -> new IllegalArgumentException("Team not found with ID: " + id));

        team.setActive(false);
        team.setLastModified(LocalDateTime.now());
        teamRepository.save(team);

        logger.info("Team marked as inactive: {}", id);
    }

    /**
     * Search teams by name or description
     */
    @Transactional(readOnly = true)
    public List<Team> searchTeams(String searchTerm) {
        logger.debug("Searching teams with term: {}", searchTerm);
        if (searchTerm == null || searchTerm.trim().isEmpty()) {
            return getAllActiveTeams();
        }
        return teamRepository.searchTeams(searchTerm);
    }

    /**
     * Get teams by team lead email
     */
    @Transactional(readOnly = true)
    public List<Team> getTeamsByTeamLead(String teamLeadEmail) {
        logger.debug("Fetching teams by team lead: {}", teamLeadEmail);
        return teamRepository.findByTeamLeadEmailAndActiveTrue(teamLeadEmail);
    }

    /**
     * Get count of active teams
     */
    @Transactional(readOnly = true)
    public long getActiveTeamsCount() {
        return teamRepository.countActiveTeams();
    }

    /**
     * Get teams with project counts
     */
    @Transactional(readOnly = true)
    public List<Object[]> getTeamsWithProjectCounts() {
        logger.debug("Fetching teams with project counts");
        return teamRepository.findTeamsWithProjectCount();
    }

    /**
     * Validate team data
     */
    public void validateTeam(Team team) {
        if (team.getName() == null || team.getName().trim().isEmpty()) {
            throw new IllegalArgumentException("Team name is required");
        }

        if (team.getName().length() > 100) {
            throw new IllegalArgumentException("Team name cannot exceed 100 characters");
        }

        if (team.getDescription() != null && team.getDescription().length() > 1000) {
            throw new IllegalArgumentException("Team description cannot exceed 1000 characters");
        }

        // Validate email format if provided
        if (team.getTeamLeadEmail() != null && !team.getTeamLeadEmail().isEmpty()) {
            if (!isValidEmail(team.getTeamLeadEmail())) {
                throw new IllegalArgumentException("Invalid team lead email format");
            }
        }

        // Validate notification emails if provided
        if (team.getNotificationEmails() != null && !team.getNotificationEmails().isEmpty()) {
            String[] emails = team.getNotificationEmails().split(",");
            for (String email : emails) {
                String trimmedEmail = email.trim();
                if (!trimmedEmail.isEmpty() && !isValidEmail(trimmedEmail)) {
                    throw new IllegalArgumentException("Invalid notification email format: " + trimmedEmail);
                }
            }
        }
    }

    /**
     * Simple email validation
     */
    private boolean isValidEmail(String email) {
        return email != null && email.matches("^[A-Za-z0-9+_.-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}$");
    }
}
-------------------
package com.codereview.manager;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

/**
 * Main application class for Code Review Manager
 * This is the entry point of the Spring Boot application
 */
@SpringBootApplication
public class CodeReviewManagerApplication {

    /**
     * Main method to start the application
     * @param args command line arguments
     */
    public static void main(String[] args) {
        SpringApplication.run(CodeReviewManagerApplication.class, args);
        System.out.println("Code Review Manager application started successfully!");
        System.out.println("Access the application at: http://localhost:8080/api");
        System.out.println("H2 Console available at: http://localhost:8080/api/h2-console");
    }
}
---------------------------
# Server Configuration
server:
  port: 8081
  servlet:
    context-path: /api

# Spring Configuration
spring:
  application:
    name: code-review-ai

  # Database Configuration (H2 in-memory for development)
  datasource:
    url: jdbc:h2:mem:testdb
    driverClassName: org.h2.Driver
    username: sa
    password: ""

  # H2 Console (for development/debugging)
  h2:
    console:
      enabled: true
      path: /h2-console

  # JPA Configuration
  jpa:
    database-platform: org.hibernate.dialect.H2Dialect
    hibernate:
      ddl-auto: create-drop
    show-sql: true
    properties:
      hibernate:
        format_sql: true

  # JSON Configuration
  jackson:
    default-property-inclusion: NON_NULL

  # Spring AI Anthropic Configuration
  ai:
    anthropic:
      api-key: ${ANTHROPIC_API_KEY:your-anthropic-api-key-here}
      chat:
        options:
          model: claude-sonnet-4-5-20250929
          temperature: 0.2
          max-tokens: 4000

# Logging Configuration
logging:
  level:
    com.codereview.manager: DEBUG
    org.springframework.web: INFO
    org.springframework.ai: DEBUG
  pattern:
    console: "%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n"
    -------------------------------