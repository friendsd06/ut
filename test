package com.yourcompany.config.mybatis;

import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;

import java.lang.reflect.Method;
import java.lang.reflect.Parameter;
import java.sql.Time;
import java.sql.Timestamp;
import java.text.SimpleDateFormat;
import java.time.*;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

/**
 * MyBatis SQL Logging Aspect
 *
 * Features:
 * - Logs executable SQL queries that can be copied and run directly
 * - Handles all Java types and collections
 * - Configurable logging levels and formatting
 * - Performance optimized with caching
 */
@Aspect
@Component
public class SqlLoggingAspect {

    private static final Logger logger = LoggerFactory.getLogger(SqlLoggingAspect.class);

    // Thread-safe caches for performance
    private static final Map<Class<?>, Boolean> SIMPLE_TYPE_CACHE = new ConcurrentHashMap<>();

    // Date formatters - thread-safe in Java 8+
    private static final DateTimeFormatter DATETIME_FORMATTER = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
    private static final DateTimeFormatter DATE_FORMATTER = DateTimeFormatter.ofPattern("yyyy-MM-dd");
    private static final DateTimeFormatter TIME_FORMATTER = DateTimeFormatter.ofPattern("HH:mm:ss");
    private static final SimpleDateFormat LEGACY_DATETIME_FORMAT = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
    private static final SimpleDateFormat LEGACY_DATE_FORMAT = new SimpleDateFormat("yyyy-MM-dd");
    private static final SimpleDateFormat LEGACY_TIME_FORMAT = new SimpleDateFormat("HH:mm:ss");

    // Configuration properties
    @Value("${mybatis.sql.logging.enabled:true}")
    private boolean sqlLoggingEnabled;

    @Value("${mybatis.sql.logging.slow-query-threshold:1000}")
    private long slowQueryThreshold;

    @Value("${mybatis.sql.logging.format-sql:true}")
    private boolean formatSql;

    @Value("${mybatis.sql.logging.max-sql-length:10000}")
    private int maxSqlLength;

    @Value("${mybatis.sql.logging.exclude-mappers:}")
    private String excludeMappers;

    private Set<String> excludeMapperSet;

    /**
     * Intercept all MyBatis mapper method calls
     */
    @Around("execution(* *..*Mapper.*(..))")
    public Object logSqlExecution(ProceedingJoinPoint joinPoint) throws Throwable {
        if (!sqlLoggingEnabled) {
            return joinPoint.proceed();
        }

        initializeExcludeMappers();

        String methodName = getFullMethodName(joinPoint);

        // Check if this mapper should be excluded
        if (shouldExcludeMapper(methodName)) {
            return joinPoint.proceed();
        }

        long startTime = System.nanoTime();
        Object result = null;
        Exception exception = null;

        try {
            result = joinPoint.proceed();
            return result;
        } catch (Exception e) {
            exception = e;
            throw e;
        } finally {
            try {
                logExecutableSql(joinPoint, methodName, startTime, result, exception);
            } catch (Exception e) {
                logger.warn("Failed to log SQL execution: {}", e.getMessage());
            }
        }
    }

    private void initializeExcludeMappers() {
        if (excludeMapperSet == null && StringUtils.hasText(excludeMappers)) {
            excludeMapperSet = new HashSet<>(Arrays.asList(excludeMappers.split(",")));
        }
    }

    private String getFullMethodName(ProceedingJoinPoint joinPoint) {
        return joinPoint.getTarget().getClass().getName() + "." + joinPoint.getSignature().getName();
    }

    private boolean shouldExcludeMapper(String methodName) {
        if (excludeMapperSet == null || excludeMapperSet.isEmpty()) {
            return false;
        }
        return excludeMapperSet.stream().anyMatch(methodName::contains);
    }

    private void logExecutableSql(ProceedingJoinPoint joinPoint, String methodName, long startTime, Object result, Exception exception) {
        long executionTime = (System.nanoTime() - startTime) / 1_000_000; // Convert to ms

        // Build executable SQL from method and parameters
        String executableSql = buildExecutableSqlFromMethod(joinPoint);

        // Truncate if too long
        if (executableSql.length() > maxSqlLength) {
            executableSql = executableSql.substring(0, maxSqlLength) + "... [TRUNCATED]";
        }

        logFormattedSql(methodName, executableSql, executionTime, result, exception);
    }

    /**
     * Build executable SQL by analyzing method annotations and parameters
     */
    private String buildExecutableSqlFromMethod(ProceedingJoinPoint joinPoint) {
        try {
            Method method = ((org.aspectj.lang.reflect.MethodSignature) joinPoint.getSignature()).getMethod();
            Object[] args = joinPoint.getArgs();

            // Try to get SQL from @Select, @Insert, @Update, @Delete annotations
            String sql = extractSqlFromAnnotations(method);

            if (sql != null && !sql.isEmpty()) {
                return replacePlaceholdersWithValues(sql, method.getParameters(), args);
            }

            // Fallback: show method call with parameters
            return buildMethodCallSql(joinPoint.getSignature().getName(), method.getParameters(), args);

        } catch (Exception e) {
            return "-- Unable to extract SQL: " + e.getMessage();
        }
    }

    /**
     * Extract SQL from MyBatis annotations including SQL providers
     */
    private String extractSqlFromAnnotations(Method method) {
        // Check for @Select annotation
        org.apache.ibatis.annotations.Select select = method.getAnnotation(org.apache.ibatis.annotations.Select.class);
        if (select != null && select.value().length > 0) {
            return String.join(" ", select.value());
        }

        // Check for @Insert annotation
        org.apache.ibatis.annotations.Insert insert = method.getAnnotation(org.apache.ibatis.annotations.Insert.class);
        if (insert != null && insert.value().length > 0) {
            return String.join(" ", insert.value());
        }

        // Check for @Update annotation
        org.apache.ibatis.annotations.Update update = method.getAnnotation(org.apache.ibatis.annotations.Update.class);
        if (update != null && update.value().length > 0) {
            return String.join(" ", update.value());
        }

        // Check for @Delete annotation
        org.apache.ibatis.annotations.Delete delete = method.getAnnotation(org.apache.ibatis.annotations.Delete.class);
        if (delete != null && delete.value().length > 0) {
            return String.join(" ", delete.value());
        }

        // Check for SQL Provider annotations
        String providerSql = extractSqlFromProviders(method);
        if (providerSql != null) {
            return providerSql;
        }

        return null; // SQL is in XML mapper file
    }

    /**
     * Extract SQL from provider annotations (@SelectProvider, @InsertProvider, etc.)
     */
    private String extractSqlFromProviders(Method method) {
        try {
            // Check for @SelectProvider
            org.apache.ibatis.annotations.SelectProvider selectProvider = method.getAnnotation(org.apache.ibatis.annotations.SelectProvider.class);
            if (selectProvider != null) {
                return generateSqlFromProvider(selectProvider.type(), selectProvider.method(), method);
            }

            // Check for @InsertProvider
            org.apache.ibatis.annotations.InsertProvider insertProvider = method.getAnnotation(org.apache.ibatis.annotations.InsertProvider.class);
            if (insertProvider != null) {
                return generateSqlFromProvider(insertProvider.type(), insertProvider.method(), method);
            }

            // Check for @UpdateProvider
            org.apache.ibatis.annotations.UpdateProvider updateProvider = method.getAnnotation(org.apache.ibatis.annotations.UpdateProvider.class);
            if (updateProvider != null) {
                return generateSqlFromProvider(updateProvider.type(), updateProvider.method(), method);
            }

            // Check for @DeleteProvider
            org.apache.ibatis.annotations.DeleteProvider deleteProvider = method.getAnnotation(org.apache.ibatis.annotations.DeleteProvider.class);
            if (deleteProvider != null) {
                return generateSqlFromProvider(deleteProvider.type(), deleteProvider.method(), method);
            }

        } catch (Exception e) {
            logger.debug("Failed to extract SQL from provider: {}", e.getMessage());
        }

        return null;
    }

    /**
     * Generate SQL by calling the provider method
     */
    private String generateSqlFromProvider(Class<?> providerClass, String providerMethodName, Method originalMethod) {
        try {
            // Create instance of provider class
            Object providerInstance = providerClass.getDeclaredConstructor().newInstance();

            // Find the provider method
            Method providerMethod = findProviderMethod(providerClass, providerMethodName, originalMethod);
            if (providerMethod == null) {
                return "-- Provider method not found: " + providerClass.getSimpleName() + "." + providerMethodName;
            }

            // Call provider method to generate SQL
            Object sqlResult = null;

            // Handle different provider method signatures
            if (providerMethod.getParameterCount() == 0) {
                // No parameters
                sqlResult = providerMethod.invoke(providerInstance);
            } else if (providerMethod.getParameterCount() == 1) {
                // Single parameter - usually Map or specific type
                Map<String, Object> context = new HashMap<>();
                context.put("method", originalMethod.getName());
                context.put("class", originalMethod.getDeclaringClass().getSimpleName());
                sqlResult = providerMethod.invoke(providerInstance, context);
            } else {
                // Multiple parameters - try with context map
                Object[] args = new Object[providerMethod.getParameterCount()];
                Arrays.fill(args, new HashMap<String, Object>());
                sqlResult = providerMethod.invoke(providerInstance, args);
            }

            if (sqlResult instanceof String) {
                return (String) sqlResult;
            } else if (sqlResult != null) {
                return sqlResult.toString();
            }

        } catch (Exception e) {
            logger.debug("Failed to generate SQL from provider {}.{}: {}",
                providerClass.getSimpleName(), providerMethodName, e.getMessage());
            return "-- SQL Provider: " + providerClass.getSimpleName() + "." + providerMethodName + "() [Error: " + e.getMessage() + "]";
        }

        return "-- SQL Provider: " + providerClass.getSimpleName() + "." + providerMethodName + "()";
    }

    /**
     * Find the provider method by name and compatible signature
     */
    private Method findProviderMethod(Class<?> providerClass, String methodName, Method originalMethod) {
        Method[] methods = providerClass.getDeclaredMethods();

        // First try to find exact method name
        for (Method method : methods) {
            if (method.getName().equals(methodName)) {
                method.setAccessible(true);
                return method;
            }
        }

        // If not found, try case-insensitive search
        for (Method method : methods) {
            if (method.getName().equalsIgnoreCase(methodName)) {
                method.setAccessible(true);
                return method;
            }
        }

        return null;
    }

    /**
     * Replace #{} and ${} placeholders with actual parameter values
     */
    private String replacePlaceholdersWithValues(String sql, Parameter[] parameters, Object[] args) {
        if (parameters == null || args == null || parameters.length != args.length) {
            return sql;
        }

        String result = sql;

        for (int i = 0; i < parameters.length; i++) {
            String paramName = parameters[i].getName();
            Object paramValue = args[i];
            String formattedValue = formatParameterValue(paramValue);

            // Replace #{paramName} and ${paramName} with actual values
            result = result.replaceAll("#\\{" + paramName + "\\}", formattedValue);
            result = result.replaceAll("\\$\\{" + paramName + "\\}", formattedValue);
        }

        // Also handle ? placeholders (prepared statement style)
        for (Object arg : args) {
            if (result.contains("?")) {
                String formattedValue = formatParameterValue(arg);
                result = result.replaceFirst("\\?", formattedValue);
            }
        }

        return result;
    }

    /**
     * Build method call representation when SQL extraction fails
     */
    private String buildMethodCallSql(String methodName, Parameter[] parameters, Object[] args) {
        StringBuilder sb = new StringBuilder();
        sb.append("-- Method Call: ").append(methodName).append("(");

        if (parameters != null && args != null && parameters.length > 0) {
            for (int i = 0; i < parameters.length && i < args.length; i++) {
                if (i > 0) sb.append(", ");
                sb.append(parameters[i].getName()).append("=").append(formatParameterValue(args[i]));
            }
        }

        sb.append(")");
        return sb.toString();
    }

    /**
     * Format parameter values for direct SQL execution
     */
    private String formatParameterValue(Object value) {
        if (value == null) {
            return "NULL";
        }

        // Handle primitives and numbers
        if (isSimpleType(value.getClass())) {
            return formatSimpleType(value);
        }

        // Handle collections and arrays
        if (value instanceof Collection) {
            return formatCollection((Collection<?>) value);
        }

        if (value.getClass().isArray()) {
            return formatArray(value);
        }

        // Handle dates and times
        if (value instanceof java.util.Date) {
            return formatLegacyDate((java.util.Date) value);
        }

        if (value instanceof LocalDateTime) {
            return "'" + ((LocalDateTime) value).format(DATETIME_FORMATTER) + "'";
        }

        if (value instanceof LocalDate) {
            return "'" + ((LocalDate) value).format(DATE_FORMATTER) + "'";
        }

        if (value instanceof LocalTime) {
            return "'" + ((LocalTime) value).format(TIME_FORMATTER) + "'";
        }

        if (value instanceof Instant) {
            return "'" + LocalDateTime.ofInstant((Instant) value, ZoneId.systemDefault()).format(DATETIME_FORMATTER) + "'";
        }

        if (value instanceof ZonedDateTime) {
            return "'" + ((ZonedDateTime) value).format(DATETIME_FORMATTER) + "'";
        }

        if (value instanceof OffsetDateTime) {
            return "'" + ((OffsetDateTime) value).format(DATETIME_FORMATTER) + "'";
        }

        // Handle enum
        if (value instanceof Enum) {
            return "'" + ((Enum<?>) value).name() + "'";
        }

        // Default: treat as string
        return "'" + escapeSqlString(value.toString()) + "'";
    }

    private boolean isSimpleType(Class<?> clazz) {
        return SIMPLE_TYPE_CACHE.computeIfAbsent(clazz, this::checkSimpleType);
    }

    private boolean checkSimpleType(Class<?> clazz) {
        return clazz.isPrimitive() ||
               Number.class.isAssignableFrom(clazz) ||
               Boolean.class == clazz ||
               String.class == clazz ||
               Character.class == clazz;
    }

    private String formatSimpleType(Object value) {
        if (value instanceof String) {
            return "'" + escapeSqlString((String) value) + "'";
        }

        if (value instanceof Character) {
            return "'" + escapeSqlString(value.toString()) + "'";
        }

        if (value instanceof Boolean) {
            return ((Boolean) value) ? "1" : "0";
        }

        // Numbers (Integer, Long, Double, BigDecimal, etc.)
        return value.toString();
    }

    private String formatCollection(Collection<?> collection) {
        if (collection.isEmpty()) {
            return "()";
        }

        StringBuilder sb = new StringBuilder("(");
        Iterator<?> iterator = collection.iterator();

        while (iterator.hasNext()) {
            sb.append(formatParameterValue(iterator.next()));
            if (iterator.hasNext()) {
                sb.append(", ");
            }
        }

        sb.append(")");
        return sb.toString();
    }

    private String formatArray(Object array) {
        List<Object> list = new ArrayList<>();

        if (array instanceof Object[]) {
            Collections.addAll(list, (Object[]) array);
        } else if (array instanceof int[]) {
            for (int i : (int[]) array) list.add(i);
        } else if (array instanceof long[]) {
            for (long l : (long[]) array) list.add(l);
        } else if (array instanceof double[]) {
            for (double d : (double[]) array) list.add(d);
        } else if (array instanceof float[]) {
            for (float f : (float[]) array) list.add(f);
        } else if (array instanceof boolean[]) {
            for (boolean b : (boolean[]) array) list.add(b);
        } else if (array instanceof char[]) {
            for (char c : (char[]) array) list.add(c);
        } else if (array instanceof byte[]) {
            for (byte b : (byte[]) array) list.add(b);
        } else if (array instanceof short[]) {
            for (short s : (short[]) array) list.add(s);
        }

        return formatCollection(list);
    }

    private String formatLegacyDate(java.util.Date date) {
        synchronized (LEGACY_DATETIME_FORMAT) {
            if (date instanceof java.sql.Date) {
                return "'" + LEGACY_DATE_FORMAT.format(date) + "'";
            } else if (date instanceof Time) {
                return "'" + LEGACY_TIME_FORMAT.format(date) + "'";
            } else if (date instanceof Timestamp) {
                return "'" + LEGACY_DATETIME_FORMAT.format(date) + "'";
            } else {
                return "'" + LEGACY_DATETIME_FORMAT.format(date) + "'";
            }
        }
    }

    private String escapeSqlString(String value) {
        if (value == null) {
            return "";
        }
        // Escape single quotes by doubling them
        return value.replace("'", "''");
    }

    private void logFormattedSql(String methodName, String executableSql, long executionTime, Object result, Exception exception) {
        StringBuilder logMessage = new StringBuilder();

        // Header
        logMessage.append("\n").append("=".repeat(80)).append("\n");
        logMessage.append("Mapper Method: ").append(methodName).append("\n");
        logMessage.append("Execution Time: ").append(executionTime).append(" ms");

        if (executionTime > slowQueryThreshold) {
            logMessage.append(" [SLOW QUERY]");
        }
        logMessage.append("\n");

        // Status
        if (exception != null) {
            logMessage.append("Status: FAILED - ").append(exception.getClass().getSimpleName()).append("\n");
            logMessage.append("Error: ").append(exception.getMessage()).append("\n");
        } else {
            logMessage.append("Status: SUCCESS");
            if (result != null) {
                logMessage.append(" (").append(getResultCount(result)).append(" rows)");
            }
            logMessage.append("\n");
        }

        // SQL
        logMessage.append("\nExecutable SQL:\n");
        if (formatSql && !executableSql.startsWith("-- Method Call:")) {
            logMessage.append(formatSqlForReadability(executableSql));
        } else {
            logMessage.append(executableSql.replaceAll("\\s+", " ").trim());
        }

        logMessage.append("\n").append("=".repeat(80));

        // Log at appropriate level
        if (exception != null) {
            logger.error(logMessage.toString());
        } else if (executionTime > slowQueryThreshold) {
            logger.warn(logMessage.toString());
        } else {
            logger.info(logMessage.toString());
        }
    }

    private String getResultCount(Object result) {
        if (result instanceof Collection) {
            return String.valueOf(((Collection<?>) result).size());
        } else if (result instanceof Integer) {
            return String.valueOf(result);
        } else if (result != null) {
            return "1";
        }
        return "0";
    }

    private String formatSqlForReadability(String sql) {
        if (!formatSql || sql == null) {
            return sql;
        }

        return sql
            .replaceAll("(?i)\\b(SELECT|FROM|WHERE|AND|OR|ORDER\\s+BY|GROUP\\s+BY|HAVING|LIMIT|OFFSET|INSERT|UPDATE|DELETE|SET|VALUES|INTO|JOIN|LEFT\\s+JOIN|RIGHT\\s+JOIN|INNER\\s+JOIN|ON)\\b", "\n$1")
            .replaceAll("\\s+", " ")
            .replaceAll("\n ", "\n")
            .trim();
    }
}

/**
 * Configuration to enable AspectJ and register the SQL logging aspect
 */
@org.springframework.context.annotation.Configuration
@org.springframework.context.annotation.EnableAspectJAutoProxy
public class SqlLoggingAspectConfig {

    @org.springframework.context.annotation.Bean
    public SqlLoggingAspect sqlLoggingAspect() {
        return new SqlLoggingAspect();
    }
}

-------------------------
mybatis:
  sql:
    logging:
      enabled: true
      slow-query-threshold: 1000
      format-sql: true
      max-sql-length: 10000
      exclude-mappers: ""

logging:
  level:
    com.yourcompany.config.mybatis.SqlLoggingAspect: INFO
    org.apache.ibatis: WARN

spring:
  aop:
    auto: true
    proxy-target-class: true

    -----------------
    ---


package com.yourcompany.config.mybatis;

import org.apache.ibatis.annotations.*;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.Signature;
import org.aspectj.lang.reflect.MethodSignature;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.Arguments;
import org.junit.jupiter.params.provider.MethodSource;
import org.junit.jupiter.params.provider.ValueSource;
import org.mockito.ArgumentCaptor;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.mockito.junit.jupiter.MockitoExtension;
import org.slf4j.Logger;
import org.springframework.test.util.ReflectionTestUtils;

import java.lang.reflect.Method;
import java.lang.reflect.Parameter;
import java.math.BigDecimal;
import java.sql.Time;
import java.sql.Timestamp;
import java.time.*;
import java.util.*;
import java.util.stream.Stream;

import static org.assertj.core.api.Assertions.*;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
@DisplayName("SqlLoggingAspect Tests")
class SqlLoggingAspectTest {

    private SqlLoggingAspect aspect;

    @Mock
    private ProceedingJoinPoint joinPoint;

    @Mock
    private MethodSignature methodSignature;

    @Mock
    private Signature signature;

    @Mock
    private Logger logger;

    private static final String TEST_METHOD_NAME = "selectById";
    private static final String TEST_CLASS_NAME = "com.yourcompany.mapper.UserMapper";

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);

        // Create actual instance of the aspect
        aspect = new SqlLoggingAspect();

        // Set default configuration values using reflection
        ReflectionTestUtils.setField(aspect, "sqlLoggingEnabled", true);
        ReflectionTestUtils.setField(aspect, "slowQueryThreshold", 1000L);
        ReflectionTestUtils.setField(aspect, "formatSql", true);
        ReflectionTestUtils.setField(aspect, "maxSqlLength", 10000);
        ReflectionTestUtils.setField(aspect, "excludeMappers", "");
        ReflectionTestUtils.setField(aspect, "logger", logger);
    }

    @Test
    @DisplayName("Should proceed without logging when logging is disabled")
    void testLogSqlExecutionWhenLoggingDisabled() throws Throwable {
        // Given
        ReflectionTestUtils.setField(aspect, "sqlLoggingEnabled", false);
        Object expectedResult = new Object();
        when(joinPoint.proceed()).thenReturn(expectedResult);

        // When
        Object result = aspect.logSqlExecution(joinPoint);

        // Then
        assertThat(result).isEqualTo(expectedResult);
        verify(joinPoint, times(1)).proceed();
        verifyNoInteractions(logger);
    }

    @Test
    @DisplayName("Should log SQL execution successfully")
    void testLogSqlExecutionWithSuccessfulExecution() throws Throwable {
        // Given
        setupBasicMocks();
        List<String> expectedResult = Arrays.asList("user1", "user2");
        when(joinPoint.proceed()).thenReturn(expectedResult);

        // When
        Object result = aspect.logSqlExecution(joinPoint);

        // Then
        assertThat(result).isEqualTo(expectedResult);
        verify(joinPoint).proceed();
        verify(logger).info(anyString());
    }

    @Test
    @DisplayName("Should log SQL execution with exception")
    void testLogSqlExecutionWithException() throws Throwable {
        // Given
        setupBasicMocks();
        RuntimeException exception = new RuntimeException("Database error");
        when(joinPoint.proceed()).thenThrow(exception);

        // When & Then
        assertThatThrownBy(() -> aspect.logSqlExecution(joinPoint))
            .isInstanceOf(RuntimeException.class)
            .hasMessage("Database error");

        verify(logger).error(anyString());
    }

    @Test
    @DisplayName("Should log slow query warning")
    void testSlowQueryLogging() throws Throwable {
        // Given
        setupBasicMocks();
        ReflectionTestUtils.setField(aspect, "slowQueryThreshold", 0L); // Set threshold to 0 to trigger slow query
        when(joinPoint.proceed()).thenAnswer(inv -> {
            Thread.sleep(10); // Simulate slow query
            return Collections.emptyList();
        });

        // When
        aspect.logSqlExecution(joinPoint);

        // Then
        verify(logger).warn(anyString());
    }

    @Test
    @DisplayName("Should exclude specified mappers from logging")
    void testExcludeMappers() throws Throwable {
        // Given
        ReflectionTestUtils.setField(aspect, "excludeMappers", "UserMapper,OrderMapper");
        ReflectionTestUtils.setField(aspect, "excludeMapperSet", null); // Reset the set
        setupBasicMocks();
        when(joinPoint.proceed()).thenReturn(new Object());

        // When
        aspect.logSqlExecution(joinPoint);

        // Then
        verify(joinPoint).proceed();
        verifyNoInteractions(logger);
    }

    @Test
    @DisplayName("Should truncate long SQL statements")
    void testSqlTruncation() throws Throwable {
        // Given
        ReflectionTestUtils.setField(aspect, "maxSqlLength", 50);
        setupBasicMocks();

        // Setup method with very long SQL
        Method method = TestMapper.class.getMethod("selectWithLongQuery", Long.class);
        when(methodSignature.getMethod()).thenReturn(method);
        when(joinPoint.getArgs()).thenReturn(new Object[]{123L});
        when(joinPoint.proceed()).thenReturn(new Object());

        // When
        aspect.logSqlExecution(joinPoint);

        // Then
        ArgumentCaptor<String> logCaptor = ArgumentCaptor.forClass(String.class);
        verify(logger).info(logCaptor.capture());
        assertThat(logCaptor.getValue()).contains("[TRUNCATED]");
    }

    @Test
    @DisplayName("Should extract SQL from @Select annotation")
    void testExtractSqlFromSelectAnnotation() throws Throwable {
        // Given
        setupBasicMocks();
        Method method = TestMapper.class.getMethod("selectById", Long.class);
        when(methodSignature.getMethod()).thenReturn(method);
        when(joinPoint.getArgs()).thenReturn(new Object[]{123L});
        when(joinPoint.proceed()).thenReturn(Collections.singletonList("user"));

        // When
        aspect.logSqlExecution(joinPoint);

        // Then
        ArgumentCaptor<String> logCaptor = ArgumentCaptor.forClass(String.class);
        verify(logger).info(logCaptor.capture());
        assertThat(logCaptor.getValue()).contains("SELECT * FROM users WHERE id = 123");
    }

    @Test
    @DisplayName("Should extract SQL from @Insert annotation")
    void testExtractSqlFromInsertAnnotation() throws Throwable {
        // Given
        setupBasicMocks();
        Method method = TestMapper.class.getMethod("insertUser", Long.class, String.class);
        when(methodSignature.getMethod()).thenReturn(method);
        when(joinPoint.getArgs()).thenReturn(new Object[]{1L, "John"});
        when(joinPoint.proceed()).thenReturn(1);

        // When
        aspect.logSqlExecution(joinPoint);

        // Then
        ArgumentCaptor<String> logCaptor = ArgumentCaptor.forClass(String.class);
        verify(logger).info(logCaptor.capture());
        assertThat(logCaptor.getValue()).contains("INSERT INTO users (id, name) VALUES (1, 'John')");
    }

    @Test
    @DisplayName("Should extract SQL from @Update annotation")
    void testExtractSqlFromUpdateAnnotation() throws Throwable {
        // Given
        setupBasicMocks();
        Method method = TestMapper.class.getMethod("updateUser", String.class, Long.class);
        when(methodSignature.getMethod()).thenReturn(method);
        when(joinPoint.getArgs()).thenReturn(new Object[]{"Jane", 2L});
        when(joinPoint.proceed()).thenReturn(1);

        // When
        aspect.logSqlExecution(joinPoint);

        // Then
        ArgumentCaptor<String> logCaptor = ArgumentCaptor.forClass(String.class);
        verify(logger).info(logCaptor.capture());
        assertThat(logCaptor.getValue()).contains("UPDATE users SET name = 'Jane' WHERE id = 2");
    }

    @Test
    @DisplayName("Should extract SQL from @Delete annotation")
    void testExtractSqlFromDeleteAnnotation() throws Throwable {
        // Given
        setupBasicMocks();
        Method method = TestMapper.class.getMethod("deleteUser", Long.class);
        when(methodSignature.getMethod()).thenReturn(method);
        when(joinPoint.getArgs()).thenReturn(new Object[]{3L});
        when(joinPoint.proceed()).thenReturn(1);

        // When
        aspect.logSqlExecution(joinPoint);

        // Then
        ArgumentCaptor<String> logCaptor = ArgumentCaptor.forClass(String.class);
        verify(logger).info(logCaptor.capture());
        assertThat(logCaptor.getValue()).contains("DELETE FROM users WHERE id = 3");
    }

    @Test
    @DisplayName("Should handle method without SQL annotations")
    void testMethodWithoutSqlAnnotations() throws Throwable {
        // Given
        setupBasicMocks();
        Method method = TestMapper.class.getMethod("methodWithoutAnnotation", String.class, Integer.class);
        when(methodSignature.getMethod()).thenReturn(method);
        when(joinPoint.getArgs()).thenReturn(new Object[]{"test", 100});
        when(joinPoint.proceed()).thenReturn(null);

        // When
        aspect.logSqlExecution(joinPoint);

        // Then
        ArgumentCaptor<String> logCaptor = ArgumentCaptor.forClass(String.class);
        verify(logger).info(logCaptor.capture());
        assertThat(logCaptor.getValue()).contains("-- Method Call:");
        assertThat(logCaptor.getValue()).contains("methodWithoutAnnotation");
        assertThat(logCaptor.getValue()).contains("arg0='test'");
        assertThat(logCaptor.getValue()).contains("arg1=100");
    }

    @Test
    @DisplayName("Should handle null parameters")
    void testNullParameters() throws Throwable {
        // Given
        setupBasicMocks();
        Method method = TestMapper.class.getMethod("selectById", Long.class);
        when(methodSignature.getMethod()).thenReturn(method);
        when(joinPoint.getArgs()).thenReturn(new Object[]{null});
        when(joinPoint.proceed()).thenReturn(null);

        // When
        aspect.logSqlExecution(joinPoint);

        // Then
        ArgumentCaptor<String> logCaptor = ArgumentCaptor.forClass(String.class);
        verify(logger).info(logCaptor.capture());
        assertThat(logCaptor.getValue()).contains("id = NULL");
    }

    @ParameterizedTest
    @DisplayName("Should format simple parameter values correctly")
    @MethodSource("provideSimpleParameterValues")
    void testFormatSimpleParameterValues(Object value, String expected) {
        // When
        String result = invokeFormatParameterValue(value);

        // Then
        assertThat(result).isEqualTo(expected);
    }

    private static Stream<Arguments> provideSimpleParameterValues() {
        return Stream.of(
            Arguments.of(null, "NULL"),
            Arguments.of("test", "'test'"),
            Arguments.of("test's", "'test''s'"), // Test SQL escaping
            Arguments.of(123, "123"),
            Arguments.of(123L, "123"),
            Arguments.of(123.45, "123.45"),
            Arguments.of(new BigDecimal("123.45"), "123.45"),
            Arguments.of(true, "1"),
            Arguments.of(false, "0"),
            Arguments.of('A', "'A'")
        );
    }

    @ParameterizedTest
    @DisplayName("Should format date/time parameter values correctly")
    @MethodSource("provideDateTimeParameterValues")
    void testFormatDateTimeParameterValues(Object value, String expectedPattern) {
        // When
        String result = invokeFormatParameterValue(value);

        // Then
        assertThat(result).matches(expectedPattern);
    }

    private static Stream<Arguments> provideDateTimeParameterValues() {
        LocalDateTime ldt = LocalDateTime.of(2024, 1, 15, 10, 30, 45);
        LocalDate ld = LocalDate.of(2024, 1, 15);
        LocalTime lt = LocalTime.of(10, 30, 45);
        Instant instant = Instant.parse("2024-01-15T10:30:45Z");

        return Stream.of(
            Arguments.of(ldt, "'2024-01-15 10:30:45'"),
            Arguments.of(ld, "'2024-01-15'"),
            Arguments.of(lt, "'10:30:45'"),
            Arguments.of(Date.from(instant), "'\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}'"),
            Arguments.of(new java.sql.Date(System.currentTimeMillis()), "'\\d{4}-\\d{2}-\\d{2}'"),
            Arguments.of(new Time(System.currentTimeMillis()), "'\\d{2}:\\d{2}:\\d{2}'"),
            Arguments.of(new Timestamp(System.currentTimeMillis()), "'\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}'")
        );
    }

    @Test
    @DisplayName("Should format collection parameter values correctly")
    void testFormatCollectionParameterValues() {
        // Given
        List<Integer> intList = Arrays.asList(1, 2, 3);
        Set<String> stringSet = new HashSet<>(Arrays.asList("a", "b", "c"));
        List<Object> emptyList = Collections.emptyList();

        // When & Then
        assertThat(invokeFormatParameterValue(intList)).isEqualTo("(1, 2, 3)");
        assertThat(invokeFormatParameterValue(emptyList)).isEqualTo("()");

        String setResult = invokeFormatParameterValue(stringSet);
        assertThat(setResult).containsAnyOf("('a', 'b', 'c')", "('a', 'c', 'b')",
                                          "('b', 'a', 'c')", "('b', 'c', 'a')",
                                          "('c', 'a', 'b')", "('c', 'b', 'a')");
    }

    @Test
    @DisplayName("Should format array parameter values correctly")
    void testFormatArrayParameterValues() {
        // Given
        int[] intArray = {1, 2, 3};
        String[] stringArray = {"a", "b", "c"};
        long[] longArray = {100L, 200L, 300L};
        double[] doubleArray = {1.1, 2.2, 3.3};
        boolean[] boolArray = {true, false, true};
        float[] floatArray = {1.1f, 2.2f, 3.3f};
        char[] charArray = {'a', 'b', 'c'};
        byte[] byteArray = {1, 2, 3};
        short[] shortArray = {10, 20, 30};

        // When & Then
        assertThat(invokeFormatParameterValue(intArray)).isEqualTo("(1, 2, 3)");
        assertThat(invokeFormatParameterValue(stringArray)).isEqualTo("('a', 'b', 'c')");
        assertThat(invokeFormatParameterValue(longArray)).isEqualTo("(100, 200, 300)");
        assertThat(invokeFormatParameterValue(doubleArray)).isEqualTo("(1.1, 2.2, 3.3)");
        assertThat(invokeFormatParameterValue(boolArray)).isEqualTo("(1, 0, 1)");
        assertThat(invokeFormatParameterValue(floatArray)).isEqualTo("(1.1, 2.2, 3.3)");
        assertThat(invokeFormatParameterValue(charArray)).isEqualTo("('a', 'b', 'c')");
        assertThat(invokeFormatParameterValue(byteArray)).isEqualTo("(1, 2, 3)");
        assertThat(invokeFormatParameterValue(shortArray)).isEqualTo("(10, 20, 30)");
    }

    @Test
    @DisplayName("Should format enum parameter values correctly")
    void testFormatEnumParameterValues() {
        // Given
        enum TestEnum { VALUE1, VALUE2 }

        // When & Then
        assertThat(invokeFormatParameterValue(TestEnum.VALUE1)).isEqualTo("'VALUE1'");
        assertThat(invokeFormatParameterValue(TestEnum.VALUE2)).isEqualTo("'VALUE2'");
    }

    @Test
    @DisplayName("Should replace placeholders with parameter values")
    void testReplacePlaceholdersWithValues() throws Exception {
        // Given
        String sql = "SELECT * FROM users WHERE id = #{arg0} AND name = #{arg1}";
        Method method = TestMapper.class.getMethod("selectByIdAndName", Long.class, String.class);
        Parameter[] parameters = method.getParameters();
        Object[] args = {123L, "John"};

        // When
        String result = invokeReplacePlaceholdersWithValues(sql, parameters, args);

        // Then
        assertThat(result).isEqualTo("SELECT * FROM users WHERE id = 123 AND name = 'John'");
    }

    @Test
    @DisplayName("Should replace ? placeholders with parameter values")
    void testReplaceQuestionMarkPlaceholders() throws Exception {
        // Given
        String sql = "SELECT * FROM users WHERE id = ? AND name = ?";
        Method method = TestMapper.class.getMethod("selectByIdAndName", Long.class, String.class);
        Parameter[] parameters = method.getParameters();
        Object[] args = {456L, "Jane"};

        // When
        String result = invokeReplacePlaceholdersWithValues(sql, parameters, args);

        // Then
        assertThat(result).isEqualTo("SELECT * FROM users WHERE id = 456 AND name = 'Jane'");
    }

    @Test
    @DisplayName("Should format SQL for readability when enabled")
    void testFormatSqlForReadability() {
        // Given
        String unformattedSql = "SELECT id, name FROM users WHERE status = 'active' AND created_date > '2024-01-01' ORDER BY created_date DESC";

        // When
        String result = invokeFormatSqlForReadability(unformattedSql);

        // Then
        assertThat(result).contains("\nSELECT");
        assertThat(result).contains("\nFROM");
        assertThat(result).contains("\nWHERE");
        assertThat(result).contains("\nAND");
        assertThat(result).contains("\nORDER BY");
    }

    @Test
    @DisplayName("Should not format SQL when disabled")
    void testFormatSqlDisabled() {
        // Given
        ReflectionTestUtils.setField(aspect, "formatSql", false);
        String sql = "SELECT id FROM users WHERE status = 'active'";

        // When
        String result = invokeFormatSqlForReadability(sql);

        // Then
        assertThat(result).isEqualTo(sql);
    }

    @Test
    @DisplayName("Should calculate result count correctly")
    void testResultCount() {
        // Test with Collection
        List<String> listResult = Arrays.asList("a", "b", "c");
        assertThat(invokeGetResultCount(listResult)).isEqualTo("3");

        // Test with Integer (update/delete count)
        assertThat(invokeGetResultCount(5)).isEqualTo("5");

        // Test with single object
        assertThat(invokeGetResultCount(new Object())).isEqualTo("1");

        // Test with null
        assertThat(invokeGetResultCount(null)).isEqualTo("0");
    }

    @Test
    @DisplayName("Should escape SQL strings correctly")
    void testEscapeSqlString() {
        // Given
        String input1 = "John's car";
        String input2 = "It's a 'test'";
        String input3 = null;

        // When & Then
        assertThat(invokeEscapeSqlString(input1)).isEqualTo("John''s car");
        assertThat(invokeEscapeSqlString(input2)).isEqualTo("It''s a ''test''");
        assertThat(invokeEscapeSqlString(input3)).isEqualTo("");
    }

    @Test
    @DisplayName("Should handle logging exceptions gracefully")
    void testLoggingExceptionHandling() throws Throwable {
        // Given
        setupBasicMocks();
        when(methodSignature.getMethod()).thenThrow(new RuntimeException("Method extraction error"));
        when(joinPoint.proceed()).thenReturn(new Object());

        // When & Then
        assertThatCode(() -> aspect.logSqlExecution(joinPoint))
            .doesNotThrowAnyException();

        verify(logger).warn(contains("Failed to log SQL execution"));
    }

    @Test
    @DisplayName("Should handle complex SQL with multiple annotations")
    void testComplexSqlWithMultipleLines() throws Throwable {
        // Given
        setupBasicMocks();
        Method method = TestMapper.class.getMethod("complexQuery", String.class, Integer.class);
        when(methodSignature.getMethod()).thenReturn(method);
        when(joinPoint.getArgs()).thenReturn(new Object[]{"active", 10});
        when(joinPoint.proceed()).thenReturn(Collections.emptyList());

        // When
        aspect.logSqlExecution(joinPoint);

        // Then
        ArgumentCaptor<String> logCaptor = ArgumentCaptor.forClass(String.class);
        verify(logger).info(logCaptor.capture());
        String loggedSql = logCaptor.getValue();
        assertThat(loggedSql).contains("SELECT");
        assertThat(loggedSql).contains("users");
        assertThat(loggedSql).contains("status = 'active'");
        assertThat(loggedSql).contains("LIMIT 10");
    }

    @Test
    @DisplayName("Should handle custom objects as parameters")
    void testCustomObjectParameters() {
        // Given
        class CustomObject {
            @Override
            public String toString() {
                return "CustomObject[id=1, name=test]";
            }
        }
        CustomObject custom = new CustomObject();

        // When
        String result = invokeFormatParameterValue(custom);

        // Then
        assertThat(result).isEqualTo("'CustomObject[id=1, name=test]'");
    }

    // Test Mapper interface for testing annotations
    private interface TestMapper {
        @Select("SELECT * FROM users WHERE id = #{arg0}")
        List<Object> selectById(Long id);

        @Insert("INSERT INTO users (id, name) VALUES (#{arg0}, #{arg1})")
        int insertUser(Long id, String name);

        @Update("UPDATE users SET name = #{arg0} WHERE id = #{arg1}")
        int updateUser(String name, Long id);

        @Delete("DELETE FROM users WHERE id = #{arg0}")
        int deleteUser(Long id);

        List<Object> methodWithoutAnnotation(String param1, Integer param2);

        @Select("SELECT * FROM users WHERE id = #{arg0} AND name = #{arg1}")
        List<Object> selectByIdAndName(Long id, String name);

        @Select({
            "SELECT * FROM users",
            "WHERE status = #{arg0}",
            "ORDER BY created_date DESC",
            "LIMIT #{arg1}"
        })
        List<Object> complexQuery(String status, Integer limit);

        @Select("SELECT " + "a".repeat(100) + " FROM users WHERE id = #{arg0}")
        List<Object> selectWithLongQuery(Long id);
    }

    // Helper methods for reflection-based invocations
    private void setupBasicMocks() throws Throwable {
        Object mockTarget = new Object() {
            @Override
            public String toString() {
                return TEST_CLASS_NAME;
            }
        };

        when(joinPoint.getTarget()).thenReturn(mockTarget);
        when(joinPoint.getSignature()).thenReturn(methodSignature);
        when(methodSignature.getName()).thenReturn(TEST_METHOD_NAME);

        // Set up a default method
        Method defaultMethod = TestMapper.class.getMethod("methodWithoutAnnotation", String.class, Integer.class);
        when(methodSignature.getMethod()).thenReturn(defaultMethod);
        when(joinPoint.getArgs()).thenReturn(new Object[]{"test", 100});
    }

    private String invokeFormatParameterValue(Object value) {
        try {
            Method method = SqlLoggingAspect.class.getDeclaredMethod("formatParameterValue", Object.class);
            method.setAccessible(true);
            return (String) method.invoke(aspect, value);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    private String invokeReplacePlaceholdersWithValues(String sql, Parameter[] parameters, Object[] args) {
        try {
            Method method = SqlLoggingAspect.class.getDeclaredMethod(
                "replacePlaceholdersWithValues", String.class, Parameter[].class, Object[].class);
            method.setAccessible(true);
            return (String) method.invoke(aspect, sql, parameters, args);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    private String invokeFormatSqlForReadability(String sql) {
        try {
            Method method = SqlLoggingAspect.class.getDeclaredMethod("formatSqlForReadability", String.class);
            method.setAccessible(true);
            return (String) method.invoke(aspect, sql);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    private String invokeGetResultCount(Object result) {
        try {
            Method method = SqlLoggingAspect.class.getDeclaredMethod("getResultCount", Object.class);
            method.setAccessible(true);
            return (String) method.invoke(aspect, result);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    private String invokeEscapeSqlString(String value) {
        try {
            Method method = SqlLoggingAspect.class.getDeclaredMethod("escapeSqlString", String.class);
            method.setAccessible(true);
            return (String) method.invoke(aspect, value);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
}