package com.codereview.manager.config;

import com.codereview.manager.model.Category;
import com.codereview.manager.model.CodeReviewSubmission;
import com.codereview.manager.model.Project;
import com.codereview.manager.model.Prompt;
import com.codereview.manager.model.Team;
import com.codereview.manager.repository.CategoryRepository;
import com.codereview.manager.repository.CodeReviewSubmissionRepository;
import com.codereview.manager.repository.ProjectRepository;
import com.codereview.manager.repository.PromptRepository;
import com.codereview.manager.repository.TeamRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.CommandLineRunner;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

import java.util.HashMap;
import java.util.Map;

/**
 * Data Initializer component that populates the database with sample data on startup.
 * This is particularly useful for the H2 in-memory database which loses data on restart.
 */
@Component
public class DataInitializer implements CommandLineRunner {

    private static final Logger logger = LoggerFactory.getLogger(DataInitializer.class);

    private final CategoryRepository categoryRepository;
    private final PromptRepository promptRepository;
    private final TeamRepository teamRepository;
    private final ProjectRepository projectRepository;
    private final CodeReviewSubmissionRepository submissionRepository;

    @Autowired
    public DataInitializer(CategoryRepository categoryRepository, PromptRepository promptRepository,
                          TeamRepository teamRepository, ProjectRepository projectRepository,
                          CodeReviewSubmissionRepository submissionRepository) {
        this.categoryRepository = categoryRepository;
        this.promptRepository = promptRepository;
        this.teamRepository = teamRepository;
        this.projectRepository = projectRepository;
        this.submissionRepository = submissionRepository;
    }

    @Override
    @Transactional
    public void run(String... args) throws Exception {
        logger.info("Starting data initialization...");

        // Check if data already exists
        if (categoryRepository.count() > 0) {
            logger.info("Data already exists, skipping initialization");
            return;
        }

        // Initialize categories
        Map<String, Category> categories = initializeCategories();

        // Initialize prompts
        initializePrompts(categories);

        // Initialize teams and projects
        initializeTeamsAndProjects();

        // Initialize sample code review submissions
        initializeCodeReviewSubmissions();

        logger.info("Data initialization completed successfully!");
        logger.info("Created {} categories, {} prompts, {} teams, {} projects, and {} submissions",
                   categoryRepository.count(), promptRepository.count(),
                   teamRepository.count(), projectRepository.count(), submissionRepository.count());
    }

    private Map<String, Category> initializeCategories() {
        logger.info("Initializing categories...");
        Map<String, Category> categories = new HashMap<>();

        // Create and save categories
        categories.put("CODE_REVIEW", createAndSaveCategory("Code Review",
                "Guidelines and prompts for general code reviews"));

        categories.put("SECURITY", createAndSaveCategory("Security",
                "Security-focused review prompts and best practices"));

        categories.put("PERFORMANCE", createAndSaveCategory("Performance Analysis",
                "Performance optimization and monitoring code reviews"));

        categories.put("ARCHITECTURE", createAndSaveCategory("Architecture Review",
                "Architectural patterns, microservices, and design reviews"));

        categories.put("TESTING", createAndSaveCategory("Testing & Quality",
                "Test coverage, quality metrics, and testing strategies"));

        categories.put("CONFIG", createAndSaveCategory("Configuration Management",
                "Configuration, deployment, and infrastructure reviews"));

        categories.put("SPECIALIZED", createAndSaveCategory("Specialized Technologies",
                "Reactive programming, GraphQL, batch processing, and other specialized tech"));

        categories.put("DOCUMENTATION", createAndSaveCategory("Documentation & README",
                "README generation, API documentation, and technical writing prompts"));

        logger.info("Created {} categories", categories.size());
        return categories;
    }

    private Category createAndSaveCategory(String name, String description) {
        Category category = new Category(name, description);
        return categoryRepository.save(category);
    }

    private void initializePrompts(Map<String, Category> categories) {
        logger.info("Initializing prompts...");

        // Code Review prompts
        createPrompt("Check for proper error handling", categories.get("CODE_REVIEW"),
                "Review error handling patterns and exception management",
                """
                Please review this code for proper error handling. Check for:
                - Try-catch blocks where appropriate
                - Meaningful error messages
                - Proper exception propagation
                - Resource cleanup in finally blocks
                - Logging of errors with appropriate context

                Code to review:
                {CODE}
                """);

        // Security prompts
        createPrompt("Security Analysis Prompt", categories.get("SECURITY"),
                "Comprehensive security vulnerability analysis for Java/Spring Boot applications",
                """
                Analyze the provided Java/Spring Boot code for security vulnerabilities with focus on:

                CRITICAL CHECKS:
                1. SQL Injection vulnerabilities in repository methods, native queries, or JDBC templates
                2. Cross-Site Scripting (XSS) in REST endpoints returning HTML/JavaScript
                3. Authentication bypass possibilities in Spring Security configurations
                4. Insecure deserialization in Jackson/JSON processing
                5. Path traversal in file operations
                6. LDAP injection in directory services
                7. XXE attacks in XML processing
                8. Sensitive data exposure in logs, responses, or error messages
                9. Missing or incorrect @PreAuthorize/@Secured annotations
                10. Hardcoded credentials or API keys

                For each issue found, provide:
                - Severity level (CRITICAL/HIGH/MEDIUM/LOW)
                - Affected lines
                - CWE/CVE reference if applicable
                - Specific remediation code with Spring Security best practices
                - Example of secure implementation

                Context about the application:
                - Application type: {APPLICATION_TYPE}
                - Security framework version: {SPRING_SECURITY_VERSION}
                - Authentication method: {AUTH_METHOD}

                Code to review:
                {CODE}

                Previous security patterns in this codebase:
                {SECURITY_CONTEXT}
                """);

        createPrompt("Spring Security Configuration Audit", categories.get("SECURITY"),
                "Audit Spring Security configuration for vulnerabilities and best practices",
                """
                Audit Spring Security configuration for vulnerabilities and best practices:

                SECURITY REVIEW:
                1. Authentication
                   - Authentication provider configuration
                   - Password encoding
                   - Remember-me security
                   - Session management

                2. Authorization
                   - Role hierarchy
                   - Method security
                   - URL patterns
                   - Expression-based access

                3. CORS & CSRF
                   - CORS configuration
                   - CSRF token handling
                   - SameSite cookies
                   - Origin validation

                4. OAuth2/JWT
                   - Token validation
                   - Scope management
                   - Refresh token handling
                   - Key rotation

                5. Security Headers
                   - CSP configuration
                   - X-Frame-Options
                   - HSTS settings
                   - XSS protection

                Provide:
                - Security score (0-100)
                - Critical vulnerabilities
                - Configuration improvements
                - Compliance gaps

                Security requirements:
                {SECURITY_REQUIREMENTS}

                Code to review:
                {CODE}

                Authentication method: {AUTH_METHOD}
                """);

        // Performance prompts
        createPrompt("Performance Optimization Analysis", categories.get("PERFORMANCE"),
                "Comprehensive performance analysis of Java/Spring Boot code",
                """
                Perform a comprehensive performance analysis of this Java/Spring Boot code:

                PERFORMANCE ASPECTS TO ANALYZE:
                1. Database Query Optimization
                   - N+1 query problems in JPA/Hibernate
                   - Missing @Transactional boundaries
                   - Incorrect FetchType (LAZY vs EAGER)
                   - Missing database indexes implications
                   - Unnecessary data fetching

                2. Memory Management
                   - Memory leaks in collections or caches
                   - Large object allocations
                   - Stream API inefficiencies
                   - String concatenation in loops

                3. Concurrency Issues
                   - Thread safety violations
                   - Missing synchronization
                   - Incorrect use of concurrent collections
                   - Potential deadlocks

                4. Caching Opportunities
                   - Missing @Cacheable annotations
                   - Cache invalidation issues
                   - Redis/Caffeine optimization

                5. Async Processing
                   - Blocking I/O in reactive stack
                   - Missing @Async for long operations
                   - Thread pool sizing issues

                For each finding, provide:
                - Performance impact (HIGH/MEDIUM/LOW)
                - Benchmark estimation (e.g., "Could reduce response time by ~30%")
                - Optimized code example
                - JVM flags or Spring properties to tune

                Current performance SLA:
                - Expected response time: {RESPONSE_TIME_SLA}
                - Concurrent users: {CONCURRENT_USERS}
                - Database: {DATABASE_TYPE}

                Code to review:
                {CODE}

                Related performance metrics:
                {PERFORMANCE_METRICS}
                """);

        createPrompt("JPA/Hibernate Optimization", categories.get("PERFORMANCE"),
                "Analyze JPA/Hibernate implementation for correctness and performance",
                """
                Analyze JPA/Hibernate implementation for correctness and performance:

                FOCUS AREAS:
                1. Entity Mapping
                   - Incorrect @Entity relationships
                   - Missing indexes via @Table
                   - Improper cascade types
                   - Orphan removal settings

                2. Query Optimization
                   - JPQL/HQL inefficiencies
                   - Missing JOIN FETCH
                   - N+1 query problems
                   - Cartesian products

                3. Transaction Management
                   - @Transactional scope issues
                   - Read-only transaction opportunities
                   - Isolation level appropriateness
                   - Transaction timeout settings

                4. Hibernate Specific
                   - First-level cache issues
                   - Second-level cache opportunities
                   - Batch processing optimization
                   - Lazy initialization exceptions

                5. Database Schema
                   - Naming strategy compliance
                   - Migration script issues
                   - Foreign key constraints

                Provide:
                - Generated SQL analysis
                - Query execution plan implications
                - Suggested @Query optimizations
                - Batch processing improvements

                Database: {DATABASE_TYPE}
                Hibernate Version: {HIBERNATE_VERSION}

                Code to review:
                {CODE}

                Current database schema:
                {SCHEMA_CONTEXT}
                """);

        createPrompt("Caching Strategy Analysis", categories.get("PERFORMANCE"),
                "Evaluate caching implementation and optimization opportunities",
                """
                Evaluate caching implementation and optimization opportunities:

                REVIEW ASPECTS:
                1. Cache Configuration
                   - Cache provider selection
                   - TTL/TTI settings
                   - Eviction policies
                   - Cache sizing

                2. Cache Usage
                   - @Cacheable correctness
                   - Cache key strategy
                   - Conditional caching
                   - Cache synchronization

                3. Performance Impact
                   - Cache hit ratio analysis
                   - Memory usage
                   - Serialization overhead
                   - Network latency (distributed cache)

                4. Cache Invalidation
                   - @CacheEvict usage
                   - Cascade invalidation
                   - Scheduled refresh
                   - Event-based invalidation

                5. Distributed Caching
                   - Redis/Hazelcast configuration
                   - Cluster configuration
                   - Failover handling

                Provide:
                - Cache effectiveness score
                - Optimization recommendations
                - Memory impact analysis
                - Invalidation strategy improvements

                Cache provider: {CACHE_PROVIDER}
                Cache configuration: {CACHE_CONFIG}

                Code to review:
                {CODE}
                """);

        // Architecture prompts
        createPrompt("Microservice Architecture Review", categories.get("ARCHITECTURE"),
                "Review microservice code for architectural compliance and distributed system best practices",
                """
                Review this microservice code for architectural compliance and distributed system best practices:

                EVALUATION CRITERIA:
                1. Service Boundaries
                   - Domain-driven design adherence
                   - Bounded context violations
                   - Service coupling analysis

                2. Communication Patterns
                   - REST vs messaging appropriateness
                   - Circuit breaker implementation
                   - Retry logic and timeouts
                   - Idempotency guarantees

                3. Data Consistency
                   - Distributed transaction handling
                   - Saga pattern implementation
                   - Event sourcing correctness

                4. Service Discovery
                   - Eureka/Consul integration
                   - Load balancing configuration
                   - Health check implementation

                5. Observability
                   - Distributed tracing (Sleuth/Zipkin)
                   - Correlation ID propagation
                   - Metrics exposure
                   - Structured logging

                Analyze for:
                - Service coupling score
                - Failure resilience rating
                - Scalability bottlenecks
                - Data consistency risks

                Microservice context:
                - Service name: {SERVICE_NAME}
                - Communication protocol: {PROTOCOL}
                - Service mesh: {SERVICE_MESH}

                Code to review:
                {CODE}

                Service dependencies:
                {SERVICE_DEPENDENCIES}
                """);

        createPrompt("Event-Driven Architecture Analysis", categories.get("ARCHITECTURE"),
                "Analyze event-driven implementation for reliability and consistency",
                """
                Analyze event-driven implementation for reliability and consistency:

                EVALUATION CRITERIA:
                1. Event Design
                   - Event schema design
                   - Event versioning
                   - Event sourcing patterns
                   - CQRS implementation

                2. Message Handling
                   - Idempotency guarantees
                   - Message ordering
                   - Duplicate detection
                   - Dead letter handling

                3. Transaction Management
                   - Saga implementation
                   - Compensation logic
                   - Distributed transactions
                   - Eventual consistency

                4. Integration
                   - Kafka/RabbitMQ usage
                   - Spring Cloud Stream
                   - Message serialization
                   - Schema registry

                5. Monitoring
                   - Event tracking
                   - Latency metrics
                   - Error rates
                   - Message backlogs

                Assess:
                - Event flow correctness
                - Failure resilience
                - Consistency guarantees
                - Performance characteristics

                Message broker: {MESSAGE_BROKER}
                Event store: {EVENT_STORE}

                Code to review:
                {CODE}

                Event catalog:
                {EVENT_CATALOG}
                """);

        createPrompt("Cloud-Native Readiness Assessment", categories.get("ARCHITECTURE"),
                "Assess cloud-native readiness and Kubernetes compatibility",
                """
                Assess cloud-native readiness and Kubernetes compatibility:

                CLOUD-NATIVE CHECKLIST:
                1. Containerization
                   - Dockerfile optimization
                   - Image size analysis
                   - Layer caching
                   - Security scanning

                2. Configuration
                   - Environment variables
                   - ConfigMap/Secret usage
                   - Cloud config server
                   - Feature flags

                3. Scalability
                   - Stateless design
                   - Session management
                   - Horizontal scaling ready
                   - Resource limits

                4. Resilience
                   - Health checks
                   - Readiness probes
                   - Graceful shutdown
                   - Circuit breakers

                5. Observability
                   - Prometheus metrics
                   - Log aggregation
                   - Distributed tracing
                   - Service mesh ready

                Rate:
                - Cloud maturity level (1-5)
                - Kubernetes readiness score
                - Migration effort estimation
                - Risk assessment

                Target platform: {CLOUD_PLATFORM}
                Container orchestration: {ORCHESTRATION}

                Code to review:
                {CODE}

                Deployment configuration:
                {DEPLOYMENT_CONFIG}
                """);

        // Testing & Quality prompts
        createPrompt("Spring Boot Best Practices Review", categories.get("TESTING"),
                "Review Spring Boot code against enterprise best practices and Spring Boot 3.x standards",
                """
                Review this Spring Boot code against enterprise best practices and Spring Boot 3.x standards:

                EVALUATION CRITERIA:
                1. Dependency Injection
                   - Constructor vs field injection
                   - Circular dependencies
                   - @Autowired usage
                   - Qualifier usage

                2. Configuration Management
                   - @ConfigurationProperties vs @Value
                   - Profile-specific configurations
                   - Externalized configuration
                   - Property validation

                3. REST API Design
                   - RESTful principles adherence
                   - Proper HTTP status codes
                   - Request/Response DTOs
                   - API versioning strategy
                   - HATEOAS compliance

                4. Exception Handling
                   - Global exception handler usage
                   - Custom exceptions
                   - Error response structure
                   - Logging practices

                5. Spring Boot Starters
                   - Appropriate starter usage
                   - Version compatibility
                   - Unnecessary dependencies

                6. Actuator & Monitoring
                   - Health checks implementation
                   - Custom metrics
                   - Appropriate endpoint exposure

                Provide:
                - Compliance score (0-100)
                - Priority-ordered improvements
                - Migration path for deprecated features
                - Modern Spring Boot 3.x alternatives

                Spring Boot Version: {SPRING_BOOT_VERSION}
                Java Version: {JAVA_VERSION}

                Code to review:
                {CODE}

                Project conventions:
                {PROJECT_CONVENTIONS}
                """);

        createPrompt("Clean Code & SOLID Principles Analysis", categories.get("TESTING"),
                "Evaluate code quality using Clean Code principles and SOLID design patterns",
                """
                Evaluate code quality using Clean Code principles and SOLID design patterns:

                ANALYSIS FRAMEWORK:
                1. SOLID Principles
                   - Single Responsibility violations
                   - Open/Closed principle adherence
                   - Liskov Substitution issues
                   - Interface Segregation problems
                   - Dependency Inversion violations

                2. Clean Code Metrics
                   - Method complexity (Cyclomatic complexity > 10)
                   - Class cohesion
                   - Method/variable naming conventions
                   - Code duplication (DRY violations)
                   - Magic numbers/strings

                3. Design Patterns
                   - Appropriate pattern usage
                   - Anti-pattern detection
                   - Over-engineering assessment

                4. Readability
                   - Comment quality and necessity
                   - Self-documenting code
                   - Cognitive complexity

                Calculate and provide:
                - Cyclomatic complexity score
                - Maintainability index
                - Technical debt estimation (in hours)
                - Refactoring priority matrix

                Output format:
                - Issue type
                - Location (class:method:line)
                - Current code snippet
                - Suggested improvement
                - Effort estimate

                Code to review:
                {CODE}

                Team coding standards:
                {CODING_STANDARDS}
                """);

        createPrompt("Testing Quality Assessment", categories.get("TESTING"),
                "Evaluate test code quality, coverage, and testing strategies",
                """
                Evaluate test code quality, coverage, and testing strategies:

                ASSESSMENT CRITERIA:
                1. Test Coverage
                   - Line coverage percentage
                   - Branch coverage analysis
                   - Missing test scenarios
                   - Edge cases coverage

                2. Test Quality
                   - Test naming conventions
                   - AAA pattern compliance
                   - Test independence
                   - Assertion quality

                3. Test Types
                   - Unit vs Integration balance
                   - Missing @SpringBootTest
                   - @MockBean vs @Mock usage
                   - @DataJpaTest optimization

                4. Test Data Management
                   - Test fixture quality
                   - @Sql script usage
                   - Test data builders
                   - Database cleanup

                5. Test Performance
                   - Slow test identification
                   - Unnecessary context loading
                   - @DirtiesContext usage

                Provide:
                - Test quality score
                - Missing test scenarios
                - Test refactoring suggestions
                - Performance improvements

                Testing framework: {TEST_FRAMEWORK}
                Coverage threshold: {COVERAGE_THRESHOLD}

                Code to review:
                {CODE}

                Test execution metrics:
                {TEST_METRICS}
                """);

        createPrompt("Technical Debt Assessment", categories.get("TESTING"),
                "Perform comprehensive technical debt analysis and prioritization",
                """
                Perform comprehensive technical debt analysis and prioritization:

                ASSESSMENT DIMENSIONS:
                1. Code Debt
                   - Code smells
                   - Duplicated code
                   - Complex methods
                   - Dead code
                   - TODO/FIXME comments

                2. Design Debt
                   - Architecture violations
                   - Pattern misuse
                   - Coupling issues
                   - Missing abstractions

                3. Testing Debt
                   - Coverage gaps
                   - Flaky tests
                   - Missing test types
                   - Test maintenance burden

                4. Documentation Debt
                   - Missing documentation
                   - Outdated docs
                   - API documentation
                   - Architecture decisions

                5. Infrastructure Debt
                   - Outdated dependencies
                   - Security patches
                   - Performance bottlenecks
                   - Monitoring gaps

                Calculate:
                - Technical debt score
                - Remediation cost (hours)
                - Risk-based priority
                - ROI for fixes
                - Debt payment roadmap

                Code to review:
                {CODE}

                Current metrics:
                {CURRENT_METRICS}
                """);

        // Configuration Management prompts
        createPrompt("API Contract Validation", categories.get("CONFIG"),
                "Validate REST API implementation against OpenAPI/Swagger specifications and consumer contracts",
                """
                Validate REST API implementation against OpenAPI/Swagger specifications and consumer contracts:

                VALIDATION CHECKLIST:
                1. Contract Compliance
                   - Request/Response schema matching
                   - Required fields validation
                   - Data type consistency
                   - Enum value compliance

                2. Versioning Strategy
                   - Breaking change detection
                   - Backward compatibility
                   - Deprecation handling
                   - Version header management

                3. Documentation
                   - Swagger annotations completeness
                   - Example values provision
                   - Error response documentation
                   - Authentication documentation

                4. Consumer Contract Tests
                   - Pact/Spring Cloud Contract compliance
                   - Contract test coverage
                   - Provider state management

                Report:
                - Contract violations with severity
                - Breaking changes detected
                - Missing documentation elements
                - Consumer impact analysis

                API Specification:
                {OPENAPI_SPEC}

                Code to review:
                {CODE}

                Known consumers:
                {API_CONSUMERS}
                """);

        createPrompt("Dependency Management Analysis", categories.get("CONFIG"),
                "Analyze Maven/Gradle dependencies and dependency management",
                """
                Analyze Maven/Gradle dependencies and dependency management:

                CHECK FOR:
                1. Dependency Issues
                   - Version conflicts
                   - Transitive dependency problems
                   - Security vulnerabilities (CVEs)
                   - Deprecated libraries

                2. Optimization Opportunities
                   - Unnecessary dependencies
                   - Dependency scope issues
                   - Test dependency leakage
                   - BOM usage

                3. Spring Boot Compatibility
                   - Starter compatibility
                   - Version alignment
                   - Property overrides

                4. License Compliance
                   - License compatibility
                   - Commercial license usage
                   - Open source compliance

                Report:
                - Vulnerable dependencies with CVE scores
                - Version upgrade recommendations
                - Dependency optimization suggestions
                - License compliance issues

                Build tool: {BUILD_TOOL}
                Spring Boot version: {SPRING_BOOT_VERSION}

                Dependencies to review:
                {DEPENDENCIES}

                Security policy:
                {SECURITY_POLICY}
                """);

        createPrompt("Configuration Management Review", categories.get("CONFIG"),
                "Review application configuration and externalization strategies",
                """
                Review application configuration and externalization strategies:

                ANALYSIS POINTS:
                1. Configuration Structure
                   - Property naming conventions
                   - Configuration hierarchy
                   - Profile organization
                   - Environment-specific configs

                2. Security
                   - Sensitive data in configs
                   - Encryption needs
                   - Vault integration
                   - Config server security

                3. Validation
                   - @ConfigurationProperties validation
                   - Required properties
                   - Type safety
                   - Default values

                4. Documentation
                   - Property documentation
                   - Configuration examples
                   - Migration guides

                5. Best Practices
                   - Configuration as code
                   - Feature flags
                   - Dynamic configuration

                Identify:
                - Security risks
                - Configuration smells
                - Missing validations
                - Documentation gaps

                Configuration files:
                {CONFIG_FILES}

                Environment: {ENVIRONMENT}

                Code to review:
                {CODE}
                """);

        createPrompt("Database Migration Review", categories.get("CONFIG"),
                "Review database migration scripts (Flyway/Liquibase) for correctness and safety",
                """
                Review database migration scripts (Flyway/Liquibase) for correctness and safety:

                EVALUATION CRITERIA:
                1. Migration Safety
                   - Backward compatibility
                   - Data loss risks
                   - Rollback capability
                   - Idempotency

                2. Performance Impact
                   - Lock duration estimation
                   - Index creation strategy
                   - Large table migrations
                   - Batch processing

                3. Best Practices
                   - Naming conventions
                   - Version numbering
                   - Repeatable migrations
                   - Schema consistency

                4. Data Integrity
                   - Constraint violations
                   - Data transformation accuracy
                   - Null handling
                   - Default values

                Assess:
                - Migration risk level
                - Estimated execution time
                - Rollback strategy
                - Testing requirements

                Migration tool: {MIGRATION_TOOL}
                Database: {DATABASE_TYPE}
                Database size: {DATABASE_SIZE}

                Migration scripts:
                {MIGRATION_SCRIPTS}

                Current schema:
                {CURRENT_SCHEMA}
                """);

        // Specialized Technology prompts
        createPrompt("Reactive Programming Analysis", categories.get("SPECIALIZED"),
                "Analyze Spring WebFlux/Reactor code for reactive programming best practices",
                """
                Analyze Spring WebFlux/Reactor code for reactive programming best practices:

                REVIEW POINTS:
                1. Reactive Streams
                   - Proper Mono/Flux usage
                   - Backpressure handling
                   - Cold vs Hot streams

                2. Non-blocking Operations
                   - Blocking call detection
                   - Thread pool usage
                   - Scheduler selection

                3. Error Handling
                   - onError operators usage
                   - Retry strategies
                   - Circuit breaker integration

                4. Performance
                   - Operator efficiency
                   - Memory leaks in streams
                   - Context propagation

                5. Testing
                   - StepVerifier usage
                   - Async testing patterns

                Identify:
                - Blocking operations in reactive chain
                - Missing error handling
                - Performance bottlenecks
                - Memory leak risks

                Reactive stack: {REACTIVE_STACK}

                Code to review:
                {CODE}

                Performance requirements:
                {PERFORMANCE_REQUIREMENTS}
                """);

        createPrompt("Logging and Monitoring Review", categories.get("SPECIALIZED"),
                "Review logging, monitoring, and observability implementation",
                """
                Review logging, monitoring, and observability implementation:

                EVALUATION AREAS:
                1. Logging Practices
                   - Log levels appropriateness
                   - Structured logging (JSON)
                   - PII/sensitive data in logs
                   - Correlation ID usage
                   - Performance impact

                2. Metrics Collection
                   - Micrometer metrics usage
                   - Custom metrics relevance
                   - Metric naming conventions
                   - Cardinality issues

                3. Distributed Tracing
                   - Span creation
                   - Trace context propagation
                   - Sampling configuration

                4. Error Tracking
                   - Exception logging quality
                   - Stack trace management
                   - Error aggregation

                5. Audit Logging
                   - Compliance requirements
                   - Audit event completeness

                Provide:
                - Logging improvement suggestions
                - Missing metrics identification
                - Performance impact analysis
                - Compliance gaps

                Logging framework: {LOGGING_FRAMEWORK}
                Monitoring stack: {MONITORING_STACK}

                Code to review:
                {CODE}

                Compliance requirements:
                {COMPLIANCE_REQUIREMENTS}
                """);

        createPrompt("Spring Batch Processing Review", categories.get("SPECIALIZED"),
                "Review Spring Batch implementation for reliability and performance",
                """
                Review Spring Batch implementation for reliability and performance:

                ANALYSIS FRAMEWORK:
                1. Job Configuration
                   - Step configuration
                   - Chunk size optimization
                   - Skip/retry policies
                   - Transaction boundaries

                2. Performance
                   - Parallel processing
                   - Partitioning strategy
                   - Reader/processor/writer efficiency
                   - Database connection pooling

                3. Error Handling
                   - Skip logic appropriateness
                   - Retry configuration
                   - Error logging
                   - Failed record handling

                4. Monitoring
                   - Job metrics
                   - Progress tracking
                   - Failure alerting
                   - Job history

                5. Restartability
                   - Job restart configuration
                   - State management
                   - Idempotency guarantees

                Calculate:
                - Throughput estimation
                - Error tolerance rating
                - Scalability assessment
                - Recovery strategy score

                Batch requirements:
                - Volume: {DATA_VOLUME}
                - Frequency: {JOB_FREQUENCY}
                - SLA: {BATCH_SLA}

                Code to review:
                {CODE}
                """);

        createPrompt("GraphQL Implementation Review", categories.get("SPECIALIZED"),
                "Review GraphQL implementation for performance and security",
                """
                Review GraphQL implementation for performance and security:

                ANALYSIS POINTS:
                1. Schema Design
                   - Type definitions
                   - Nullable fields
                   - Naming conventions
                   - Schema organization

                2. Performance
                   - N+1 query problems
                   - DataLoader implementation
                   - Query complexity limits
                   - Pagination strategy

                3. Security
                   - Authentication/authorization
                   - Query depth limiting
                   - Rate limiting
                   - Field-level security

                4. Error Handling
                   - Error formatting
                   - Partial success handling
                   - Validation errors
                   - Exception mapping

                5. Best Practices
                   - Resolver organization
                   - Schema stitching
                   - Subscription handling
                   - Caching strategy

                Provide:
                - Performance bottlenecks
                - Security vulnerabilities
                - Schema improvements
                - Query optimization suggestions

                GraphQL library: {GRAPHQL_LIBRARY}

                Code to review:
                {CODE}

                Schema definition:
                {GRAPHQL_SCHEMA}
                """);

        // Documentation & README prompts
        createPrompt("Comprehensive README Generator", categories.get("DOCUMENTATION"),
                "Generate comprehensive README.md files for any project type",
                """
                You are an expert technical writer specializing in creating comprehensive README files.

                Based on the project analysis provided, create a professional README.md file that includes:

                ## Essential Sections:
                1. **Project Title & Description**: Clear, concise project overview
                2. **Features**: Key functionality and capabilities
                3. **Installation**: Step-by-step setup instructions
                4. **Usage**: Code examples and basic usage patterns
                5. **API Documentation**: Endpoints and methods (if applicable)
                6. **Configuration**: Environment variables and configuration options
                7. **Contributing**: Guidelines for contributors
                8. **License**: License information

                ## Quality Standards:
                - Use clear, professional language
                - Include code examples with proper syntax highlighting
                - Add badges for build status, version, license where appropriate
                - Structure information hierarchically with proper headings
                - Include troubleshooting section if relevant
                - Add links to documentation, demos, or related resources

                ## Markdown Best Practices:
                - Use consistent heading levels
                - Include a table of contents for long READMEs
                - Use code blocks with language specification
                - Add screenshots or diagrams where helpful
                - Use tables for structured data
                - Include emojis sparingly for visual appeal

                Make the README informative, professional, and user-friendly. Focus on what developers need to know to understand, install, and use the project effectively.
                """);

        createPrompt("API Documentation README", categories.get("DOCUMENTATION"),
                "Generate API-focused README with endpoint documentation",
                """
                You are an expert API documentation writer. Create a README.md focused on API documentation.

                Structure the README with these sections:

                ## API Documentation Focus:
                1. **API Overview**: Purpose and core functionality
                2. **Authentication**: How to authenticate with the API
                3. **Base URL & Versioning**: API base URL and version information
                4. **Endpoints**: Complete endpoint documentation with:
                   - HTTP methods
                   - Request/response examples
                   - Parameters and data types
                   - Response codes and error handling
                5. **Rate Limiting**: Usage limits and throttling
                6. **SDK/Client Libraries**: Available client libraries
                7. **Testing**: How to test the API (Postman, curl examples)
                8. **Changelog**: API version changes

                ## Documentation Standards:
                - Provide complete request/response examples in JSON
                - Include curl command examples
                - Document all parameters with types and descriptions
                - Show error responses with proper HTTP status codes
                - Include authentication examples
                - Use consistent formatting for endpoints
                - Add interactive elements where possible

                Focus on making the API easy to understand and integrate with clear, complete examples.
                """);

        createPrompt("User Guide README", categories.get("DOCUMENTATION"),
                "Generate user-focused README with tutorials and guides",
                """
                You are a technical writer specializing in user-friendly documentation. Create a README.md focused on end-users.

                Structure the README for maximum user friendliness:

                ## User-Centric Sections:
                1. **What This Does**: Plain-language explanation of the project
                2. **Quick Start**: Get up and running in 5 minutes or less
                3. **Step-by-Step Tutorial**: Detailed walkthrough with examples
                4. **Common Use Cases**: Real-world scenarios and solutions
                5. **Configuration Guide**: How to customize for different needs
                6. **Troubleshooting**: Solutions to common problems
                7. **FAQ**: Frequently asked questions
                8. **Getting Help**: Support channels and resources

                ## User Experience Focus:
                - Use simple, non-technical language where possible
                - Include screenshots and visual guides
                - Provide copy-paste code examples
                - Anticipate user questions and pain points
                - Include success indicators ("You should see...")
                - Offer multiple paths for different user types
                - Add tips and best practices

                ## Tutorial Quality:
                - Start with the simplest possible example
                - Build complexity gradually
                - Explain why, not just how
                - Include expected outputs
                - Provide links to deeper documentation

                Make the README approachable for users of all skill levels while being comprehensive enough for advanced users.
                """);

        createPrompt("Project Analysis README", categories.get("DOCUMENTATION"),
                "Generate README based on comprehensive project analysis",
                """
                You are a technical analyst and documentation expert. Based on the comprehensive project analysis provided, create a README.md that accurately reflects the project's architecture, technologies, and purpose.

                ## Analysis-Driven Documentation:
                1. **Project Overview**: Based on file structure and key files analysis
                2. **Architecture**: Describe the identified patterns and structure
                3. **Technology Stack**: List all detected technologies and frameworks
                4. **Project Structure**: Explain the directory layout and organization
                5. **Dependencies**: Key dependencies from package files
                6. **Build & Deployment**: Based on build files and configurations
                7. **Development**: Setup for contributors based on project structure
                8. **Testing**: Testing strategy based on detected test files

                ## Technical Analysis Integration:
                - Identify the primary programming language and frameworks
                - Detect architectural patterns (MVC, microservices, etc.)
                - Analyze configuration files for setup requirements
                - Extract dependency information from package managers
                - Identify build tools and deployment strategies
                - Recognize testing frameworks and strategies
                - Understand project conventions and standards

                ## Accuracy Standards:
                - Only document what can be verified from the project structure
                - Infer reasonable setup steps from configuration files
                - Explain the purpose based on file organization
                - Highlight unique aspects of the project architecture
                - Provide accurate technology versions where detected

                Create documentation that serves as both an introduction and technical reference, grounded in actual project analysis rather than assumptions.
                """);

        logger.info("Initialized {} prompts", promptRepository.count());
    }

    private void createPrompt(String title, Category category, String description, String content) {
        Prompt prompt = new Prompt(title, content, description, category);
        prompt.setIsActive(true);
        promptRepository.save(prompt);
    }

    private void initializeTeamsAndProjects() {
        logger.info("Initializing teams and projects...");

        // Create teams
        Team developmentTeam = createAndSaveTeam("Development Team",
                "Main development team responsible for core application development",
                "tech.lead@company.com", "dev-notifications@company.com,team-lead@company.com");

        Team qaTeam = createAndSaveTeam("QA Team",
                "Quality Assurance team focused on testing and quality control",
                "qa.lead@company.com", "qa-notifications@company.com");

        Team devopsTeam = createAndSaveTeam("DevOps Team",
                "DevOps and infrastructure team managing deployments and operations",
                "devops.lead@company.com", "devops-alerts@company.com");

        // Create projects for Development Team
        createAndSaveProject("Code Review Manager",
                "Web application for managing code reviews with AI assistance",
                "https://github.com/company/code-review-manager",
                "main", developmentTeam);

        createAndSaveProject("User Management System",
                "Microservice for user authentication and authorization",
                "https://github.com/company/user-management",
                "develop", developmentTeam);

        createAndSaveProject("API Gateway",
                "Central API gateway for microservices architecture",
                "https://github.com/company/api-gateway",
                "main", developmentTeam);

        // Create projects for QA Team
        createAndSaveProject("Automated Testing Suite",
                "Comprehensive automated testing framework",
                "https://github.com/company/test-automation",
                "master", qaTeam);

        // Create projects for DevOps Team
        createAndSaveProject("Infrastructure as Code",
                "Terraform and Ansible configurations for infrastructure",
                "https://github.com/company/infrastructure",
                "main", devopsTeam);

        logger.info("Created {} teams and {} projects", teamRepository.count(), projectRepository.count());
    }

    private Team createAndSaveTeam(String name, String description, String teamLeadEmail, String notificationEmails) {
        Team team = new Team(name, description);
        team.setTeamLeadEmail(teamLeadEmail);
        team.setNotificationEmails(notificationEmails);
        team.setActive(true);
        return teamRepository.save(team);
    }

    private Project createAndSaveProject(String name, String description, String repositoryUrl,
                                       String branchName, Team team) {
        Project project = new Project(name, description, team);
        project.setRepositoryUrl(repositoryUrl);
        project.setBranchName(branchName);
        project.setActive(true);
        return projectRepository.save(project);
    }

    private void initializeCodeReviewSubmissions() {
        logger.info("Initializing sample code review submissions...");

        // Get projects for creating submissions
        Project codeReviewProject = projectRepository.findByName("Code Review Manager").orElse(null);
        Project userMgmtProject = projectRepository.findByName("User Management System").orElse(null);
        Project apiGatewayProject = projectRepository.findByName("API Gateway").orElse(null);

        if (codeReviewProject != null) {
            // Sample Java code submission
            createCodeReviewSubmission(
                "abc123def456",
                "john.developer@company.com",
                "John Developer",
                codeReviewProject,
                "src/main/java/com/example/UserService.java",
                "Java",
                getSampleJavaCode(),
                CodeReviewSubmission.Priority.HIGH,
                CodeReviewSubmission.ReviewStatus.PENDING
            );

            // Sample JavaScript code submission
            createCodeReviewSubmission(
                "xyz789abc123",
                "jane.frontend@company.com",
                "Jane Frontend",
                codeReviewProject,
                "frontend/src/components/TeamManager.js",
                "JavaScript",
                getSampleJavaScriptCode(),
                CodeReviewSubmission.Priority.MEDIUM,
                CodeReviewSubmission.ReviewStatus.IN_PROGRESS
            );
        }

        if (userMgmtProject != null) {
            // Sample Spring Security configuration
            createCodeReviewSubmission(
                "def456ghi789",
                "security.expert@company.com",
                "Security Expert",
                userMgmtProject,
                "src/main/java/com/auth/SecurityConfig.java",
                "Java",
                getSampleSecurityCode(),
                CodeReviewSubmission.Priority.URGENT,
                CodeReviewSubmission.ReviewStatus.COMPLETED
            );
        }

        if (apiGatewayProject != null) {
            // Sample API Gateway configuration
            createCodeReviewSubmission(
                "ghi789jkl012",
                "api.developer@company.com",
                "API Developer",
                apiGatewayProject,
                "src/main/java/com/gateway/GatewayConfig.java",
                "Java",
                getSampleGatewayCode(),
                CodeReviewSubmission.Priority.LOW,
                CodeReviewSubmission.ReviewStatus.FAILED
            );
        }

        logger.info("Created {} code review submissions", submissionRepository.count());
    }

    private void createCodeReviewSubmission(String commitHash, String submitterEmail, String submitterName,
                                           Project project, String filePath, String language, String codeContent,
                                           CodeReviewSubmission.Priority priority,
                                           CodeReviewSubmission.ReviewStatus status) {
        CodeReviewSubmission submission = new CodeReviewSubmission(commitHash, submitterEmail, project, codeContent);
        submission.setSubmitterName(submitterName);
        submission.setFilePath(filePath);
        submission.setProgrammingLanguage(language);
        submission.setPriority(priority);
        submission.setReviewStatus(status);
        submission.generateContextualReviewId();

        // Set review dates based on status
        if (status == CodeReviewSubmission.ReviewStatus.IN_PROGRESS ||
            status == CodeReviewSubmission.ReviewStatus.COMPLETED ||
            status == CodeReviewSubmission.ReviewStatus.FAILED) {
            submission.setReviewStartedDate(submission.getSubmittedDate().plusMinutes(10));
        }

        if (status == CodeReviewSubmission.ReviewStatus.COMPLETED) {
            submission.setReviewCompletedDate(submission.getSubmittedDate().plusHours(2));
            submission.setReviewReport("Code review completed successfully. Found 2 minor issues and 1 suggestion for improvement.");
            submission.setNotificationSent(true);
        } else if (status == CodeReviewSubmission.ReviewStatus.FAILED) {
            submission.setReviewCompletedDate(submission.getSubmittedDate().plusMinutes(30));
            submission.setReviewReport("Review failed due to compilation errors. Please fix syntax errors and resubmit.");
            submission.setNotificationSent(true);
        }

        submissionRepository.save(submission);
    }

    private String getSampleJavaCode() {
        return "@Service\n" +
               "public class UserService {\n" +
               "    \n" +
               "    @Autowired\n" +
               "    private UserRepository userRepository;\n" +
               "    \n" +
               "    public User createUser(UserDto userDto) {\n" +
               "        // TODO: Add validation\n" +
               "        User user = new User();\n" +
               "        user.setUsername(userDto.getUsername());\n" +
               "        user.setEmail(userDto.getEmail());\n" +
               "        user.setPassword(userDto.getPassword()); // Security issue: plain text password!\n" +
               "        \n" +
               "        return userRepository.save(user);\n" +
               "    }\n" +
               "    \n" +
               "    public List<User> getAllUsers() {\n" +
               "        return userRepository.findAll();\n" +
               "    }\n" +
               "}";
    }

    private String getSampleJavaScriptCode() {
        return "function loadTeams() {\n" +
               "    fetch('/api/teams')\n" +
               "        .then(response => response.json())\n" +
               "        .then(teams => {\n" +
               "            const teamList = document.getElementById('team-list');\n" +
               "            teamList.innerHTML = '';\n" +
               "            \n" +
               "            teams.forEach(team => {\n" +
               "                const teamElement = document.createElement('div');\n" +
               "                teamElement.className = 'team-card';\n" +
               "                teamElement.innerHTML = `\n" +
               "                    <h3>${team.name}</h3>\n" +
               "                    <p>${team.description}</p>\n" +
               "                    <span class=\"status ${team.active ? 'active' : 'inactive'}\">\n" +
               "                        ${team.active ? 'Active' : 'Inactive'}\n" +
               "                    </span>\n" +
               "                `;\n" +
               "                teamList.appendChild(teamElement);\n" +
               "            });\n" +
               "        })\n" +
               "        .catch(error => {\n" +
               "            console.error('Error loading teams:', error);\n" +
               "        });\n" +
               "}";
    }

    private String getSampleSecurityCode() {
        return "@Configuration\n" +
               "@EnableWebSecurity\n" +
               "public class SecurityConfig {\n" +
               "    \n" +
               "    @Bean\n" +
               "    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n" +
               "        http\n" +
               "            .authorizeHttpRequests(authz -> authz\n" +
               "                .requestMatchers(\"/api/public/**\").permitAll()\n" +
               "                .requestMatchers(\"/api/admin/**\").hasRole(\"ADMIN\")\n" +
               "                .anyRequest().authenticated()\n" +
               "            )\n" +
               "            .oauth2ResourceServer(oauth2 -> oauth2\n" +
               "                .jwt(jwt -> jwt.jwtAuthenticationConverter(jwtAuthConverter()))\n" +
               "            )\n" +
               "            .csrf(csrf -> csrf.disable()); // Consider CSRF protection\n" +
               "            \n" +
               "        return http.build();\n" +
               "    }\n" +
               "}";
    }

    private String getSampleGatewayCode() {
        return "@Configuration\n" +
               "public class GatewayConfig {\n" +
               "    \n" +
               "    @Bean\n" +
               "    public RouteLocator customRouteLocator(RouteLocatorBuilder builder) {\n" +
               "        return builder.routes()\n" +
               "            .route(\"user-service\", r -> r.path(\"/api/users/**\")\n" +
               "                .uri(\"http://user-service:8080\"))\n" +
               "            .route(\"order-service\", r -> r.path(\"/api/orders/**\")\n" +
               "                .filters(f -> f.addRequestHeader(\"X-Gateway\", \"true\"))\n" +
               "                .uri(\"http://order-service:8080\"))\n" +
               "            .build();\n" +
               "    }\n" +
               "    \n" +
               "    @Bean\n" +
               "    public CorsGlobalConfig corsGlobalConfig() {\n" +
               "        // CORS configuration needed\n" +
               "        return new CorsGlobalConfig();\n" +
               "    }\n" +
               "}";
    }
}
