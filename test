package com.yourcompany.config.mybatis;

import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;

import java.lang.reflect.Method;
import java.lang.reflect.Parameter;
import java.sql.Time;
import java.sql.Timestamp;
import java.text.SimpleDateFormat;
import java.time.*;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

/**
 * MyBatis SQL Logging Aspect
 *
 * Features:
 * - Logs executable SQL queries that can be copied and run directly
 * - Handles all Java types and collections
 * - Configurable logging levels and formatting
 * - Performance optimized with caching
 */
@Aspect
@Component
public class SqlLoggingAspect {

    private static final Logger logger = LoggerFactory.getLogger(SqlLoggingAspect.class);

    // Thread-safe caches for performance
    private static final Map<Class<?>, Boolean> SIMPLE_TYPE_CACHE = new ConcurrentHashMap<>();

    // Date formatters - thread-safe in Java 8+
    private static final DateTimeFormatter DATETIME_FORMATTER = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
    private static final DateTimeFormatter DATE_FORMATTER = DateTimeFormatter.ofPattern("yyyy-MM-dd");
    private static final DateTimeFormatter TIME_FORMATTER = DateTimeFormatter.ofPattern("HH:mm:ss");
    private static final SimpleDateFormat LEGACY_DATETIME_FORMAT = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
    private static final SimpleDateFormat LEGACY_DATE_FORMAT = new SimpleDateFormat("yyyy-MM-dd");
    private static final SimpleDateFormat LEGACY_TIME_FORMAT = new SimpleDateFormat("HH:mm:ss");

    // Configuration properties
    @Value("${mybatis.sql.logging.enabled:true}")
    private boolean sqlLoggingEnabled;

    @Value("${mybatis.sql.logging.slow-query-threshold:1000}")
    private long slowQueryThreshold;

    @Value("${mybatis.sql.logging.format-sql:true}")
    private boolean formatSql;

    @Value("${mybatis.sql.logging.max-sql-length:10000}")
    private int maxSqlLength;

    @Value("${mybatis.sql.logging.exclude-mappers:}")
    private String excludeMappers;

    private Set<String> excludeMapperSet;

    /**
     * Intercept all MyBatis mapper method calls
     */
    @Around("execution(* *..*Mapper.*(..))")
    public Object logSqlExecution(ProceedingJoinPoint joinPoint) throws Throwable {
        if (!sqlLoggingEnabled) {
            return joinPoint.proceed();
        }

        initializeExcludeMappers();

        String methodName = getFullMethodName(joinPoint);

        // Check if this mapper should be excluded
        if (shouldExcludeMapper(methodName)) {
            return joinPoint.proceed();
        }

        long startTime = System.nanoTime();
        Object result = null;
        Exception exception = null;

        try {
            result = joinPoint.proceed();
            return result;
        } catch (Exception e) {
            exception = e;
            throw e;
        } finally {
            try {
                logExecutableSql(joinPoint, methodName, startTime, result, exception);
            } catch (Exception e) {
                logger.warn("Failed to log SQL execution: {}", e.getMessage());
            }
        }
    }

    private void initializeExcludeMappers() {
        if (excludeMapperSet == null && StringUtils.hasText(excludeMappers)) {
            excludeMapperSet = new HashSet<>(Arrays.asList(excludeMappers.split(",")));
        }
    }

    private String getFullMethodName(ProceedingJoinPoint joinPoint) {
        return joinPoint.getTarget().getClass().getName() + "." + joinPoint.getSignature().getName();
    }

    private boolean shouldExcludeMapper(String methodName) {
        if (excludeMapperSet == null || excludeMapperSet.isEmpty()) {
            return false;
        }
        return excludeMapperSet.stream().anyMatch(methodName::contains);
    }

    private void logExecutableSql(ProceedingJoinPoint joinPoint, String methodName, long startTime, Object result, Exception exception) {
        long executionTime = (System.nanoTime() - startTime) / 1_000_000; // Convert to ms

        // Build executable SQL from method and parameters
        String executableSql = buildExecutableSqlFromMethod(joinPoint);

        // Truncate if too long
        if (executableSql.length() > maxSqlLength) {
            executableSql = executableSql.substring(0, maxSqlLength) + "... [TRUNCATED]";
        }

        logFormattedSql(methodName, executableSql, executionTime, result, exception);
    }

    /**
     * Build executable SQL by analyzing method annotations and parameters
     */
    private String buildExecutableSqlFromMethod(ProceedingJoinPoint joinPoint) {
        try {
            Method method = ((org.aspectj.lang.reflect.MethodSignature) joinPoint.getSignature()).getMethod();
            Object[] args = joinPoint.getArgs();

            // Try to get SQL from @Select, @Insert, @Update, @Delete annotations
            String sql = extractSqlFromAnnotations(method);

            if (sql != null && !sql.isEmpty()) {
                return replacePlaceholdersWithValues(sql, method.getParameters(), args);
            }

            // Fallback: show method call with parameters
            return buildMethodCallSql(joinPoint.getSignature().getName(), method.getParameters(), args);

        } catch (Exception e) {
            return "-- Unable to extract SQL: " + e.getMessage();
        }
    }

    /**
     * Extract SQL from MyBatis annotations including SQL providers
     */
    private String extractSqlFromAnnotations(Method method) {
        // Check for @Select annotation
        org.apache.ibatis.annotations.Select select = method.getAnnotation(org.apache.ibatis.annotations.Select.class);
        if (select != null && select.value().length > 0) {
            return String.join(" ", select.value());
        }

        // Check for @Insert annotation
        org.apache.ibatis.annotations.Insert insert = method.getAnnotation(org.apache.ibatis.annotations.Insert.class);
        if (insert != null && insert.value().length > 0) {
            return String.join(" ", insert.value());
        }

        // Check for @Update annotation
        org.apache.ibatis.annotations.Update update = method.getAnnotation(org.apache.ibatis.annotations.Update.class);
        if (update != null && update.value().length > 0) {
            return String.join(" ", update.value());
        }

        // Check for @Delete annotation
        org.apache.ibatis.annotations.Delete delete = method.getAnnotation(org.apache.ibatis.annotations.Delete.class);
        if (delete != null && delete.value().length > 0) {
            return String.join(" ", delete.value());
        }

        // Check for SQL Provider annotations
        String providerSql = extractSqlFromProviders(method);
        if (providerSql != null) {
            return providerSql;
        }

        return null; // SQL is in XML mapper file
    }

    /**
     * Extract SQL from provider annotations (@SelectProvider, @InsertProvider, etc.)
     */
    private String extractSqlFromProviders(Method method) {
        try {
            // Check for @SelectProvider
            org.apache.ibatis.annotations.SelectProvider selectProvider = method.getAnnotation(org.apache.ibatis.annotations.SelectProvider.class);
            if (selectProvider != null) {
                return generateSqlFromProvider(selectProvider.type(), selectProvider.method(), method);
            }

            // Check for @InsertProvider
            org.apache.ibatis.annotations.InsertProvider insertProvider = method.getAnnotation(org.apache.ibatis.annotations.InsertProvider.class);
            if (insertProvider != null) {
                return generateSqlFromProvider(insertProvider.type(), insertProvider.method(), method);
            }

            // Check for @UpdateProvider
            org.apache.ibatis.annotations.UpdateProvider updateProvider = method.getAnnotation(org.apache.ibatis.annotations.UpdateProvider.class);
            if (updateProvider != null) {
                return generateSqlFromProvider(updateProvider.type(), updateProvider.method(), method);
            }

            // Check for @DeleteProvider
            org.apache.ibatis.annotations.DeleteProvider deleteProvider = method.getAnnotation(org.apache.ibatis.annotations.DeleteProvider.class);
            if (deleteProvider != null) {
                return generateSqlFromProvider(deleteProvider.type(), deleteProvider.method(), method);
            }

        } catch (Exception e) {
            logger.debug("Failed to extract SQL from provider: {}", e.getMessage());
        }

        return null;
    }

    /**
     * Generate SQL by calling the provider method
     */
    private String generateSqlFromProvider(Class<?> providerClass, String providerMethodName, Method originalMethod) {
        try {
            // Create instance of provider class
            Object providerInstance = providerClass.getDeclaredConstructor().newInstance();

            // Find the provider method
            Method providerMethod = findProviderMethod(providerClass, providerMethodName, originalMethod);
            if (providerMethod == null) {
                return "-- Provider method not found: " + providerClass.getSimpleName() + "." + providerMethodName;
            }

            // Call provider method to generate SQL
            Object sqlResult = null;

            // Handle different provider method signatures
            if (providerMethod.getParameterCount() == 0) {
                // No parameters
                sqlResult = providerMethod.invoke(providerInstance);
            } else if (providerMethod.getParameterCount() == 1) {
                // Single parameter - usually Map or specific type
                Map<String, Object> context = new HashMap<>();
                context.put("method", originalMethod.getName());
                context.put("class", originalMethod.getDeclaringClass().getSimpleName());
                sqlResult = providerMethod.invoke(providerInstance, context);
            } else {
                // Multiple parameters - try with context map
                Object[] args = new Object[providerMethod.getParameterCount()];
                Arrays.fill(args, new HashMap<String, Object>());
                sqlResult = providerMethod.invoke(providerInstance, args);
            }

            if (sqlResult instanceof String) {
                return (String) sqlResult;
            } else if (sqlResult != null) {
                return sqlResult.toString();
            }

        } catch (Exception e) {
            logger.debug("Failed to generate SQL from provider {}.{}: {}",
                providerClass.getSimpleName(), providerMethodName, e.getMessage());
            return "-- SQL Provider: " + providerClass.getSimpleName() + "." + providerMethodName + "() [Error: " + e.getMessage() + "]";
        }

        return "-- SQL Provider: " + providerClass.getSimpleName() + "." + providerMethodName + "()";
    }

    /**
     * Find the provider method by name and compatible signature
     */
    private Method findProviderMethod(Class<?> providerClass, String methodName, Method originalMethod) {
        Method[] methods = providerClass.getDeclaredMethods();

        // First try to find exact method name
        for (Method method : methods) {
            if (method.getName().equals(methodName)) {
                method.setAccessible(true);
                return method;
            }
        }

        // If not found, try case-insensitive search
        for (Method method : methods) {
            if (method.getName().equalsIgnoreCase(methodName)) {
                method.setAccessible(true);
                return method;
            }
        }

        return null;
    }

    /**
     * Replace #{} and ${} placeholders with actual parameter values
     */
    private String replacePlaceholdersWithValues(String sql, Parameter[] parameters, Object[] args) {
        if (parameters == null || args == null || parameters.length != args.length) {
            return sql;
        }

        String result = sql;

        for (int i = 0; i < parameters.length; i++) {
            String paramName = parameters[i].getName();
            Object paramValue = args[i];
            String formattedValue = formatParameterValue(paramValue);

            // Replace #{paramName} and ${paramName} with actual values
            result = result.replaceAll("#\\{" + paramName + "\\}", formattedValue);
            result = result.replaceAll("\\$\\{" + paramName + "\\}", formattedValue);
        }

        // Also handle ? placeholders (prepared statement style)
        for (Object arg : args) {
            if (result.contains("?")) {
                String formattedValue = formatParameterValue(arg);
                result = result.replaceFirst("\\?", formattedValue);
            }
        }

        return result;
    }

    /**
     * Build method call representation when SQL extraction fails
     */
    private String buildMethodCallSql(String methodName, Parameter[] parameters, Object[] args) {
        StringBuilder sb = new StringBuilder();
        sb.append("-- Method Call: ").append(methodName).append("(");

        if (parameters != null && args != null && parameters.length > 0) {
            for (int i = 0; i < parameters.length && i < args.length; i++) {
                if (i > 0) sb.append(", ");
                sb.append(parameters[i].getName()).append("=").append(formatParameterValue(args[i]));
            }
        }

        sb.append(")");
        return sb.toString();
    }

    /**
     * Format parameter values for direct SQL execution
     */
    private String formatParameterValue(Object value) {
        if (value == null) {
            return "NULL";
        }

        // Handle primitives and numbers
        if (isSimpleType(value.getClass())) {
            return formatSimpleType(value);
        }

        // Handle collections and arrays
        if (value instanceof Collection) {
            return formatCollection((Collection<?>) value);
        }

        if (value.getClass().isArray()) {
            return formatArray(value);
        }

        // Handle dates and times
        if (value instanceof java.util.Date) {
            return formatLegacyDate((java.util.Date) value);
        }

        if (value instanceof LocalDateTime) {
            return "'" + ((LocalDateTime) value).format(DATETIME_FORMATTER) + "'";
        }

        if (value instanceof LocalDate) {
            return "'" + ((LocalDate) value).format(DATE_FORMATTER) + "'";
        }

        if (value instanceof LocalTime) {
            return "'" + ((LocalTime) value).format(TIME_FORMATTER) + "'";
        }

        if (value instanceof Instant) {
            return "'" + LocalDateTime.ofInstant((Instant) value, ZoneId.systemDefault()).format(DATETIME_FORMATTER) + "'";
        }

        if (value instanceof ZonedDateTime) {
            return "'" + ((ZonedDateTime) value).format(DATETIME_FORMATTER) + "'";
        }

        if (value instanceof OffsetDateTime) {
            return "'" + ((OffsetDateTime) value).format(DATETIME_FORMATTER) + "'";
        }

        // Handle enum
        if (value instanceof Enum) {
            return "'" + ((Enum<?>) value).name() + "'";
        }

        // Default: treat as string
        return "'" + escapeSqlString(value.toString()) + "'";
    }

    private boolean isSimpleType(Class<?> clazz) {
        return SIMPLE_TYPE_CACHE.computeIfAbsent(clazz, this::checkSimpleType);
    }

    private boolean checkSimpleType(Class<?> clazz) {
        return clazz.isPrimitive() ||
               Number.class.isAssignableFrom(clazz) ||
               Boolean.class == clazz ||
               String.class == clazz ||
               Character.class == clazz;
    }

    private String formatSimpleType(Object value) {
        if (value instanceof String) {
            return "'" + escapeSqlString((String) value) + "'";
        }

        if (value instanceof Character) {
            return "'" + escapeSqlString(value.toString()) + "'";
        }

        if (value instanceof Boolean) {
            return ((Boolean) value) ? "1" : "0";
        }

        // Numbers (Integer, Long, Double, BigDecimal, etc.)
        return value.toString();
    }

    private String formatCollection(Collection<?> collection) {
        if (collection.isEmpty()) {
            return "()";
        }

        StringBuilder sb = new StringBuilder("(");
        Iterator<?> iterator = collection.iterator();

        while (iterator.hasNext()) {
            sb.append(formatParameterValue(iterator.next()));
            if (iterator.hasNext()) {
                sb.append(", ");
            }
        }

        sb.append(")");
        return sb.toString();
    }

    private String formatArray(Object array) {
        List<Object> list = new ArrayList<>();

        if (array instanceof Object[]) {
            Collections.addAll(list, (Object[]) array);
        } else if (array instanceof int[]) {
            for (int i : (int[]) array) list.add(i);
        } else if (array instanceof long[]) {
            for (long l : (long[]) array) list.add(l);
        } else if (array instanceof double[]) {
            for (double d : (double[]) array) list.add(d);
        } else if (array instanceof float[]) {
            for (float f : (float[]) array) list.add(f);
        } else if (array instanceof boolean[]) {
            for (boolean b : (boolean[]) array) list.add(b);
        } else if (array instanceof char[]) {
            for (char c : (char[]) array) list.add(c);
        } else if (array instanceof byte[]) {
            for (byte b : (byte[]) array) list.add(b);
        } else if (array instanceof short[]) {
            for (short s : (short[]) array) list.add(s);
        }

        return formatCollection(list);
    }

    private String formatLegacyDate(java.util.Date date) {
        synchronized (LEGACY_DATETIME_FORMAT) {
            if (date instanceof java.sql.Date) {
                return "'" + LEGACY_DATE_FORMAT.format(date) + "'";
            } else if (date instanceof Time) {
                return "'" + LEGACY_TIME_FORMAT.format(date) + "'";
            } else if (date instanceof Timestamp) {
                return "'" + LEGACY_DATETIME_FORMAT.format(date) + "'";
            } else {
                return "'" + LEGACY_DATETIME_FORMAT.format(date) + "'";
            }
        }
    }

    private String escapeSqlString(String value) {
        if (value == null) {
            return "";
        }
        // Escape single quotes by doubling them
        return value.replace("'", "''");
    }

    private void logFormattedSql(String methodName, String executableSql, long executionTime, Object result, Exception exception) {
        StringBuilder logMessage = new StringBuilder();

        // Header
        logMessage.append("\n").append("=".repeat(80)).append("\n");
        logMessage.append("Mapper Method: ").append(methodName).append("\n");
        logMessage.append("Execution Time: ").append(executionTime).append(" ms");

        if (executionTime > slowQueryThreshold) {
            logMessage.append(" [SLOW QUERY]");
        }
        logMessage.append("\n");

        // Status
        if (exception != null) {
            logMessage.append("Status: FAILED - ").append(exception.getClass().getSimpleName()).append("\n");
            logMessage.append("Error: ").append(exception.getMessage()).append("\n");
        } else {
            logMessage.append("Status: SUCCESS");
            if (result != null) {
                logMessage.append(" (").append(getResultCount(result)).append(" rows)");
            }
            logMessage.append("\n");
        }

        // SQL
        logMessage.append("\nExecutable SQL:\n");
        if (formatSql && !executableSql.startsWith("-- Method Call:")) {
            logMessage.append(formatSqlForReadability(executableSql));
        } else {
            logMessage.append(executableSql.replaceAll("\\s+", " ").trim());
        }

        logMessage.append("\n").append("=".repeat(80));

        // Log at appropriate level
        if (exception != null) {
            logger.error(logMessage.toString());
        } else if (executionTime > slowQueryThreshold) {
            logger.warn(logMessage.toString());
        } else {
            logger.info(logMessage.toString());
        }
    }

    private String getResultCount(Object result) {
        if (result instanceof Collection) {
            return String.valueOf(((Collection<?>) result).size());
        } else if (result instanceof Integer) {
            return String.valueOf(result);
        } else if (result != null) {
            return "1";
        }
        return "0";
    }

    private String formatSqlForReadability(String sql) {
        if (!formatSql || sql == null) {
            return sql;
        }

        return sql
            .replaceAll("(?i)\\b(SELECT|FROM|WHERE|AND|OR|ORDER\\s+BY|GROUP\\s+BY|HAVING|LIMIT|OFFSET|INSERT|UPDATE|DELETE|SET|VALUES|INTO|JOIN|LEFT\\s+JOIN|RIGHT\\s+JOIN|INNER\\s+JOIN|ON)\\b", "\n$1")
            .replaceAll("\\s+", " ")
            .replaceAll("\n ", "\n")
            .trim();
    }
}

/**
 * Configuration to enable AspectJ and register the SQL logging aspect
 */
@org.springframework.context.annotation.Configuration
@org.springframework.context.annotation.EnableAspectJAutoProxy
public class SqlLoggingAspectConfig {

    @org.springframework.context.annotation.Bean
    public SqlLoggingAspect sqlLoggingAspect() {
        return new SqlLoggingAspect();
    }
}

-------------------------
mybatis:
  sql:
    logging:
      enabled: true
      slow-query-threshold: 1000
      format-sql: true
      max-sql-length: 10000
      exclude-mappers: ""

logging:
  level:
    com.yourcompany.config.mybatis.SqlLoggingAspect: INFO
    org.apache.ibatis: WARN

spring:
  aop:
    auto: true
    proxy-target-class: true

    -----------------
    ---


    package com.yourcompany.config.mybatis;

    import org.apache.ibatis.binding.MapperMethod;
    import org.apache.ibatis.executor.Executor;
    import org.apache.ibatis.mapping.BoundSql;
    import org.apache.ibatis.mapping.MappedStatement;
    import org.apache.ibatis.mapping.ParameterMapping;
    import org.apache.ibatis.plugin.Invocation;
    import org.apache.ibatis.plugin.Plugin;
    import org.apache.ibatis.reflection.MetaObject;
    import org.apache.ibatis.session.Configuration;
    import org.apache.ibatis.session.ResultHandler;
    import org.apache.ibatis.session.RowBounds;
    import org.apache.ibatis.type.TypeHandlerRegistry;
    import org.junit.jupiter.api.BeforeEach;
    import org.junit.jupiter.api.DisplayName;
    import org.junit.jupiter.api.Test;
    import org.junit.jupiter.api.extension.ExtendWith;
    import org.junit.jupiter.params.ParameterizedTest;
    import org.junit.jupiter.params.provider.Arguments;
    import org.junit.jupiter.params.provider.MethodSource;
    import org.junit.jupiter.params.provider.NullSource;
    import org.junit.jupiter.params.provider.ValueSource;
    import org.mockito.ArgumentCaptor;
    import org.mockito.InjectMocks;
    import org.mockito.Mock;
    import org.mockito.Spy;
    import org.mockito.junit.jupiter.MockitoExtension;
    import org.slf4j.Logger;
    import org.springframework.test.util.ReflectionTestUtils;

    import java.lang.reflect.Method;
    import java.math.BigDecimal;
    import java.sql.Time;
    import java.sql.Timestamp;
    import java.time.*;
    import java.util.*;
    import java.util.stream.Stream;

    import static org.assertj.core.api.Assertions.*;
    import static org.mockito.ArgumentMatchers.*;
    import static org.mockito.Mockito.*;

    @ExtendWith(MockitoExtension.class)
    @DisplayName("SqlLoggingInterceptor Tests")
    class SqlLoggingInterceptorTest {

        @InjectMocks
        @Spy
        private SqlLoggingInterceptor interceptor;

        @Mock
        private Invocation invocation;

        @Mock
        private MappedStatement mappedStatement;

        @Mock
        private BoundSql boundSql;

        @Mock
        private Configuration configuration;

        @Mock
        private TypeHandlerRegistry typeHandlerRegistry;

        @Mock
        private Executor executor;

        @Mock
        private MetaObject metaObject;

        @Mock
        private Logger logger;

        private static final String TEST_SQL = "SELECT * FROM users WHERE id = ? AND name = ?";
        private static final String TEST_SQL_ID = "com.yourcompany.mapper.UserMapper.selectById";

        @BeforeEach
        void setUp() {
            // Set default configuration values
            ReflectionTestUtils.setField(interceptor, "sqlLoggingEnabled", true);
            ReflectionTestUtils.setField(interceptor, "slowQueryThreshold", 1000L);
            ReflectionTestUtils.setField(interceptor, "formatSql", true);
            ReflectionTestUtils.setField(interceptor, "includeParameters", true);
            ReflectionTestUtils.setField(interceptor, "maxSqlLength", 10000);
            ReflectionTestUtils.setField(interceptor, "excludeMappers", "");
            ReflectionTestUtils.setField(interceptor, "logger", logger);
        }

        @Test
        @DisplayName("Should proceed without logging when logging is disabled")
        void testInterceptWhenLoggingDisabled() throws Throwable {
            // Given
            ReflectionTestUtils.setField(interceptor, "sqlLoggingEnabled", false);
            Object expectedResult = new Object();
            when(invocation.proceed()).thenReturn(expectedResult);

            // When
            Object result = interceptor.intercept(invocation);

            // Then
            assertThat(result).isEqualTo(expectedResult);
            verify(invocation, times(1)).proceed();
            verifyNoInteractions(mappedStatement, boundSql);
        }

        @Test
        @DisplayName("Should log SQL execution successfully")
        void testInterceptWithSuccessfulExecution() throws Throwable {
            // Given
            setupBasicMocks();
            List<String> expectedResult = Arrays.asList("user1", "user2");
            when(invocation.proceed()).thenReturn(expectedResult);

            // When
            Object result = interceptor.intercept(invocation);

            // Then
            assertThat(result).isEqualTo(expectedResult);
            verify(invocation).proceed();
            verify(logger).info(anyString());
        }

        @Test
        @DisplayName("Should log SQL execution with exception")
        void testInterceptWithException() throws Throwable {
            // Given
            setupBasicMocks();
            RuntimeException exception = new RuntimeException("Database error");
            when(invocation.proceed()).thenThrow(exception);

            // When & Then
            assertThatThrownBy(() -> interceptor.intercept(invocation))
                .isInstanceOf(RuntimeException.class)
                .hasMessage("Database error");

            verify(logger).error(anyString());
        }

        @Test
        @DisplayName("Should log slow query warning")
        void testSlowQueryLogging() throws Throwable {
            // Given
            setupBasicMocks();
            ReflectionTestUtils.setField(interceptor, "slowQueryThreshold", 0L); // Set threshold to 0 to trigger slow query
            when(invocation.proceed()).thenAnswer(inv -> {
                Thread.sleep(10); // Simulate slow query
                return Collections.emptyList();
            });

            // When
            interceptor.intercept(invocation);

            // Then
            verify(logger).warn(anyString());
        }

        @Test
        @DisplayName("Should exclude specified mappers from logging")
        void testExcludeMappers() throws Throwable {
            // Given
            ReflectionTestUtils.setField(interceptor, "excludeMappers", "UserMapper,OrderMapper");
            setupBasicMocks();
            when(invocation.proceed()).thenReturn(new Object());

            // When
            interceptor.intercept(invocation);

            // Then
            verify(invocation).proceed();
            verifyNoInteractions(logger);
        }

        @Test
        @DisplayName("Should truncate long SQL statements")
        void testSqlTruncation() throws Throwable {
            // Given
            ReflectionTestUtils.setField(interceptor, "maxSqlLength", 50);
            String longSql = "SELECT " + "a".repeat(100) + " FROM table";
            setupBasicMocks();
            when(boundSql.getSql()).thenReturn(longSql);
            when(invocation.proceed()).thenReturn(new Object());

            // When
            interceptor.intercept(invocation);

            // Then
            ArgumentCaptor<String> logCaptor = ArgumentCaptor.forClass(String.class);
            verify(logger).info(logCaptor.capture());
            assertThat(logCaptor.getValue()).contains("[TRUNCATED]");
        }

        @ParameterizedTest
        @DisplayName("Should format simple parameter values correctly")
        @MethodSource("provideSimpleParameterValues")
        void testFormatSimpleParameterValues(Object value, String expected) {
            // When
            String result = invokeFormatParameterValue(value);

            // Then
            assertThat(result).isEqualTo(expected);
        }

        private static Stream<Arguments> provideSimpleParameterValues() {
            return Stream.of(
                Arguments.of(null, "NULL"),
                Arguments.of("test", "'test'"),
                Arguments.of("test's", "'test''s'"), // Test SQL escaping
                Arguments.of(123, "123"),
                Arguments.of(123L, "123"),
                Arguments.of(123.45, "123.45"),
                Arguments.of(new BigDecimal("123.45"), "123.45"),
                Arguments.of(true, "1"),
                Arguments.of(false, "0"),
                Arguments.of('A', "'A'")
            );
        }

        @ParameterizedTest
        @DisplayName("Should format date/time parameter values correctly")
        @MethodSource("provideDateTimeParameterValues")
        void testFormatDateTimeParameterValues(Object value, String expectedPattern) {
            // When
            String result = invokeFormatParameterValue(value);

            // Then
            assertThat(result).matches(expectedPattern);
        }

        private static Stream<Arguments> provideDateTimeParameterValues() {
            LocalDateTime ldt = LocalDateTime.of(2024, 1, 15, 10, 30, 45);
            LocalDate ld = LocalDate.of(2024, 1, 15);
            LocalTime lt = LocalTime.of(10, 30, 45);
            Instant instant = Instant.parse("2024-01-15T10:30:45Z");

            return Stream.of(
                Arguments.of(ldt, "'2024-01-15 10:30:45'"),
                Arguments.of(ld, "'2024-01-15'"),
                Arguments.of(lt, "'10:30:45'"),
                Arguments.of(Date.from(instant), "'\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}'"),
                Arguments.of(new java.sql.Date(System.currentTimeMillis()), "'\\d{4}-\\d{2}-\\d{2}'"),
                Arguments.of(new Time(System.currentTimeMillis()), "'\\d{2}:\\d{2}:\\d{2}'"),
                Arguments.of(new Timestamp(System.currentTimeMillis()), "'\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}'")
            );
        }

        @Test
        @DisplayName("Should format collection parameter values correctly")
        void testFormatCollectionParameterValues() {
            // Given
            List<Integer> intList = Arrays.asList(1, 2, 3);
            Set<String> stringSet = new HashSet<>(Arrays.asList("a", "b", "c"));
            List<Object> emptyList = Collections.emptyList();

            // When & Then
            assertThat(invokeFormatParameterValue(intList)).isEqualTo("(1, 2, 3)");
            assertThat(invokeFormatParameterValue(emptyList)).isEqualTo("()");

            String setResult = invokeFormatParameterValue(stringSet);
            assertThat(setResult).containsAnyOf("('a', 'b', 'c')", "('a', 'c', 'b')",
                                              "('b', 'a', 'c')", "('b', 'c', 'a')",
                                              "('c', 'a', 'b')", "('c', 'b', 'a')");
        }

        @Test
        @DisplayName("Should format array parameter values correctly")
        void testFormatArrayParameterValues() {
            // Given
            int[] intArray = {1, 2, 3};
            String[] stringArray = {"a", "b", "c"};
            long[] longArray = {100L, 200L, 300L};
            double[] doubleArray = {1.1, 2.2, 3.3};
            boolean[] boolArray = {true, false, true};

            // When & Then
            assertThat(invokeFormatParameterValue(intArray)).isEqualTo("(1, 2, 3)");
            assertThat(invokeFormatParameterValue(stringArray)).isEqualTo("('a', 'b', 'c')");
            assertThat(invokeFormatParameterValue(longArray)).isEqualTo("(100, 200, 300)");
            assertThat(invokeFormatParameterValue(doubleArray)).isEqualTo("(1.1, 2.2, 3.3)");
            assertThat(invokeFormatParameterValue(boolArray)).isEqualTo("(1, 0, 1)");
        }

        @Test
        @DisplayName("Should format enum parameter values correctly")
        void testFormatEnumParameterValues() {
            // Given
            enum TestEnum { VALUE1, VALUE2 }

            // When & Then
            assertThat(invokeFormatParameterValue(TestEnum.VALUE1)).isEqualTo("'VALUE1'");
            assertThat(invokeFormatParameterValue(TestEnum.VALUE2)).isEqualTo("'VALUE2'");
        }

        @Test
        @DisplayName("Should build executable SQL with no parameters")
        void testBuildExecutableSqlNoParameters() {
            // Given
            String sql = "SELECT * FROM users";
            when(boundSql.getSql()).thenReturn(sql);
            when(boundSql.getParameterMappings()).thenReturn(Collections.emptyList());

            // When
            String result = invokeBuildExecutableSql(configuration, boundSql, null);

            // Then
            assertThat(result).isEqualTo(sql);
        }

        @Test
        @DisplayName("Should build executable SQL with null parameter object")
        void testBuildExecutableSqlNullParameterObject() {
            // Given
            String sql = "SELECT * FROM users WHERE id = ? AND name = ?";
            List<ParameterMapping> mappings = Arrays.asList(mock(ParameterMapping.class), mock(ParameterMapping.class));
            when(boundSql.getSql()).thenReturn(sql);
            when(boundSql.getParameterMappings()).thenReturn(mappings);

            // When
            String result = invokeBuildExecutableSql(configuration, boundSql, null);

            // Then
            assertThat(result).isEqualTo("SELECT * FROM users WHERE id = NULL AND name = NULL");
        }

        @Test
        @DisplayName("Should build executable SQL with simple parameter")
        void testBuildExecutableSqlSimpleParameter() {
            // Given
            String sql = "SELECT * FROM users WHERE id = ?";
            List<ParameterMapping> mappings = Collections.singletonList(mock(ParameterMapping.class));
            when(boundSql.getSql()).thenReturn(sql);
            when(boundSql.getParameterMappings()).thenReturn(mappings);
            when(configuration.getTypeHandlerRegistry()).thenReturn(typeHandlerRegistry);
            when(typeHandlerRegistry.hasTypeHandler(Integer.class)).thenReturn(true);

            // When
            String result = invokeBuildExecutableSql(configuration, boundSql, 123);

            // Then
            assertThat(result).isEqualTo("SELECT * FROM users WHERE id = 123");
        }

        @Test
        @DisplayName("Should build executable SQL with complex parameters")
        void testBuildExecutableSqlComplexParameters() {
            // Given
            String sql = "SELECT * FROM users WHERE id = ? AND name = ?";
            ParameterMapping mapping1 = mock(ParameterMapping.class);
            ParameterMapping mapping2 = mock(ParameterMapping.class);
            when(mapping1.getProperty()).thenReturn("id");
            when(mapping2.getProperty()).thenReturn("name");

            List<ParameterMapping> mappings = Arrays.asList(mapping1, mapping2);
            when(boundSql.getSql()).thenReturn(sql);
            when(boundSql.getParameterMappings()).thenReturn(mappings);
            when(configuration.getTypeHandlerRegistry()).thenReturn(typeHandlerRegistry);
            when(typeHandlerRegistry.hasTypeHandler(any())).thenReturn(false);

            Map<String, Object> paramMap = new HashMap<>();
            paramMap.put("id", 123);
            paramMap.put("name", "John");

            when(configuration.newMetaObject(paramMap)).thenReturn(metaObject);
            when(metaObject.hasGetter("id")).thenReturn(true);
            when(metaObject.hasGetter("name")).thenReturn(true);
            when(metaObject.getValue("id")).thenReturn(123);
            when(metaObject.getValue("name")).thenReturn("John");

            // When
            String result = invokeBuildExecutableSql(configuration, boundSql, paramMap);

            // Then
            assertThat(result).isEqualTo("SELECT * FROM users WHERE id = 123 AND name = 'John'");
        }

        @Test
        @DisplayName("Should handle foreach parameters correctly")
        void testForeachParameters() {
            // Given
            String sql = "SELECT * FROM users WHERE id IN (?, ?, ?)";
            MapperMethod.ParamMap<Object> paramMap = new MapperMethod.ParamMap<>();
            paramMap.put("__frch_item_0", 1);
            paramMap.put("__frch_item_1", 2);
            paramMap.put("__frch_item_2", 3);

            ParameterMapping mapping1 = mock(ParameterMapping.class);
            ParameterMapping mapping2 = mock(ParameterMapping.class);
            ParameterMapping mapping3 = mock(ParameterMapping.class);
            when(mapping1.getProperty()).thenReturn("__frch_item_0");
            when(mapping2.getProperty()).thenReturn("__frch_item_1");
            when(mapping3.getProperty()).thenReturn("__frch_item_2");

            List<ParameterMapping> mappings = Arrays.asList(mapping1, mapping2, mapping3);
            when(boundSql.getSql()).thenReturn(sql);
            when(boundSql.getParameterMappings()).thenReturn(mappings);
            when(configuration.getTypeHandlerRegistry()).thenReturn(typeHandlerRegistry);
            when(typeHandlerRegistry.hasTypeHandler(any())).thenReturn(false);
            when(configuration.newMetaObject(paramMap)).thenReturn(metaObject);
            when(metaObject.hasGetter(anyString())).thenReturn(false);

            // When
            String result = invokeBuildExecutableSql(configuration, boundSql, paramMap);

            // Then
            assertThat(result).isEqualTo("SELECT * FROM users WHERE id IN (1, 2, 3)");
        }

        @Test
        @DisplayName("Should format SQL for readability when enabled")
        void testFormatSqlForReadability() {
            // Given
            String unformattedSql = "SELECT id, name FROM users WHERE status = 'active' AND created_date > '2024-01-01' ORDER BY created_date DESC";

            // When
            String result = invokeFormatSqlForReadability(unformattedSql);

            // Then
            assertThat(result).contains("\nSELECT");
            assertThat(result).contains("\nFROM");
            assertThat(result).contains("\nWHERE");
            assertThat(result).contains("\nAND");
            assertThat(result).contains("\nORDER BY");
        }

        @Test
        @DisplayName("Should not format SQL when disabled")
        void testFormatSqlDisabled() {
            // Given
            ReflectionTestUtils.setField(interceptor, "formatSql", false);
            String sql = "SELECT id FROM users WHERE status = 'active'";

            // When
            String result = invokeFormatSqlForReadability(sql);

            // Then
            assertThat(result).isEqualTo(sql);
        }

        @Test
        @DisplayName("Should handle additional parameters from BoundSql")
        void testAdditionalParameters() {
            // Given
            String sql = "SELECT * FROM users WHERE id = ?";
            ParameterMapping mapping = mock(ParameterMapping.class);
            when(mapping.getProperty()).thenReturn("additionalParam");

            List<ParameterMapping> mappings = Collections.singletonList(mapping);
            when(boundSql.getSql()).thenReturn(sql);
            when(boundSql.getParameterMappings()).thenReturn(mappings);
            when(boundSql.hasAdditionalParameter("additionalParam")).thenReturn(true);
            when(boundSql.getAdditionalParameter("additionalParam")).thenReturn("testValue");

            when(configuration.getTypeHandlerRegistry()).thenReturn(typeHandlerRegistry);
            when(typeHandlerRegistry.hasTypeHandler(any())).thenReturn(false);
            when(configuration.newMetaObject(any())).thenReturn(metaObject);
            when(metaObject.hasGetter("additionalParam")).thenReturn(false);

            // When
            String result = invokeBuildExecutableSql(configuration, boundSql, new Object());

            // Then
            assertThat(result).isEqualTo("SELECT * FROM users WHERE id = 'testValue'");
        }

        @Test
        @DisplayName("Should wrap target with plugin")
        void testPlugin() {
            // Given
            Object target = mock(Executor.class);

            // When
            Object result = interceptor.plugin(target);

            // Then
            assertThat(result).isNotNull();
            // Plugin.wrap creates a proxy, so the result should be different from target
            assertThat(result).isNotSameAs(target);
        }

        @Test
        @DisplayName("Should set properties correctly")
        void testSetProperties() {
            // Given
            Properties properties = new Properties();
            properties.setProperty("test.property", "test.value");

            // When & Then (should not throw exception)
            assertThatCode(() -> interceptor.setProperties(properties))
                .doesNotThrowAnyException();
        }

        @Test
        @DisplayName("Should handle logging exceptions gracefully")
        void testLoggingExceptionHandling() throws Throwable {
            // Given
            setupBasicMocks();
            when(mappedStatement.getBoundSql(any())).thenThrow(new RuntimeException("BoundSql error"));
            when(invocation.proceed()).thenReturn(new Object());

            // When & Then
            assertThatCode(() -> interceptor.intercept(invocation))
                .doesNotThrowAnyException();

            verify(logger).warn(contains("Failed to log SQL execution"));
        }

        @Test
        @DisplayName("Should calculate result count correctly")
        void testResultCount() {
            // Test with Collection
            List<String> listResult = Arrays.asList("a", "b", "c");
            assertThat(invokeGetResultCount(listResult)).isEqualTo("3");

            // Test with Integer (update/delete count)
            assertThat(invokeGetResultCount(5)).isEqualTo("5");

            // Test with single object
            assertThat(invokeGetResultCount(new Object())).isEqualTo("1");

            // Test with null
            assertThat(invokeGetResultCount(null)).isEqualTo("0");
        }

        @Test
        @DisplayName("Should escape SQL strings correctly")
        void testEscapeSqlString() {
            // Given
            String input1 = "John's car";
            String input2 = "It's a 'test'";
            String input3 = null;

            // When & Then
            assertThat(invokeEscapeSqlString(input1)).isEqualTo("John''s car");
            assertThat(invokeEscapeSqlString(input2)).isEqualTo("It''s a ''test''");
            assertThat(invokeEscapeSqlString(input3)).isEqualTo("");
        }

        // Helper methods for reflection-based invocations
        private void setupBasicMocks() throws Throwable {
            when(invocation.getArgs()).thenReturn(new Object[]{mappedStatement, new Object()});
            when(mappedStatement.getId()).thenReturn(TEST_SQL_ID);
            when(mappedStatement.getBoundSql(any())).thenReturn(boundSql);
            when(mappedStatement.getConfiguration()).thenReturn(configuration);
            when(boundSql.getSql()).thenReturn(TEST_SQL);
            when(boundSql.getParameterMappings()).thenReturn(Collections.emptyList());
        }

        private String invokeFormatParameterValue(Object value) {
            try {
                Method method = SqlLoggingInterceptor.class.getDeclaredMethod("formatParameterValue", Object.class);
                method.setAccessible(true);
                return (String) method.invoke(interceptor, value);
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        }

        private String invokeBuildExecutableSql(Configuration config, BoundSql boundSql, Object param) {
            try {
                Method method = SqlLoggingInterceptor.class.getDeclaredMethod(
                    "buildExecutableSql", Configuration.class, BoundSql.class, Object.class);
                method.setAccessible(true);
                return (String) method.invoke(interceptor, config, boundSql, param);
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        }

        private String invokeFormatSqlForReadability(String sql) {
            try {
                Method method = SqlLoggingInterceptor.class.getDeclaredMethod("formatSqlForReadability", String.class);
                method.setAccessible(true);
                return (String) method.invoke(interceptor, sql);
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        }

        private String invokeGetResultCount(Object result) {
            try {
                Method method = SqlLoggingInterceptor.class.getDeclaredMethod("getResultCount", Object.class);
                method.setAccessible(true);
                return (String) method.invoke(interceptor, result);
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        }

        private String invokeEscapeSqlString(String value) {
            try {
                Method method = SqlLoggingInterceptor.class.getDeclaredMethod("escapeSqlString", String.class);
                method.setAccessible(true);
                return (String) method.invoke(interceptor, value);
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        }
    }