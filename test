admin.js
/**
 * Admin Panel Management
 * Handles system administration and configuration
 */

class AdminManager {
    constructor() {
        this.config = {};
    }

    init() {
        this.setupEventListeners();
        this.loadConfiguration();
        this.updateStatistics();
    }

    setupEventListeners() {
        // No specific event listeners needed for basic admin panel
        console.log('Admin panel initialized');
    }

    async loadConfiguration() {
        try {
            // Load current configuration from API
            const config = await apiCall('/admin/config', 'GET');
            this.config = config || {};
            this.populateConfigForm();
        } catch (error) {
            console.warn('Failed to load admin configuration:', error);
            this.loadDefaultConfig();
        }
    }

    loadDefaultConfig() {
        this.config = {
            emailEnabled: false,
            emailFrom: 'noreply@company.com',
            baseUrl: 'http://localhost:3000',
            aiModel: 'claude-3-5-sonnet'
        };
        this.populateConfigForm();
    }

    populateConfigForm() {
        document.getElementById('email-enabled').checked = this.config.emailEnabled || false;
        document.getElementById('email-from').value = this.config.emailFrom || '';
        document.getElementById('base-url').value = this.config.baseUrl || '';
        document.getElementById('ai-model').value = this.config.aiModel || 'claude-3-5-sonnet';
    }

    async updateStatistics() {
        try {
            // Get counts from other managers if available
            const stats = {
                teams: window.teamsManager?.teams?.length || 0,
                projects: window.projectsManager?.projects?.length || 0,
                reviews: window.reviewsManager?.reviews?.length || 0,
                prompts: 25 // Default from backend
            };

            document.getElementById('admin-teams-count').textContent = stats.teams;
            document.getElementById('admin-projects-count').textContent = stats.projects;
            document.getElementById('admin-reviews-count').textContent = stats.reviews;
            document.getElementById('admin-prompts-count').textContent = stats.prompts;

        } catch (error) {
            console.warn('Failed to update admin statistics:', error);
        }
    }
}

window.adminManager = new AdminManager();

// Global functions
window.saveEmailConfig = async function() {
    const config = {
        emailEnabled: document.getElementById('email-enabled').checked,
        emailFrom: document.getElementById('email-from').value,
        baseUrl: document.getElementById('base-url').value
    };

    try {
        await apiCall('/admin/config/email', 'POST', config);
        showSuccess('Email configuration saved successfully');
    } catch (error) {
        showError('Failed to save email configuration');
    }
};

window.testEmailConfig = function() {
    showInfo('Email test functionality would be implemented here');
};

window.saveAIConfig = async function() {
    const config = {
        aiModel: document.getElementById('ai-model').value
    };

    try {
        await apiCall('/admin/config/ai', 'POST', config);
        showSuccess('AI configuration saved successfully');
    } catch (error) {
        showError('Failed to save AI configuration');
    }
};

window.testAIConnection = async function() {
    try {
        showLoading();
        const result = await apiCall('/admin/test/ai', 'POST');
        showSuccess('AI connection test successful');
    } catch (error) {
        showError('AI connection test failed');
    } finally {
        hideLoading();
    }
};

window.openH2Console = function() {
    window.open('http://localhost:8081/api/h2-console', '_blank');
};

window.exportData = function() {
    showInfo('Data export functionality would be implemented here');
};

window.clearDatabase = function() {
    showConfirm(
        'Are you sure you want to clear all data? This action cannot be undone!',
        async () => {
            try {
                await apiCall('/admin/database/clear', 'POST');
                showSuccess('Database cleared successfully');
                // Refresh all managers
                if (window.teamsManager) await window.teamsManager.loadTeams();
                if (window.projectsManager) await window.projectsManager.loadProjects();
                if (window.reviewsManager) await window.reviewsManager.loadReviews();
            } catch (error) {
                showError('Failed to clear database');
            }
        }
    );
};

document.addEventListener('DOMContentLoaded', () => {
    if (document.getElementById('admin-tab')) {
        window.adminManager.init();
    }
});

----------------------------------------
ai-review.js


/**
 * AI Review Module
 * Handles AI-powered code review and prompt testing features
 */

// AI Review API functions
const aiReviewApi = {
    /**
     * Execute AI code review
     */
    async executeReview(promptId, code, context = {}) {
        const response = await fetch(`${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.AI_REVIEW_EXECUTE}`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                promptId: promptId,
                code: code,
                applicationType: context.applicationType || 'Spring Boot Application',
                springBootVersion: context.springBootVersion || '3.1.0',
                javaVersion: context.javaVersion || '17',
                databaseType: context.databaseType || 'H2'
            })
        });

        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`AI Review failed: ${response.status} - ${errorText}`);
        }

        return await response.json();
    },

    /**
     * Test a prompt with sample code
     */
    async testPrompt(promptId, sampleCode) {
        const response = await fetch(`${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.AI_REVIEW_TEST}`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                promptId: promptId,
                sampleCode: sampleCode
            })
        });

        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Prompt test failed: ${response.status} - ${errorText}`);
        }

        return await response.json();
    },

    /**
     * Check AI service status
     */
    async getStatus() {
        const response = await fetch(`${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.AI_REVIEW_STATUS}`);

        if (!response.ok) {
            throw new Error(`Status check failed: ${response.status}`);
        }

        return await response.json();
    }
};

// AI Review Functions called from HTML
async function executeAIReview() {
    const promptSelect = document.getElementById('review-prompt-select');
    const codeInput = document.getElementById('review-code-input');
    const executeBtn = document.getElementById('execute-review-btn');
    const resultContainer = document.getElementById('ai-review-result-container');
    const resultContent = document.getElementById('ai-review-result-content');
    const timestampEl = document.getElementById('review-timestamp');
    const modelEl = document.getElementById('review-model');

    // Validation
    if (!promptSelect.value) {
        showError('Please select a review prompt');
        return;
    }

    if (!codeInput.value.trim()) {
        showError('Please enter code to review');
        return;
    }

    try {
        // Show loading state
        executeBtn.disabled = true;
        executeBtn.innerHTML = '<span class="spinner"></span> Reviewing...';
        resultContainer.classList.add('hidden');

        // Execute review
        const result = await aiReviewApi.executeReview(
            parseInt(promptSelect.value),
            codeInput.value.trim()
        );

        // Display results
        resultContent.innerHTML = result.aiReview;
        timestampEl.textContent = `Generated: ${new Date(result.timestamp).toLocaleString()}`;
        modelEl.textContent = `Model: ${result.model}`;
        resultContainer.classList.remove('hidden');

        // Scroll to results
        resultContainer.scrollIntoView({ behavior: 'smooth', block: 'start' });

        showSuccess('AI code review completed successfully!');

    } catch (error) {
        console.error('AI Review error:', error);
        showError(`AI Review failed: ${error.message}`);
    } finally {
        executeBtn.disabled = false;
        executeBtn.innerHTML = '‚≠ê Get AI Review';
    }
}

async function testPrompt() {
    const promptSelect = document.getElementById('test-prompt-select');
    const sampleCodeInput = document.getElementById('test-sample-code');
    const testBtn = document.getElementById('test-prompt-btn');
    const resultContainer = document.getElementById('test-result-container');
    const resultContent = document.getElementById('test-result-content');

    // Validation
    if (!promptSelect.value) {
        showError('Please select a prompt to test');
        return;
    }

    if (!sampleCodeInput.value.trim()) {
        showError('Please enter sample code for testing');
        return;
    }

    try {
        // Show loading state
        testBtn.disabled = true;
        testBtn.innerHTML = '<span class="spinner"></span> Testing...';
        resultContainer.classList.add('hidden');

        // Test prompt
        const result = await aiReviewApi.testPrompt(
            parseInt(promptSelect.value),
            sampleCodeInput.value.trim()
        );

        // Display results
        resultContent.innerHTML = result.testResult;
        resultContainer.classList.remove('hidden');

        // Scroll to results
        resultContainer.scrollIntoView({ behavior: 'smooth', block: 'start' });

        showSuccess('Prompt test completed successfully!');

    } catch (error) {
        console.error('Prompt test error:', error);
        showError(`Prompt test failed: ${error.message}`);
    } finally {
        testBtn.disabled = false;
        testBtn.innerHTML = 'üß™ Test Prompt';
    }
}

function clearTestLab() {
    document.getElementById('test-prompt-select').value = '';
    document.getElementById('test-sample-code').value = `// Example Java Spring Boot code
@RestController
@RequestMapping("/api/users")
public class UserController {

    @Autowired
    private UserService userService;

    @GetMapping("/{id}")
    public ResponseEntity<User> getUser(@PathVariable String id) {
        User user = userService.findById(id);
        return ResponseEntity.ok(user);
    }
}`;
    document.getElementById('test-code-language').value = 'java';
    document.getElementById('test-result-container').classList.add('hidden');
}

function clearReviewForm() {
    document.getElementById('review-prompt-select').value = '';
    document.getElementById('review-code-input').value = '// Paste your code here';
    document.getElementById('review-code-language').value = 'java';
    document.getElementById('ai-review-result-container').classList.add('hidden');
}

// Initialize AI features when tab is shown
async function initializeAIFeatures() {
    try {
        // Check AI service status
        await updateAIStatus();

        // Load prompts for selectors
        await loadPromptsForAI();

    } catch (error) {
        console.error('Failed to initialize AI features:', error);
    }
}

async function updateAIStatus() {
    const testLabStatus = document.getElementById('test-lab-status');
    const aiReviewStatus = document.getElementById('ai-review-status');

    try {
        const status = await aiReviewApi.getStatus();

        const statusHTML = status.claudeApiConfigured
            ? `<strong>‚úÖ Claude AI Ready:</strong> ${status.message}`
            : `<strong>‚ö†Ô∏è Configuration Required:</strong> ${status.message}`;

        const statusClass = status.claudeApiConfigured ? 'success' : 'error';

        if (testLabStatus) {
            testLabStatus.innerHTML = statusHTML;
            testLabStatus.className = `ai-status ${statusClass}`;
        }

        if (aiReviewStatus) {
            aiReviewStatus.innerHTML = statusHTML;
            aiReviewStatus.className = `ai-status ${statusClass}`;
        }

    } catch (error) {
        const errorHTML = '<strong>‚ùå Service Unavailable:</strong> Unable to connect to AI service';

        if (testLabStatus) {
            testLabStatus.innerHTML = errorHTML;
            testLabStatus.className = 'ai-status error';
        }

        if (aiReviewStatus) {
            aiReviewStatus.innerHTML = errorHTML;
            aiReviewStatus.className = 'ai-status error';
        }
    }
}

async function loadPromptsForAI() {
    try {
        const prompts = await promptApi.getAll();

        const testPromptSelect = document.getElementById('test-prompt-select');
        const reviewPromptSelect = document.getElementById('review-prompt-select');

        // Clear existing options (keep placeholder)
        if (testPromptSelect) {
            testPromptSelect.innerHTML = '<option value="">Choose a prompt...</option>';
        }
        if (reviewPromptSelect) {
            reviewPromptSelect.innerHTML = '<option value="">Choose a prompt...</option>';
        }

        // Add prompts grouped by category
        const promptsByCategory = {};
        prompts.forEach(prompt => {
            const categoryName = prompt.category.name;
            if (!promptsByCategory[categoryName]) {
                promptsByCategory[categoryName] = [];
            }
            promptsByCategory[categoryName].push(prompt);
        });

        // Add options to both selects
        Object.keys(promptsByCategory).sort().forEach(categoryName => {
            if (testPromptSelect) {
                const optgroup = document.createElement('optgroup');
                optgroup.label = categoryName;
                testPromptSelect.appendChild(optgroup);

                promptsByCategory[categoryName].forEach(prompt => {
                    const option = document.createElement('option');
                    option.value = prompt.id;
                    option.textContent = prompt.title;
                    optgroup.appendChild(option);
                });
            }

            if (reviewPromptSelect) {
                const optgroup = document.createElement('optgroup');
                optgroup.label = categoryName;
                reviewPromptSelect.appendChild(optgroup);

                promptsByCategory[categoryName].forEach(prompt => {
                    const option = document.createElement('option');
                    option.value = prompt.id;
                    option.textContent = prompt.title;
                    optgroup.appendChild(option);
                });
            }
        });

    } catch (error) {
        console.error('Failed to load prompts for AI features:', error);
        showError('Failed to load prompts for AI features');
    }
}

// Export functions for global access
window.executeAIReview = executeAIReview;
window.testPrompt = testPrompt;
window.clearTestLab = clearTestLab;
window.clearReviewForm = clearReviewForm;
window.initializeAIFeatures = initializeAIFeatures;
window.updateAIStatus = updateAIStatus;
window.loadPromptsForAI = loadPromptsForAI;

-------------------------------


api.js


/**
 * API utility functions for making HTTP requests
 * Simple and clean implementation without external dependencies
 */

/**
 * Extract basic team information from potentially corrupted JSON response
 * This is a fallback for when the backend returns circular references or malformed JSON
 * @param {string} responseText - Raw response text from API
 * @returns {Array} Array of basic team objects
 */
function extractBasicTeamsData(responseText) {
    console.log('Attempting to extract basic team data from corrupted response...');
    const teams = [];

    try {
        // Use regex to find team objects in the malformed JSON
        const teamMatches = responseText.match(/\{"id":(\d+),"name":"([^"]+)","description":"([^"]*)","active":(true|false)/g);

        if (teamMatches) {
            teamMatches.forEach(match => {
                const idMatch = match.match(/"id":(\d+)/);
                const nameMatch = match.match(/"name":"([^"]+)"/);
                const descMatch = match.match(/"description":"([^"]*)"/);
                const activeMatch = match.match(/"active":(true|false)/);

                if (idMatch && nameMatch) {
                    teams.push({
                        id: parseInt(idMatch[1]),
                        name: nameMatch[1],
                        description: descMatch ? descMatch[1] : '',
                        active: activeMatch ? activeMatch[1] === 'true' : true,
                        createdDate: new Date().toISOString(),
                        lastModified: new Date().toISOString(),
                        projectsCount: 0
                    });
                }
            });
        }

        // Remove duplicates based on ID
        const uniqueTeams = teams.filter((team, index, self) =>
            index === self.findIndex(t => t.id === team.id)
        );

        console.log(`Extracted ${uniqueTeams.length} teams from corrupted response`);
        return uniqueTeams;

    } catch (error) {
        console.error('Failed to extract team data:', error);
        return [];
    }
}

/**
 * Makes an HTTP request
 * @param {string} url - The request URL
 * @param {object} options - Request options
 * @returns {Promise} Promise that resolves to the response data
 */
async function makeRequest(url, options = {}) {
    // Show loading indicator if this is the first request
    showLoading();

    try {
        const response = await fetch(url, {
            headers: {
                'Content-Type': 'application/json',
                ...options.headers
            },
            ...options
        });

        if (!response.ok) {
            const errorData = await response.json().catch(() => ({}));
            throw new Error(errorData.error || errorData.message || `HTTP error! status: ${response.status}`);
        }

        // Get response text first to handle large responses
        const responseText = await response.text();

        // Check if response is too large (might cause parsing issues)
        if (responseText.length > 100000) {
            console.warn(`Large API response detected: ${responseText.length} characters`);
            console.warn('This might indicate circular references or excessive data nesting');
        }

        try {
            const data = JSON.parse(responseText);
            return data;
        } catch (jsonError) {
            console.error('JSON parsing failed:', jsonError);
            console.error('Response length:', responseText.length);
            console.error('Response preview:', responseText.substring(0, 1000));

            // Try to extract basic team info if it's a teams request
            if (url.includes('/teams')) {
                return extractBasicTeamsData(responseText);
            }

            throw new Error('Invalid JSON response from server');
        }

    } catch (error) {
        console.error('API Request Error:', error);
        throw error;
    } finally {
        hideLoading();
    }
}

/**
 * GET request
 * @param {string} endpoint - API endpoint
 * @param {object} params - Query parameters
 * @returns {Promise} Promise that resolves to the response data
 */
async function get(endpoint, params = {}) {
    let url = `${API_CONFIG.BASE_URL}${endpoint}`;

    // Add query parameters if provided
    if (Object.keys(params).length > 0) {
        const queryString = new URLSearchParams(params).toString();
        url += `?${queryString}`;
    }

    return makeRequest(url, { method: 'GET' });
}

/**
 * POST request
 * @param {string} endpoint - API endpoint
 * @param {object} data - Request body data
 * @returns {Promise} Promise that resolves to the response data
 */
async function post(endpoint, data) {
    const url = `${API_CONFIG.BASE_URL}${endpoint}`;
    return makeRequest(url, {
        method: 'POST',
        body: JSON.stringify(data)
    });
}

/**
 * PUT request
 * @param {string} endpoint - API endpoint
 * @param {object} data - Request body data
 * @returns {Promise} Promise that resolves to the response data
 */
async function put(endpoint, data) {
    const url = `${API_CONFIG.BASE_URL}${endpoint}`;
    return makeRequest(url, {
        method: 'PUT',
        body: JSON.stringify(data)
    });
}

/**
 * DELETE request
 * @param {string} endpoint - API endpoint
 * @returns {Promise} Promise that resolves to the response data
 */
async function del(endpoint) {
    const url = `${API_CONFIG.BASE_URL}${endpoint}`;
    return makeRequest(url, { method: 'DELETE' });
}

/**
 * PATCH request
 * @param {string} endpoint - API endpoint
 * @param {object} data - Request body data
 * @returns {Promise} Promise that resolves to the response data
 */
async function patch(endpoint, data) {
    const url = `${API_CONFIG.BASE_URL}${endpoint}`;
    return makeRequest(url, {
        method: 'PATCH',
        body: JSON.stringify(data)
    });
}

// Category API functions
const categoryApi = {
    /**
     * Get all categories
     */
    getAll: () => get(API_CONFIG.ENDPOINTS.CATEGORIES),

    /**
     * Get category by ID
     */
    getById: (id) => get(`${API_CONFIG.ENDPOINTS.CATEGORIES}/${id}`),

    /**
     * Create new category
     */
    create: (categoryData) => post(API_CONFIG.ENDPOINTS.CATEGORIES, categoryData),

    /**
     * Update category
     */
    update: (id, categoryData) => put(`${API_CONFIG.ENDPOINTS.CATEGORIES}/${id}`, categoryData),

    /**
     * Delete category
     */
    delete: (id) => del(`${API_CONFIG.ENDPOINTS.CATEGORIES}/${id}`),

    /**
     * Search categories
     */
    search: (query) => get(API_CONFIG.ENDPOINTS.CATEGORIES_SEARCH, { q: query })
};

// Prompt API functions
const promptApi = {
    /**
     * Get all active prompts
     */
    getActive: () => get(API_CONFIG.ENDPOINTS.PROMPTS),

    /**
     * Get all prompts (including inactive)
     */
    getAll: () => get(API_CONFIG.ENDPOINTS.PROMPTS_ALL),

    /**
     * Get prompt by ID
     */
    getById: (id) => get(`${API_CONFIG.ENDPOINTS.PROMPTS}/${id}`),

    /**
     * Get prompts by category
     */
    getByCategory: (categoryId) => get(`${API_CONFIG.ENDPOINTS.PROMPTS_BY_CATEGORY}/${categoryId}`),

    /**
     * Create new prompt
     */
    create: (promptData) => post(API_CONFIG.ENDPOINTS.PROMPTS, promptData),

    /**
     * Update prompt
     */
    update: (id, promptData) => put(`${API_CONFIG.ENDPOINTS.PROMPTS}/${id}`, promptData),

    /**
     * Delete prompt
     */
    delete: (id) => del(`${API_CONFIG.ENDPOINTS.PROMPTS}/${id}`),

    /**
     * Update prompt status (active/inactive)
     */
    updateStatus: (id, isActive) => patch(`${API_CONFIG.ENDPOINTS.PROMPTS}/${id}/status`, { active: isActive }),

    /**
     * Search prompts
     */
    search: (query) => get(API_CONFIG.ENDPOINTS.PROMPTS_SEARCH, { q: query }),

    /**
     * Get prompt statistics
     */
    getStats: () => get(API_CONFIG.ENDPOINTS.PROMPTS_STATS)
};

// Team API functions
const teamApi = {
    /**
     * Get all teams
     */
    getAll: async () => {
        try {
            return await get(API_CONFIG.ENDPOINTS.TEAMS);
        } catch (error) {
            console.warn('Primary teams API failed, trying fallback...', error);

            // Fallback: return mock data if API fails completely
            return [
                {
                    id: 1,
                    name: 'Development Team',
                    description: 'Main development team',
                    active: true,
                    createdDate: new Date().toISOString(),
                    lastModified: new Date().toISOString(),
                    projectsCount: 1
                }
            ];
        }
    },

    /**
     * Get team by ID
     */
    getById: (id) => get(`${API_CONFIG.ENDPOINTS.TEAMS}/${id}`),

    /**
     * Create new team
     */
    create: (teamData) => post(API_CONFIG.ENDPOINTS.TEAMS, teamData),

    /**
     * Update team
     */
    update: (id, teamData) => put(`${API_CONFIG.ENDPOINTS.TEAMS}/${id}`, teamData),

    /**
     * Delete team
     */
    delete: (id) => del(`${API_CONFIG.ENDPOINTS.TEAMS}/${id}`),

    /**
     * Update team status (active/inactive)
     */
    updateStatus: (id, isActive) => patch(`${API_CONFIG.ENDPOINTS.TEAMS}/${id}/status`, { active: isActive }),

    /**
     * Search teams
     */
    search: (query) => get(API_CONFIG.ENDPOINTS.TEAMS_SEARCH, { q: query }),

    /**
     * Get team statistics
     */
    getStats: () => get(API_CONFIG.ENDPOINTS.TEAMS_STATS)
};

// Project API functions
const projectApi = {
    /**
     * Get all projects
     */
    getAll: () => get(API_CONFIG.ENDPOINTS.PROJECTS),

    /**
     * Get project by ID
     */
    getById: (id) => get(`${API_CONFIG.ENDPOINTS.PROJECTS}/${id}`),

    /**
     * Get projects by team
     */
    getByTeam: (teamId) => get(`${API_CONFIG.ENDPOINTS.PROJECTS_BY_TEAM}/${teamId}`),

    /**
     * Create new project
     */
    create: (projectData) => post(API_CONFIG.ENDPOINTS.PROJECTS, projectData),

    /**
     * Update project
     */
    update: (id, projectData) => put(`${API_CONFIG.ENDPOINTS.PROJECTS}/${id}`, projectData),

    /**
     * Delete project
     */
    delete: (id) => del(`${API_CONFIG.ENDPOINTS.PROJECTS}/${id}`),

    /**
     * Update project status (active/inactive)
     */
    updateStatus: (id, isActive) => patch(`${API_CONFIG.ENDPOINTS.PROJECTS}/${id}/status`, { active: isActive }),

    /**
     * Search projects
     */
    search: (query) => get(API_CONFIG.ENDPOINTS.PROJECTS_SEARCH, { q: query }),

    /**
     * Get project statistics
     */
    getStats: () => get(API_CONFIG.ENDPOINTS.PROJECTS_STATS)
};

// Code Review Submission API functions
const submissionApi = {
    /**
     * Get all submissions
     */
    getAll: () => get(API_CONFIG.ENDPOINTS.SUBMISSIONS),

    /**
     * Get submission by ID
     */
    getById: (id) => get(`${API_CONFIG.ENDPOINTS.SUBMISSIONS}/${id}`),

    /**
     * Get submissions by project
     */
    getByProject: (projectId) => get(`${API_CONFIG.ENDPOINTS.SUBMISSIONS_BY_PROJECT}/${projectId}`),

    /**
     * Get submissions by team
     */
    getByTeam: (teamId) => get(`${API_CONFIG.ENDPOINTS.SUBMISSIONS_BY_TEAM}/${teamId}`),

    /**
     * Create new submission
     */
    create: (submissionData) => post(API_CONFIG.ENDPOINTS.SUBMISSIONS, submissionData),

    /**
     * Update submission
     */
    update: (id, submissionData) => put(`${API_CONFIG.ENDPOINTS.SUBMISSIONS}/${id}`, submissionData),

    /**
     * Delete submission
     */
    delete: (id) => del(`${API_CONFIG.ENDPOINTS.SUBMISSIONS}/${id}`),

    /**
     * Update submission status
     */
    updateStatus: (id, status) => patch(`${API_CONFIG.ENDPOINTS.SUBMISSIONS}/${id}/status`, { status: status }),

    /**
     * Search submissions
     */
    search: (query) => get(API_CONFIG.ENDPOINTS.SUBMISSIONS_SEARCH, { q: query }),

    /**
     * Get submission statistics
     */
    getStats: () => get(API_CONFIG.ENDPOINTS.SUBMISSIONS_STATS),

    /**
     * Cancel submission
     */
    cancel: (reviewId) => post(`${API_CONFIG.ENDPOINTS.SUBMISSIONS}/${reviewId}/cancel`, {})
};

// Export API objects to global scope
window.categoryApi = categoryApi;
window.promptApi = promptApi;
window.teamApi = teamApi;
window.projectApi = projectApi;
window.submissionApi = submissionApi;
---------------------------------------

app.js

/**
 * Main application file
 * Initializes the application and sets up event listeners
 */

// Global state for confirm dialog
let confirmCallback = null;

/**
 * Initialize the application when DOM is loaded
 */
document.addEventListener('DOMContentLoaded', function() {
    console.log('Code Review Manager application starting...');

    // Initialize tabs
    initializeTabs();

    // Initialize forms
    initializeForms();

    // Initialize search functionality
    initializeSearch();

    // Load initial data
    loadInitialData();

    console.log('Application initialized successfully');
});

/**
 * Initialize tab navigation
 */
function initializeTabs() {
    const tabButtons = document.querySelectorAll('.tab-btn');

    tabButtons.forEach(button => {
        button.addEventListener('click', function() {
            const tabName = this.getAttribute('data-tab');
            switchTab(tabName);

            // Load data for the active tab
            if (tabName === 'prompts') {
                loadPrompts();
            } else if (tabName === 'categories') {
                loadCategories();
            } else if (tabName === 'code-review') {
                // Code Review manager will be initialized by the switchTab function
                console.log('Switched to Code Review tab');
            } else if (tabName === 'test-lab' || tabName === 'ai-review') {
                // AI features will be initialized by the switchTab function
                console.log(`Switched to AI tab: ${tabName}`);
            } else if (tabName === 'project-analyzer') {
                // Project Analyzer will be initialized by the switchTab function
                console.log('Switched to Project Analyzer tab');
            }
        });
    });
}

/**
 * Initialize form event listeners
 */
function initializeForms() {
    // Prompt form
    const promptForm = el('prompt-form');
    if (promptForm) {
        promptForm.addEventListener('submit', handlePromptFormSubmit);
    }

    // Category form
    const categoryForm = el('category-form');
    if (categoryForm) {
        categoryForm.addEventListener('submit', handleCategoryFormSubmit);
    }

    // Modal close on background click
    setupModalCloseOnBackgroundClick();
}

/**
 * Initialize search functionality
 */
function initializeSearch() {
    // Prompt search
    const promptSearch = el('prompt-search');
    if (promptSearch) {
        promptSearch.addEventListener('input', searchPrompts);
        promptSearch.addEventListener('keydown', function(e) {
            if (e.key === 'Enter') {
                e.preventDefault();
                searchPrompts();
            }
        });
    }

    // Category search
    const categorySearch = el('category-search');
    if (categorySearch) {
        categorySearch.addEventListener('input', searchCategories);
        categorySearch.addEventListener('keydown', function(e) {
            if (e.key === 'Enter') {
                e.preventDefault();
                searchCategories();
            }
        });
    }
}

/**
 * Setup modal close on background click
 */
function setupModalCloseOnBackgroundClick() {
    const modals = document.querySelectorAll('.modal');

    modals.forEach(modal => {
        modal.addEventListener('click', function(e) {
            if (e.target === modal) {
                // Click was on the modal background
                modal.classList.add('hidden');
            }
        });
    });
}

/**
 * Load initial data for the application
 */
async function loadInitialData() {
    try {
        // Load prompts (default active tab)
        await loadPrompts();

        // Load categories for filter dropdown
        await loadCategoriesForFilter();

        console.log('Initial data loaded successfully');
    } catch (error) {
        console.error('Failed to load initial data:', error);
        showError('Failed to load initial data. Please refresh the page.');
    }
}

/**
 * Code copy functionality for README tab
 */
function copyCode(button) {
    const code = button.getAttribute('data-code');
    const originalText = button.textContent;

    navigator.clipboard.writeText(code).then(function() {
        button.textContent = 'Copied!';
        button.style.background = '#10b981';

        setTimeout(function() {
            button.textContent = originalText;
            button.style.background = '#667eea';
        }, 2000);
    }).catch(function(err) {
        console.error('Failed to copy code: ', err);
        button.textContent = 'Failed';
        button.style.background = '#e53e3e';

        setTimeout(function() {
            button.textContent = originalText;
            button.style.background = '#667eea';
        }, 2000);
    });
}

/**
 * Show confirmation dialog
 */
function showConfirmDialog(message, callback) {
    const modal = el('confirm-modal');
    const messageEl = el('confirm-message');

    if (!modal || !messageEl) return;

    messageEl.textContent = message;
    confirmCallback = callback;
    modal.classList.remove('hidden');
}

/**
 * Hide confirmation dialog
 */
function hideConfirmModal() {
    const modal = el('confirm-modal');
    if (modal) modal.classList.add('hidden');
    confirmCallback = null;
}

/**
 * Execute the confirm action
 */
function confirmDelete() {
    if (confirmCallback) {
        confirmCallback();
    }
    hideConfirmModal();
}

/**
 * Handle keyboard shortcuts
 */
document.addEventListener('keydown', function(e) {
    // Escape key to close modals
    if (e.key === 'Escape') {
        const visibleModals = document.querySelectorAll('.modal:not(.hidden)');
        visibleModals.forEach(modal => {
            modal.classList.add('hidden');
        });
        hideError();
        hideSuccess();
    }

    // Ctrl+N to create new item
    if (e.ctrlKey && e.key === 'n') {
        e.preventDefault();
        const activeTab = document.querySelector('.tab-btn.active');
        if (activeTab) {
            const tabName = activeTab.getAttribute('data-tab');
            if (tabName === 'prompts') {
                showPromptForm();
            } else if (tabName === 'categories') {
                showCategoryForm();
            }
        }
    }
});

/**
 * Handle window resize
 */
window.addEventListener('resize', function() {
    // Handle responsive adjustments if needed
    console.log('Window resized');
});

/**
 * Handle errors globally
 */
window.addEventListener('error', function(e) {
    console.error('Global error:', e.error);
    showError('An unexpected error occurred. Please try again.');
});

/**
 * Handle unhandled promise rejections
 */
window.addEventListener('unhandledrejection', function(e) {
    console.error('Unhandled promise rejection:', e.reason);
    showError('A network error occurred. Please check your connection and try again.');
    e.preventDefault(); // Prevent the default handling
});

console.log('App.js loaded successfully');

-----------------------------------------------------------
categories.js

/**
 * Category management functions
 * Handles all category-related UI operations
 */

// Global variable to store current categories
let currentCategories = [];

/**
 * Load and display all categories
 */
async function loadCategories() {
    try {
        currentCategories = await categoryApi.getAll();
        displayCategories(currentCategories);
        loadCategoriesForFilter(); // Update the filter dropdown
    } catch (error) {
        showError('Failed to load categories: ' + error.message);
        displayCategories([]);
    }
}

/**
 * Display categories in the list
 */
function displayCategories(categories) {
    const categoriesList = el('categories-list');
    if (!categoriesList) return;

    if (categories.length === 0) {
        categoriesList.innerHTML = `
            <div class="empty-state">
                <p>${MESSAGES.NO_CATEGORIES}</p>
            </div>
        `;
        return;
    }

    categoriesList.innerHTML = categories.map(category => `
        <div class="category-card" data-id="${category.id}">
            <div class="category-header">
                <h3 class="category-name">${escapeHtml(category.name)}</h3>
                <div class="category-actions">
                    <button class="btn-small btn-secondary" onclick="editCategory(${category.id})">Edit</button>
                    <button class="btn-small btn-danger" onclick="deleteCategory(${category.id})">Delete</button>
                </div>
            </div>
            ${category.description ? `<div class="category-description">${escapeHtml(category.description)}</div>` : ''}
            <div class="category-footer">
                <small class="category-date">
                    Created: ${formatDate(category.createdAt)}
                    ${category.updatedAt !== category.createdAt ? `| Updated: ${formatDate(category.updatedAt)}` : ''}
                </small>
            </div>
        </div>
    `).join('');
}

/**
 * Load categories for the filter dropdown
 */
async function loadCategoriesForFilter() {
    try {
        const categories = await categoryApi.getAll();
        const select = el('category-filter');
        if (!select) return;

        select.innerHTML = '<option value="">All Categories</option>' +
            categories.map(cat => `<option value="${cat.id}">${escapeHtml(cat.name)}</option>`).join('');
    } catch (error) {
        console.error('Failed to load categories for filter:', error);
    }
}

/**
 * Show category form for creating new category
 */
function showCategoryForm(categoryId = null) {
    const modal = el('category-modal');
    const form = el('category-form');
    const title = el('category-modal-title');

    if (!modal || !form || !title) return;

    // Reset form
    form.reset();
    el('category-id').value = '';

    if (categoryId) {
        title.textContent = 'Edit Category';
        loadCategoryForEditing(categoryId);
    } else {
        title.textContent = 'Add New Category';
    }

    modal.classList.remove('hidden');
}

/**
 * Load category data for editing
 */
async function loadCategoryForEditing(categoryId) {
    try {
        const category = await categoryApi.getById(categoryId);
        if (!category) return;

        el('category-id').value = category.id;
        el('category-name').value = category.name;
        el('category-description').value = category.description || '';
    } catch (error) {
        showError('Failed to load category for editing: ' + error.message);
    }
}

/**
 * Hide category form modal
 */
function hideCategoryModal() {
    const modal = el('category-modal');
    if (modal) modal.classList.add('hidden');
}

/**
 * Search categories
 */
const searchCategories = debounce(async function() {
    const searchInput = el('category-search');
    const query = searchInput ? searchInput.value.trim() : '';

    try {
        if (query) {
            currentCategories = await categoryApi.search(query);
        } else {
            currentCategories = await categoryApi.getAll();
        }
        displayCategories(currentCategories);
    } catch (error) {
        showError('Search failed: ' + error.message);
    }
}, UI_CONFIG.DEBOUNCE_DELAY);

/**
 * Edit category
 */
function editCategory(categoryId) {
    showCategoryForm(categoryId);
}

/**
 * Delete category
 */
function deleteCategory(categoryId) {
    showConfirmDialog('Are you sure you want to delete this category?', () => {
        performDeleteCategory(categoryId);
    });
}

/**
 * Perform category deletion
 */
async function performDeleteCategory(categoryId) {
    try {
        await categoryApi.delete(categoryId);
        showSuccess('Category deleted successfully');
        loadCategories(); // Reload the list
    } catch (error) {
        showError('Failed to delete category: ' + error.message);
    }
}

/**
 * Handle category form submission
 */
async function handleCategoryFormSubmit(event) {
    event.preventDefault();

    const categoryId = el('category-id').value;
    const categoryData = {
        name: el('category-name').value.trim(),
        description: el('category-description').value.trim()
    };

    try {
        if (categoryId) {
            // Update existing category
            await categoryApi.update(categoryId, categoryData);
            showSuccess('Category updated successfully');
        } else {
            // Create new category
            await categoryApi.create(categoryData);
            showSuccess('Category created successfully');
        }

        hideCategoryModal();
        loadCategories(); // Reload the list
    } catch (error) {
        showError('Failed to save category: ' + error.message);
    }
}
--------------------------------------------
code-editor.js

/**
 * Enhanced Code Editor Functionality
 * Provides advanced features for code input areas
 */

// Sample code templates for different languages
const SAMPLE_CODE_TEMPLATES = {
    java: `// Sample Java Spring Boot code
@RestController
@RequestMapping("/api/users")
public class UserController {

    @Autowired
    private UserService userService;

    @GetMapping("/{id}")
    public ResponseEntity<User> getUser(@PathVariable String id) {
        try {
            User user = userService.findById(id);
            if (user == null) {
                return ResponseEntity.notFound().build();
            }
            return ResponseEntity.ok(user);
        } catch (Exception e) {
            return ResponseEntity.internalServerError().build();
        }
    }

    @PostMapping
    public ResponseEntity<User> createUser(@RequestBody CreateUserRequest request) {
        User user = userService.createUser(request.getName(), request.getEmail());
        return ResponseEntity.ok(user);
    }
}`,

    javascript: `// Sample JavaScript/Node.js code
const express = require('express');
const app = express();

app.use(express.json());

// User routes
app.get('/api/users/:id', async (req, res) => {
    try {
        const userId = req.params.id;
        const user = await userService.findById(userId);

        if (!user) {
            return res.status(404).json({ error: 'User not found' });
        }

        res.json(user);
    } catch (error) {
        console.error('Error fetching user:', error);
        res.status(500).json({ error: 'Internal server error' });
    }
});

app.post('/api/users', async (req, res) => {
    const { name, email } = req.body;
    const user = await userService.createUser(name, email);
    res.json(user);
});

app.listen(3000, () => {
    console.log('Server running on port 3000');
});`,

    python: `# Sample Python Flask code
from flask import Flask, request, jsonify
from flask_sqlalchemy import SQLAlchemy

app = Flask(__name__)
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///users.db'
db = SQLAlchemy(app)

class User(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(80), nullable=False)
    email = db.Column(db.String(120), unique=True, nullable=False)

@app.route('/api/users/<int:user_id>', methods=['GET'])
def get_user(user_id):
    try:
        user = User.query.get(user_id)
        if not user:
            return jsonify({'error': 'User not found'}), 404

        return jsonify({
            'id': user.id,
            'name': user.name,
            'email': user.email
        })
    except Exception as e:
        return jsonify({'error': 'Internal server error'}), 500

@app.route('/api/users', methods=['POST'])
def create_user():
    data = request.get_json()
    user = User(name=data['name'], email=data['email'])
    db.session.add(user)
    db.session.commit()
    return jsonify({'id': user.id, 'name': user.name, 'email': user.email})

if __name__ == '__main__':
    app.run(debug=True)`,

    csharp: `// Sample C# .NET code
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;

[ApiController]
[Route("api/[controller]")]
public class UsersController : ControllerBase
{
    private readonly UserContext _context;

    public UsersController(UserContext context)
    {
        _context = context;
    }

    [HttpGet("{id}")]
    public async Task<ActionResult<User>> GetUser(int id)
    {
        try
        {
            var user = await _context.Users.FindAsync(id);

            if (user == null)
            {
                return NotFound();
            }

            return user;
        }
        catch (Exception ex)
        {
            return StatusCode(500, new { error = "Internal server error" });
        }
    }

    [HttpPost]
    public async Task<ActionResult<User>> CreateUser(CreateUserRequest request)
    {
        var user = new User
        {
            Name = request.Name,
            Email = request.Email
        };

        _context.Users.Add(user);
        await _context.SaveChangesAsync();

        return CreatedAtAction(nameof(GetUser), new { id = user.Id }, user);
    }
}`,

    typescript: `// Sample TypeScript/Express code
import express, { Request, Response } from 'express';
import { UserService } from './services/UserService';

const app = express();
app.use(express.json());

interface CreateUserRequest {
    name: string;
    email: string;
}

interface User {
    id: number;
    name: string;
    email: string;
}

class UserController {
    constructor(private userService: UserService) {}

    async getUser(req: Request, res: Response): Promise<void> {
        try {
            const userId = parseInt(req.params.id);
            const user: User | null = await this.userService.findById(userId);

            if (!user) {
                res.status(404).json({ error: 'User not found' });
                return;
            }

            res.json(user);
        } catch (error) {
            console.error('Error fetching user:', error);
            res.status(500).json({ error: 'Internal server error' });
        }
    }

    async createUser(req: Request<{}, User, CreateUserRequest>, res: Response): Promise<void> {
        const { name, email } = req.body;
        const user = await this.userService.createUser(name, email);
        res.json(user);
    }
}

const userController = new UserController(new UserService());

app.get('/api/users/:id', userController.getUser.bind(userController));
app.post('/api/users', userController.createUser.bind(userController));

app.listen(3000, () => {
    console.log('Server running on port 3000');
});`
};

// Initialize code editors
function initializeCodeEditors() {
    // Initialize all code editors on page load
    const editors = document.querySelectorAll('.code-editor');
    editors.forEach(editor => {
        initializeCodeEditor(editor.id);
    });
}

// Initialize a specific code editor
function initializeCodeEditor(editorId) {
    const editor = document.getElementById(editorId);
    if (!editor) return;

    // Update line numbers and character count
    updateEditorStats(editorId);

    // Add event listeners
    editor.addEventListener('input', () => updateEditorStats(editorId));
    editor.addEventListener('scroll', () => syncLineNumbers(editorId));
    editor.addEventListener('keydown', (e) => handleEditorKeydown(e, editorId));

    // Initialize line numbers
    updateLineNumbers(editorId);
}

// Update line numbers for an editor
function updateLineNumbers(editorId) {
    const editor = document.getElementById(editorId);
    const lineNumbersId = editorId.replace(/(test-sample-code|review-code-input)/, '$1').replace(/code/, 'line-numbers');
    const lineNumbers = document.getElementById(lineNumbersId);

    if (!editor || !lineNumbers) return;

    const lines = editor.value.split('\n');
    const lineNumbersText = lines.map((_, index) => index + 1).join('\n');
    lineNumbers.textContent = lineNumbersText;
}

// Update editor statistics (lines, characters)
function updateEditorStats(editorId) {
    const editor = document.getElementById(editorId);
    if (!editor) return;

    const content = editor.value;
    const lines = content.split('\n').length;
    const chars = content.length;

    // Update line numbers
    updateLineNumbers(editorId);

    // Update stats in footer
    const linesSpanId = editorId.replace(/(test-sample-code|review-code-input)/, (match) => {
        return match.includes('test') ? 'test-code-lines' : 'review-code-lines';
    });
    const charsSpanId = editorId.replace(/(test-sample-code|review-code-input)/, (match) => {
        return match.includes('test') ? 'test-code-chars' : 'review-code-chars';
    });

    const linesSpan = document.getElementById(linesSpanId);
    const charsSpan = document.getElementById(charsSpanId);

    if (linesSpan) linesSpan.textContent = `Lines: ${lines}`;
    if (charsSpan) charsSpan.textContent = `Characters: ${chars}`;
}

// Sync line numbers scroll with editor scroll
function syncLineNumbers(editorId) {
    const editor = document.getElementById(editorId);
    const lineNumbersId = editorId.replace(/(test-sample-code|review-code-input)/, (match) => {
        return match.includes('test') ? 'test-line-numbers' : 'review-line-numbers';
    });
    const lineNumbers = document.getElementById(lineNumbersId);

    if (!editor || !lineNumbers) return;

    lineNumbers.scrollTop = editor.scrollTop;
}

// Handle special keyboard shortcuts in editor
function handleEditorKeydown(event, editorId) {
    const editor = document.getElementById(editorId);
    if (!editor) return;

    // Tab key handling
    if (event.key === 'Tab') {
        event.preventDefault();
        const start = editor.selectionStart;
        const end = editor.selectionEnd;

        // Insert tab character
        editor.value = editor.value.substring(0, start) + '\t' + editor.value.substring(end);
        editor.selectionStart = editor.selectionEnd = start + 1;

        updateEditorStats(editorId);
    }

    // Ctrl+A to select all
    if (event.ctrlKey && event.key === 'a') {
        event.preventDefault();
        editor.select();
    }
}

// Format code (basic indentation)
function formatCode(editorId) {
    const editor = document.getElementById(editorId);
    if (!editor) return;

    let code = editor.value;

    // Basic formatting - fix indentation
    const lines = code.split('\n');
    let indentLevel = 0;
    const indentSize = 4;

    const formattedLines = lines.map(line => {
        const trimmedLine = line.trim();

        // Decrease indent for closing brackets
        if (trimmedLine.startsWith('}') || trimmedLine.startsWith(')')) {
            indentLevel = Math.max(0, indentLevel - 1);
        }

        const formattedLine = ' '.repeat(indentLevel * indentSize) + trimmedLine;

        // Increase indent for opening brackets
        if (trimmedLine.endsWith('{') || trimmedLine.endsWith('(')) {
            indentLevel++;
        }

        return formattedLine;
    });

    editor.value = formattedLines.join('\n');
    updateEditorStats(editorId);

    showSuccessMessage('Code formatted successfully!');
}

// Clear code editor
function clearCode(editorId) {
    const editor = document.getElementById(editorId);
    if (!editor) return;

    if (editor.value.trim() === '') {
        showInfoMessage('Editor is already empty');
        return;
    }

    editor.value = '';
    updateEditorStats(editorId);
    editor.focus();

    showSuccessMessage('Code cleared successfully!');
}

// Copy code to clipboard
function copyCode(editorId) {
    const editor = document.getElementById(editorId);
    if (!editor) return;

    if (editor.value.trim() === '') {
        showInfoMessage('No code to copy');
        return;
    }

    navigator.clipboard.writeText(editor.value).then(() => {
        showSuccessMessage('Code copied to clipboard!');
    }).catch(err => {
        console.error('Failed to copy code:', err);
        showErrorMessage('Failed to copy code to clipboard');

        // Fallback - select text
        editor.select();
        document.execCommand('copy');
        showInfoMessage('Code selected. Press Ctrl+C to copy');
    });
}

// Load sample code based on selected language
function loadSampleCode(editorId) {
    const editor = document.getElementById(editorId);
    if (!editor) return;

    // Get language from the corresponding language selector
    let languageSelectId;
    if (editorId === 'test-sample-code') {
        languageSelectId = 'test-code-language';
    } else if (editorId === 'review-code-input') {
        languageSelectId = 'review-code-language';
    }

    const languageSelect = document.getElementById(languageSelectId);
    const language = languageSelect ? languageSelect.value : 'java';

    const sampleCode = SAMPLE_CODE_TEMPLATES[language] || SAMPLE_CODE_TEMPLATES.java;

    if (editor.value.trim() !== '' && editor.value !== sampleCode) {
        if (!confirm('This will replace the current code. Continue?')) {
            return;
        }
    }

    editor.value = sampleCode;
    updateEditorStats(editorId);

    showSuccessMessage(`Sample ${language.charAt(0).toUpperCase() + language.slice(1)} code loaded!`);
}

// Show success message
function showSuccessMessage(message) {
    const successDiv = document.getElementById('success-message');
    const textSpan = successDiv?.querySelector('.success-text');

    if (successDiv && textSpan) {
        textSpan.textContent = message;
        successDiv.classList.remove('hidden');

        // Auto-hide after 3 seconds
        setTimeout(() => {
            successDiv.classList.add('hidden');
        }, 3000);
    }
}

// Show info message (reuse success styling)
function showInfoMessage(message) {
    showSuccessMessage(message);
}

// Show error message
function showErrorMessage(message) {
    const errorDiv = document.getElementById('error-message');
    const textSpan = errorDiv?.querySelector('.error-text');

    if (errorDiv && textSpan) {
        textSpan.textContent = message;
        errorDiv.classList.remove('hidden');

        // Auto-hide after 5 seconds
        setTimeout(() => {
            errorDiv.classList.add('hidden');
        }, 5000);
    }
}

// Initialize when DOM is loaded
document.addEventListener('DOMContentLoaded', initializeCodeEditors);

// Export functions for global use
window.formatCode = formatCode;
window.clearCode = clearCode;
window.copyCode = copyCode;
window.loadSampleCode = loadSampleCode;
---------------------------------------------------------------
code-review-submission.js

/**
 * Code Review Submission Management
 * Handles code submission with file upload and validation
 */

class CodeReviewSubmissionManager {
    constructor() {
        this.projects = [];
        this.maxFileSize = 5 * 1024 * 1024; // 5MB
        this.initialized = false;
    }

    init() {
        if (this.initialized) {
            console.log('CodeReviewSubmissionManager: Already initialized, skipping...');
            return;
        }

        console.log('CodeReviewSubmissionManager: Initializing...');
        this.setupEventListeners();
        this.loadProjects();
        this.initialized = true;
    }

    setupEventListeners() {
        const form = document.getElementById('code-review-form');
        if (form) {
            form.addEventListener('submit', (e) => this.handleSubmit(e));
        }

        const codeTextarea = document.getElementById('review-code-content');
        if (codeTextarea) {
            codeTextarea.addEventListener('input', () => this.updateCodeStats());
        }

        const fileUpload = document.getElementById('code-file-upload');
        if (fileUpload) {
            fileUpload.addEventListener('change', (e) => this.handleFileUpload(e));
        }
    }

    async loadProjects() {
        try {
            console.log('CodeReviewSubmissionManager: loadProjects() called');

            if (window.projectsManager && window.projectsManager.projects) {
                console.log('CodeReviewSubmissionManager: Using projects from projectsManager:', window.projectsManager.projects);
                this.projects = window.projectsManager.projects.filter(p => p.active);
            } else {
                console.log('CodeReviewSubmissionManager: Loading projects via API...');
                const response = await projectApi.getAll();
                console.log('CodeReviewSubmissionManager: API response:', response);
                this.projects = (response || []).filter(p => p.active);
            }

            console.log('CodeReviewSubmissionManager: Filtered active projects:', this.projects);
            this.populateProjectSelector();
        } catch (error) {
            console.warn('Failed to load projects:', error);
        }
    }

    populateProjectSelector() {
        console.log('CodeReviewSubmissionManager: populateProjectSelector() called');
        const selector = document.getElementById('review-project');
        console.log('CodeReviewSubmissionManager: Selector element:', selector);

        if (selector) {
            selector.innerHTML = '<option value="">Select a project</option>';

            console.log('CodeReviewSubmissionManager: Adding projects to selector:', this.projects.length);
            this.projects.forEach(project => {
                const option = document.createElement('option');
                option.value = project.id;
                // For now, just display project name since team info is not available
                // due to @JsonBackReference annotation in the backend
                option.textContent = project.name;
                selector.appendChild(option);
                console.log(`CodeReviewSubmissionManager: Added project: ${project.name} (ID: ${project.id})`);
            });

            console.log(`CodeReviewSubmissionManager: Selector now has ${selector.options.length} options`);
        } else {
            console.warn('CodeReviewSubmissionManager: #review-project selector not found in DOM');
        }
    }

    updateCodeStats() {
        const textarea = document.getElementById('review-code-content');
        const linesCount = document.getElementById('code-lines-count');
        const charsCount = document.getElementById('code-chars-count');

        if (textarea && linesCount && charsCount) {
            const content = textarea.value;
            const lines = content.split('\n').length;
            const chars = content.length;

            linesCount.textContent = `${lines} lines`;
            charsCount.textContent = `${chars} characters`;
        }
    }

    async handleFileUpload(event) {
        const file = event.target.files[0];
        if (!file) return;

        if (file.size > this.maxFileSize) {
            showError('File size must be less than 5MB');
            event.target.value = '';
            return;
        }

        try {
            const content = await this.readFileContent(file);
            const textarea = document.getElementById('review-code-content');
            if (textarea) {
                textarea.value = content;
                this.updateCodeStats();
            }

            // Try to detect language from file extension
            const language = this.detectLanguageFromFilename(file.name);
            if (language) {
                const languageSelect = document.getElementById('review-language');
                if (languageSelect) {
                    languageSelect.value = language;
                }
            }

            // Set file path if empty
            const filePathInput = document.getElementById('review-file-path');
            if (filePathInput && !filePathInput.value) {
                filePathInput.value = file.name;
            }

            showSuccess(`File "${file.name}" loaded successfully`);

        } catch (error) {
            showError('Failed to read file content');
            console.error('File upload error:', error);
        }
    }

    readFileContent(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = (e) => resolve(e.target.result);
            reader.onerror = (e) => reject(e);
            reader.readAsText(file);
        });
    }

    detectLanguageFromFilename(filename) {
        const extension = filename.split('.').pop()?.toLowerCase();

        const languageMap = {
            'js': 'javascript',
            'jsx': 'javascript',
            'ts': 'typescript',
            'tsx': 'typescript',
            'py': 'python',
            'java': 'java',
            'cs': 'csharp',
            'cpp': 'cpp',
            'c': 'cpp',
            'go': 'go',
            'rb': 'ruby',
            'php': 'php'
        };

        return languageMap[extension] || '';
    }

    async handleSubmit(event) {
        event.preventDefault();

        const submissionData = {
            projectId: parseInt(document.getElementById('review-project').value),
            submitterName: document.getElementById('review-submitter-name').value,
            submitterEmail: document.getElementById('review-submitter-email').value,
            filePath: document.getElementById('review-file-path').value,
            commitHash: document.getElementById('review-commit-hash').value,
            programmingLanguage: document.getElementById('review-language').value,
            priority: document.getElementById('review-priority').value,
            codeContent: document.getElementById('review-code-content').value
        };

        // Validation
        if (!this.validateSubmission(submissionData)) {
            return;
        }

        try {
            console.log('CodeReviewSubmissionManager: Submitting code review...', submissionData);
            showLoading();

            const response = await submissionApi.create(submissionData);
            console.log('CodeReviewSubmissionManager: Submission successful', response);

            showSuccess('Code review submitted successfully! Review ID: ' + (response?.reviewId || 'N/A'));

            // Reset form
            this.resetForm();

            // Switch to reviews tab to show the submission
            setTimeout(() => {
                switchTab('reviews');
            }, 2000);

        } catch (error) {
            console.error('CodeReviewSubmissionManager: Submission failed:', error);
            let errorMessage = 'Failed to submit code review. Please try again.';

            // Try to get more specific error message
            if (error.message) {
                errorMessage = `Submission failed: ${error.message}`;
            }

            showError(errorMessage);
        } finally {
            hideLoading();
        }
    }

    validateSubmission(data) {
        if (!data.projectId) {
            showError('Please select a project');
            return false;
        }

        if (!data.submitterEmail || !this.isValidEmail(data.submitterEmail)) {
            showError('Please enter a valid email address');
            return false;
        }

        if (!data.commitHash || data.commitHash.trim().length < 6) {
            showError('Please enter a valid commit hash (at least 6 characters)');
            return false;
        }

        if (!data.codeContent || data.codeContent.trim().length < 10) {
            showError('Please enter the code content (at least 10 characters)');
            return false;
        }

        return true;
    }

    isValidEmail(email) {
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        return emailRegex.test(email);
    }

    resetForm() {
        const form = document.getElementById('code-review-form');
        if (form) {
            form.reset();
            document.getElementById('review-priority').value = 'MEDIUM';
            this.updateCodeStats();
        }
    }

    loadSampleCode() {
        const sampleCode = `public class UserService {

    private final UserRepository userRepository;
    private final EmailService emailService;

    public UserService(UserRepository userRepository, EmailService emailService) {
        this.userRepository = userRepository;
        this.emailService = emailService;
    }

    public User createUser(CreateUserRequest request) {
        // Validate input
        if (request.getEmail() == null || request.getEmail().isEmpty()) {
            throw new IllegalArgumentException("Email is required");
        }

        // Check if user already exists
        if (userRepository.findByEmail(request.getEmail()).isPresent()) {
            throw new UserAlreadyExistsException("User with email already exists");
        }

        // Create new user
        User user = new User();
        user.setEmail(request.getEmail());
        user.setName(request.getName());
        user.setCreatedDate(LocalDateTime.now());

        User savedUser = userRepository.save(user);

        // Send welcome email
        emailService.sendWelcomeEmail(savedUser.getEmail());

        return savedUser;
    }
}`;

        const textarea = document.getElementById('review-code-content');
        if (textarea) {
            textarea.value = sampleCode;
            this.updateCodeStats();
        }

        // Set some sample values
        document.getElementById('review-file-path').value = 'src/main/java/com/example/UserService.java';
        document.getElementById('review-language').value = 'java';
        document.getElementById('review-commit-hash').value = 'a1b2c3d4e5f6789';

        showSuccess('Sample code loaded');
    }

    formatCodeContent() {
        const textarea = document.getElementById('review-code-content');
        if (textarea && textarea.value) {
            // Simple formatting - normalize line endings and trim
            const formatted = textarea.value
                .replace(/\r\n/g, '\n')
                .replace(/\t/g, '    ')
                .split('\n')
                .map(line => line.trimEnd())
                .join('\n')
                .trim();

            textarea.value = formatted;
            this.updateCodeStats();
            showSuccess('Code formatted');
        }
    }

    clearCodeContent() {
        const textarea = document.getElementById('review-code-content');
        if (textarea) {
            textarea.value = '';
            this.updateCodeStats();
        }
    }

    previewSubmission() {
        const data = {
            project: document.getElementById('review-project').selectedOptions[0]?.textContent || 'Not selected',
            submitterName: document.getElementById('review-submitter-name').value || 'Not provided',
            submitterEmail: document.getElementById('review-submitter-email').value,
            filePath: document.getElementById('review-file-path').value || 'Not provided',
            commitHash: document.getElementById('review-commit-hash').value,
            language: document.getElementById('review-language').value || 'Auto-detect',
            priority: document.getElementById('review-priority').value,
            codeLines: document.getElementById('review-code-content').value.split('\n').length,
            codeChars: document.getElementById('review-code-content').value.length
        };

        const previewHtml = `
            <div class="review-preview">
                <h3>üìã Submission Preview</h3>
                <div class="preview-section">
                    <strong>Project:</strong> ${data.project}<br>
                    <strong>Submitter:</strong> ${data.submitterName} (${data.submitterEmail})<br>
                    <strong>File:</strong> ${data.filePath}<br>
                    <strong>Commit:</strong> ${data.commitHash}<br>
                    <strong>Language:</strong> ${data.language}<br>
                    <strong>Priority:</strong> ${data.priority}<br>
                    <strong>Code:</strong> ${data.codeLines} lines, ${data.codeChars} characters
                </div>
            </div>
        `;

        // Show in a temporary modal or alert
        showInfo(previewHtml, 'Submission Preview');
    }
}

window.codeReviewSubmissionManager = new CodeReviewSubmissionManager();

// Global functions
window.formatCodeContent = function() {
    window.codeReviewSubmissionManager.formatCodeContent();
};

window.clearCodeContent = function() {
    window.codeReviewSubmissionManager.clearCodeContent();
};

window.loadSampleCode = function() {
    window.codeReviewSubmissionManager.loadSampleCode();
};

window.handleFileUpload = function(event) {
    window.codeReviewSubmissionManager.handleFileUpload(event);
};

window.updateCodeStats = function() {
    window.codeReviewSubmissionManager.updateCodeStats();
};

window.resetCodeReviewForm = function() {
    window.codeReviewSubmissionManager.resetForm();
};

window.previewSubmission = function() {
    window.codeReviewSubmissionManager.previewSubmission();
};

// Debug function to manually load projects
window.debugLoadProjects = function() {
    console.log('Manual debug: Loading projects...');
    if (window.codeReviewSubmissionManager) {
        window.codeReviewSubmissionManager.loadProjects();
    } else {
        console.error('Code Review submission manager not available');
    }
};

// Debug function to check manager state
window.debugCheckManager = function() {
    console.log('Code Review Manager State:');
    console.log('- Manager exists:', !!window.codeReviewSubmissionManager);
    console.log('- Initialized:', window.codeReviewSubmissionManager?.initialized);
    console.log('- Projects count:', window.codeReviewSubmissionManager?.projects?.length || 0);
    console.log('- Projects:', window.codeReviewSubmissionManager?.projects);

    const selector = document.getElementById('review-project');
    console.log('- Selector exists:', !!selector);
    console.log('- Selector options count:', selector?.options?.length || 0);
};

// Debug function to test submission API
window.debugTestSubmission = async function() {
    const testData = {
        projectId: 6,
        submitterName: 'Debug User',
        submitterEmail: 'debug@test.com',
        filePath: 'src/test/DebugTest.java',
        commitHash: 'debug123456',
        programmingLanguage: 'java',
        priority: 'MEDIUM',
        codeContent: 'public class DebugTest { public void test() { System.out.println("Debug test"); } }'
    };

    try {
        console.log('Testing submission API with data:', testData);
        const response = await submissionApi.create(testData);
        console.log('‚úÖ Debug submission successful:', response);
        alert('Debug submission successful! Check console for details.');
    } catch (error) {
        console.error('‚ùå Debug submission failed:', error);
        alert(`Debug submission failed: ${error.message}`);
    }
};

document.addEventListener('DOMContentLoaded', () => {
    if (document.getElementById('code-review-tab')) {
        console.log('DOM loaded - initializing Code Review manager');
        window.codeReviewSubmissionManager.init();
    }
});

// Also initialize when the window loads (backup)
window.addEventListener('load', () => {
    if (document.getElementById('code-review-tab') && !window.codeReviewSubmissionManager.initialized) {
        console.log('Window loaded - backup initialization of Code Review manager');
        window.codeReviewSubmissionManager.init();
    }
});

// Periodic check to ensure projects are loaded when Code Review tab is active
setInterval(() => {
    const codeReviewTab = document.getElementById('code-review-tab');
    const isTabActive = codeReviewTab && codeReviewTab.classList.contains('active');

    if (isTabActive && window.codeReviewSubmissionManager) {
        const selector = document.getElementById('review-project');
        const hasProjects = window.codeReviewSubmissionManager.projects && window.codeReviewSubmissionManager.projects.length > 0;
        const selectorEmpty = selector && selector.options.length <= 1;

        // If tab is active, manager exists, we have projects but selector is empty, repopulate
        if (hasProjects && selectorEmpty) {
            console.log('Periodic check: Repopulating empty project selector');
            window.codeReviewSubmissionManager.populateProjectSelector();
        }
        // If tab is active, manager exists, but no projects loaded, try to load them
        else if (!hasProjects && window.codeReviewSubmissionManager.initialized) {
            console.log('Periodic check: Loading missing projects');
            window.codeReviewSubmissionManager.loadProjects();
        }
        // If tab is active but manager not initialized, initialize it
        else if (!window.codeReviewSubmissionManager.initialized) {
            console.log('Periodic check: Initializing Code Review manager');
            window.codeReviewSubmissionManager.init();
        }
    }
}, 2000); // Check every 2 seconds



-------------------------------------
config.js
/**
 * Configuration file for the Code Review Manager
 * Contains API endpoints and other configuration settings
 */

// API Configuration
const API_CONFIG = {
    BASE_URL: 'http://localhost:8081/api',
    ENDPOINTS: {
        // Category endpoints
        CATEGORIES: '/categories',
        CATEGORIES_SEARCH: '/categories/search',

        // Prompt endpoints
        PROMPTS: '/prompts',
        PROMPTS_ALL: '/prompts/all',
        PROMPTS_SEARCH: '/prompts/search',
        PROMPTS_BY_CATEGORY: '/prompts/category',
        PROMPTS_STATS: '/prompts/stats',

        // Team endpoints
        TEAMS: '/teams',
        TEAMS_SEARCH: '/teams/search',
        TEAMS_STATS: '/teams/stats',

        // Project endpoints
        PROJECTS: '/projects',
        PROJECTS_SEARCH: '/projects/search',
        PROJECTS_STATS: '/projects/stats',
        PROJECTS_BY_TEAM: '/projects/team',

        // Code Review Submission endpoints
        SUBMISSIONS: '/submissions',
        SUBMISSIONS_SEARCH: '/submissions/search',
        SUBMISSIONS_STATS: '/submissions/stats',
        SUBMISSIONS_BY_PROJECT: '/submissions/project',
        SUBMISSIONS_BY_TEAM: '/submissions/team',

        // AI Review endpoints
        AI_REVIEW_EXECUTE: '/ai-review/execute',
        AI_REVIEW_TEST: '/ai-review/test-prompt',
        AI_REVIEW_STATUS: '/ai-review/status',

        // Project Analysis endpoints
        PROJECT_ANALYZE: '/project-analysis/analyze',
        PROJECT_README: '/project-analysis/generate-readme',
        PROJECT_REVIEW: '/project-analysis/review-project'
    }
};

// UI Configuration
const UI_CONFIG = {
    DEBOUNCE_DELAY: 300, // milliseconds
    ANIMATION_DURATION: 200, // milliseconds
    MAX_ITEMS_PER_PAGE: 50
};

// Message Configuration
const MESSAGES = {
    LOADING: 'Loading...',
    NO_DATA: 'No data available',
    NO_PROMPTS: 'No prompts found',
    NO_CATEGORIES: 'No categories found',
    DELETE_CONFIRM: 'Are you sure you want to delete this item?',
    DELETE_SUCCESS: 'Item deleted successfully',
    SAVE_SUCCESS: 'Item saved successfully',
    ERROR_GENERIC: 'An error occurred. Please try again.',
    ERROR_NETWORK: 'Network error. Please check your connection.',
    ERROR_SERVER: 'Server error. Please try again later.'
};

// Export configuration objects to global scope
window.API_CONFIG = API_CONFIG;
window.UI_CONFIG = UI_CONFIG;
window.MESSAGES = MESSAGES;

--------------------------------------

dashboard.js


/**
 * Dashboard Management
 * Handles dashboard statistics, activity feed, and quick actions
 */

class DashboardManager {
    constructor() {
        this.refreshInterval = 30000; // 30 seconds
        this.intervalId = null;
    }

    /**
     * Initialize dashboard
     */
    init() {
        this.setupEventListeners();
        this.loadDashboardData();
        this.checkSystemStatus();
        this.startAutoRefresh();
    }

    /**
     * Set up event listeners
     */
    setupEventListeners() {
        // Quick action buttons
        document.querySelectorAll('[data-action]').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const action = e.currentTarget.getAttribute('data-action');
                this.handleQuickAction(action);
            });
        });
    }

    /**
     * Load dashboard data
     */
    async loadDashboardData() {
        try {
            showLoading();

            // Load all statistics in parallel
        // Fetch data with fallbacks for unavailable endpoints
        const teamsData = await this.fetchTeamsStats().catch(() => ({ count: 0 }));
        const projectsData = await this.fetchProjectsStats().catch(() => ({ count: 0 }));
        const reviewsData = await this.fetchReviewsStats().catch(() => ({ count: 0 }));
        const promptsData = await this.fetchPromptsStats().catch(() => ({ count: 0 }));

        // Update stats cards
        this.updateStatsCards({
            teams: teamsData.count || teamsData.activePromptCount || 0,
            projects: projectsData.count || projectsData.activePromptCount || 0,
            reviews: reviewsData.count || reviewsData.activePromptCount || 0,
            prompts: promptsData.count || promptsData.activePromptCount || 0
        });

            // Load recent activity
            await this.loadRecentActivity();

        } catch (error) {
            console.error('Failed to load dashboard data:', error);
            showError('Failed to load dashboard data');
        } finally {
            hideLoading();
        }
    }

    /**
     * Fetch teams statistics
     */
    async fetchTeamsStats() {
        try {
            const teams = await teamApi.getAll();
            return { count: teams.length || 0 };
        } catch (error) {
            console.warn('Teams stats not available:', error);
            return { count: 0 };
        }
    }

    /**
     * Fetch projects statistics
     */
    async fetchProjectsStats() {
        try {
            const projects = await projectApi.getAll();
            return { count: projects.length || 0 };
        } catch (error) {
            console.warn('Projects stats not available:', error);
            return { count: 0 };
        }
    }

    /**
     * Fetch reviews statistics
     */
    async fetchReviewsStats() {
        try {
            const submissions = await submissionApi.getAll();
            return { count: submissions.length || 0 };
        } catch (error) {
            console.warn('Reviews stats not available:', error);
            return { count: 0 };
        }
    }

    /**
     * Fetch prompts statistics
     */
    async fetchPromptsStats() {
        try {
            // For now, return 0 since prompts API is not implemented
            // TODO: Implement prompts API
            return { count: 0 };
        } catch (error) {
            console.warn('Prompts stats not available:', error);
            return { count: 0 };
        }
    }

    /**
     * Update statistics cards
     */
    updateStatsCards(stats) {
        const elements = {
            teams: document.getElementById('teams-count'),
            projects: document.getElementById('projects-count'),
            reviews: document.getElementById('reviews-count'),
            prompts: document.getElementById('prompts-count')
        };

        Object.keys(stats).forEach(key => {
            if (elements[key]) {
                this.animateNumber(elements[key], parseInt(elements[key].textContent) || 0, stats[key]);
            }
        });
    }

    /**
     * Animate number change
     */
    animateNumber(element, from, to) {
        const duration = 1000;
        const startTime = Date.now();

        const animate = () => {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(elapsed / duration, 1);

            // Use easing function for smooth animation
            const eased = 1 - Math.pow(1 - progress, 3);
            const current = Math.round(from + (to - from) * eased);

            element.textContent = current;

            if (progress < 1) {
                requestAnimationFrame(animate);
            }
        };

        animate();
    }

    /**
     * Load recent activity
     */
    async loadRecentActivity() {
        try {
            const activities = await this.fetchRecentActivities();
            this.updateActivityFeed(activities);
        } catch (error) {
            console.error('Failed to load recent activity:', error);
        }
    }

    /**
     * Fetch recent activities
     */
    async fetchRecentActivities() {
        try {
            console.log('DashboardManager: Fetching recent activities...');
            const activities = [];

            // Fetch recent submissions (code reviews)
            try {
                const submissions = await submissionApi.getAll();
                console.log('DashboardManager: Found', submissions.length, 'submissions');

                // Get the 3 most recent submissions
                const recentSubmissions = submissions
                    .sort((a, b) => new Date(b.submittedDate || b.createdDate) - new Date(a.submittedDate || a.createdDate))
                    .slice(0, 3);

                recentSubmissions.forEach(submission => {
                    const statusIcons = {
                        'PENDING': '‚è≥',
                        'IN_PROGRESS': 'üîÑ',
                        'COMPLETED': '‚úÖ',
                        'FAILED': '‚ùå',
                        'CANCELLED': '‚ö™'
                    };

                    activities.push({
                        icon: statusIcons[submission.reviewStatus] || 'üîç',
                        title: 'Code Review',
                        description: `${submission.submitterName || 'User'} submitted ${submission.filePath || 'code'} for review`,
                        timestamp: new Date(submission.submittedDate || submission.createdDate),
                        type: 'submission',
                        status: submission.reviewStatus
                    });
                });
            } catch (error) {
                console.warn('Could not fetch recent submissions:', error);
            }

            // Fetch recent projects
            try {
                const projects = await projectApi.getAll();
                console.log('DashboardManager: Found', projects.length, 'projects');

                // Get the 2 most recent projects
                const recentProjects = projects
                    .sort((a, b) => new Date(b.createdDate) - new Date(a.createdDate))
                    .slice(0, 2);

                recentProjects.forEach(project => {
                    activities.push({
                        icon: 'üìÇ',
                        title: 'Project Created',
                        description: `${project.name} was added to the system`,
                        timestamp: new Date(project.createdDate),
                        type: 'project'
                    });
                });
            } catch (error) {
                console.warn('Could not fetch recent projects:', error);
            }

            // Fetch recent teams
            try {
                const teams = await teamApi.getAll();
                console.log('DashboardManager: Found', teams.length, 'teams');

                // Get the most recent team
                const recentTeam = teams
                    .sort((a, b) => new Date(b.createdDate) - new Date(a.createdDate))
                    .slice(0, 1);

                recentTeam.forEach(team => {
                    activities.push({
                        icon: 'üë•',
                        title: 'Team Created',
                        description: `${team.name} team was established`,
                        timestamp: new Date(team.createdDate),
                        type: 'team'
                    });
                });
            } catch (error) {
                console.warn('Could not fetch recent teams:', error);
            }

            // Sort all activities by timestamp (most recent first)
            const sortedActivities = activities
                .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp))
                .slice(0, 5); // Show only top 5 activities

            console.log('DashboardManager: Returning', sortedActivities.length, 'recent activities');
            return sortedActivities;

        } catch (error) {
            console.warn('Activity feed not available:', error);
            return [];
        }
    }

    /**
     * Update activity feed
     */
    updateActivityFeed(activities) {
        const activityList = document.getElementById('recent-activity');
        if (!activityList) return;

        if (!activities || activities.length === 0) {
            activityList.innerHTML = `
                <div class="empty-activity-state">
                    <div class="empty-icon">üìã</div>
                    <p>No recent activity</p>
                    <small>Activity will appear here as you use the system</small>
                </div>
            `;
            return;
        }

        activityList.innerHTML = activities.map(activity => `
            <div class="activity-item" style="animation: slideIn 0.5s ease-out;">
                <div class="activity-icon">${activity.icon}</div>
                <div class="activity-content">
                    <span class="activity-title">${activity.title}</span>
                    <span class="activity-time">${this.formatTimeAgo(activity.timestamp)} - ${activity.description}</span>
                </div>
            </div>
        `).join('');
    }

    /**
     * Format time ago
     */
    formatTimeAgo(timestamp) {
        const now = new Date();
        const time = new Date(timestamp);
        const diff = now - time;

        const minutes = Math.floor(diff / 60000);
        const hours = Math.floor(minutes / 60);
        const days = Math.floor(hours / 24);

        if (days > 0) return `${days} day${days > 1 ? 's' : ''} ago`;
        if (hours > 0) return `${hours} hour${hours > 1 ? 's' : ''} ago`;
        if (minutes > 0) return `${minutes} minute${minutes > 1 ? 's' : ''} ago`;
        return 'Just now';
    }

    /**
     * Check system status
     */
    async checkSystemStatus() {
        // Check API status by testing a known endpoint
        try {
            await teamApi.getAll();
            this.updateStatus('api-status', 'Connected', 'online');
        } catch (error) {
            this.updateStatus('api-status', 'Disconnected', 'offline');
        }

        // For now, mark AI as unavailable since it's not implemented
        // TODO: Implement AI service status check
        const aiStatusElement = document.getElementById('ai-status-text');
        const aiStatusDot = document.getElementById('ai-status-dot');
        if (aiStatusElement) {
            this.updateStatus('ai-status-text', 'Not configured', 'offline');
        }
        if (aiStatusDot) {
            aiStatusDot.className = 'status-dot offline';
        }
    }

    /**
     * Update status indicator
     */
    updateStatus(elementId, text, status) {
        const element = document.getElementById(elementId);
        if (element) {
            element.textContent = text;
            element.className = `status-value ${status}`;
        }
    }

    /**
     * Handle quick actions
     */
    handleQuickAction(action) {
        console.log(`DashboardManager: Handling quick action: ${action}`);

        switch (action) {
            case 'new-team':
                console.log('Quick Action: Creating new team');
                if (typeof showTeamForm === 'function') {
                    showTeamForm();
                } else {
                    switchTab('teams');
                    // Try to trigger the team form after switching
                    setTimeout(() => {
                        const addTeamBtn = document.querySelector('[onclick*="showTeamForm"]');
                        if (addTeamBtn) addTeamBtn.click();
                    }, 300);
                }
                break;

            case 'new-project':
                console.log('Quick Action: Creating new project');
                if (typeof showProjectForm === 'function') {
                    showProjectForm();
                } else {
                    switchTab('projects');
                    // Try to trigger the project form after switching
                    setTimeout(() => {
                        const addProjectBtn = document.querySelector('[onclick*="showProjectForm"]');
                        if (addProjectBtn) addProjectBtn.click();
                    }, 300);
                }
                break;

            case 'submit-review':
                console.log('Quick Action: Submitting code review');
                switchTab('code-review');
                // Show success message to confirm the action worked
                setTimeout(() => {
                    showSuccess('Switched to Code Review tab - Submit your code for review!');
                }, 300);
                break;

            case 'add-prompt':
                console.log('Quick Action: Adding new prompt');
                if (typeof showPromptForm === 'function') {
                    showPromptForm();
                } else {
                    switchTab('prompts');
                    // Try to trigger the prompt form after switching
                    setTimeout(() => {
                        const addPromptBtn = document.querySelector('[onclick*="showPromptForm"]');
                        if (addPromptBtn) {
                            addPromptBtn.click();
                        } else {
                            showSuccess('Switched to Prompts tab - Click "Add New Prompt" to create a prompt!');
                        }
                    }, 300);
                }
                break;

            default:
                console.warn(`Unknown quick action: ${action}`);
                showError(`Unknown action: ${action}`);
        }
    }

    /**
     * Start auto-refresh
     */
    startAutoRefresh() {
        this.intervalId = setInterval(() => {
            this.loadDashboardData();
            this.checkSystemStatus();
        }, this.refreshInterval);
    }

    /**
     * Stop auto-refresh
     */
    stopAutoRefresh() {
        if (this.intervalId) {
            clearInterval(this.intervalId);
            this.intervalId = null;
        }
    }

    /**
     * Refresh dashboard manually
     */
    async refresh() {
        await this.loadDashboardData();
        await this.checkSystemStatus();
        showSuccess('Dashboard refreshed');
    }

    /**
     * Cleanup
     */
    cleanup() {
        this.stopAutoRefresh();
    }
}

// Global dashboard manager instance
window.dashboardManager = new DashboardManager();

/**
 * Initialize dashboard manually (for debugging)
 */
function initializeDashboard() {
    console.log('Dashboard: Manual initialization triggered');
    if (window.dashboardManager && document.getElementById('dashboard-tab')) {
        window.dashboardManager.init();
        console.log('Dashboard: Initialized successfully');
    } else {
        console.error('Dashboard: Cannot initialize - missing manager or DOM element');
    }
}

/**
 * Test quick actions (for debugging)
 */
function testQuickActions() {
    console.log('Testing quick actions...');
    const actions = ['new-team', 'new-project', 'submit-review', 'add-prompt'];

    actions.forEach(action => {
        console.log(`Testing action: ${action}`);
        if (window.dashboardManager) {
            window.dashboardManager.handleQuickAction(action);
        }
    });
}

// Initialize when DOM is ready
document.addEventListener('DOMContentLoaded', () => {
    console.log('Dashboard: DOM loaded, checking for dashboard tab');

    if (document.getElementById('dashboard-tab')) {
        console.log('Dashboard: Tab found, initializing manager');
        window.dashboardManager.init();

        // Add click event listeners to action buttons for debugging
        const actionButtons = document.querySelectorAll('[data-action]');
        console.log(`Dashboard: Found ${actionButtons.length} action buttons`);

        actionButtons.forEach((btn, index) => {
            const action = btn.getAttribute('data-action');
            console.log(`Dashboard: Button ${index + 1}: ${action}`);

            // Add additional click handler for debugging
            btn.addEventListener('click', (e) => {
                console.log('Dashboard: Direct click handler triggered for:', action);
                e.preventDefault();
                e.stopPropagation();

                if (window.dashboardManager) {
                    window.dashboardManager.handleQuickAction(action);
                } else {
                    console.error('Dashboard: Manager not available');
                }
            });
        });
    } else {
        console.log('Dashboard: Tab not found, skipping initialization');
    }
});

// Export debug functions
window.initializeDashboard = initializeDashboard;
window.testQuickActions = testQuickActions;

// Cleanup on page unload
window.addEventListener('beforeunload', () => {
    if (window.dashboardManager) {
        window.dashboardManager.cleanup();
    }
});
------------------------------------------------------------------------

enhanced-prompts.js

/**
 * Enhanced Prompts Functionality
 * Professional prompts management with advanced features
 */

// Global variables for prompts management
let currentView = 'grid';
let selectedPrompts = new Set();
let filteredPrompts = [];
let allPrompts = [];

// Initialize enhanced prompts functionality
function initializeEnhancedPrompts() {
    loadPromptsStats();
    loadEnhancedPrompts();
    setupPromptEventListeners();
}

// Setup event listeners for enhanced features
function setupPromptEventListeners() {
    // Search functionality with debouncing
    const searchInput = document.getElementById('prompt-search');
    if (searchInput) {
        let searchTimeout;
        searchInput.addEventListener('input', (e) => {
            clearTimeout(searchTimeout);
            searchTimeout = setTimeout(() => {
                filterPrompts();
            }, 300);
        });
    }

    // Filter functionality
    const categoryFilter = document.getElementById('category-filter');
    const statusFilter = document.getElementById('status-filter');

    if (categoryFilter) {
        categoryFilter.addEventListener('change', filterPrompts);
    }
    if (statusFilter) {
        statusFilter.addEventListener('change', filterPrompts);
    }
}

// Load prompts statistics
function loadPromptsStats() {
    // This would typically call your existing API
    // For now, we'll simulate the data
    setTimeout(() => {
        updatePromptsStats({
            total: 12,
            active: 8,
            categories: 4
        });
    }, 500);
}

// Update prompts statistics display
function updatePromptsStats(stats) {
    const totalElement = document.getElementById('total-prompts');
    const activeElement = document.getElementById('active-prompts');
    const categoriesElement = document.getElementById('total-categories');

    if (totalElement) totalElement.textContent = stats.total;
    if (activeElement) activeElement.textContent = stats.active;
    if (categoriesElement) categoriesElement.textContent = stats.categories;

    // Animate the numbers
    animateStatNumbers();
}

// Animate statistics numbers
function animateStatNumbers() {
    const statNumbers = document.querySelectorAll('.stat-number');
    statNumbers.forEach(statNumber => {
        const finalNumber = parseInt(statNumber.textContent);
        const duration = 1000;
        const steps = 20;
        const increment = finalNumber / steps;
        let current = 0;
        let step = 0;

        const timer = setInterval(() => {
            current += increment;
            statNumber.textContent = Math.round(current);
            step++;

            if (step >= steps) {
                clearInterval(timer);
                statNumber.textContent = finalNumber;
            }
        }, duration / steps);
    });
}

// Load enhanced prompts with sample data
function loadEnhancedPrompts() {
    // Sample prompts data - this would come from your API
    const samplePrompts = [
        {
            id: 1,
            title: "Code Quality Review",
            description: "Comprehensive code quality assessment focusing on maintainability and best practices",
            category: "Quality Assurance",
            content: `Review this code for:
- Code clarity and readability
- Performance optimizations
- Security vulnerabilities
- Best practice adherence
- Potential bugs or edge cases`,
            isActive: true,
            createdDate: "2024-01-15",
            lastModified: "2024-01-20"
        },
        {
            id: 2,
            title: "Security Vulnerability Check",
            description: "Security-focused review to identify potential vulnerabilities and threats",
            category: "Security",
            content: `Analyze for security issues:
- SQL injection vulnerabilities
- XSS attack vectors
- Authentication bypasses
- Data validation issues
- Encryption concerns`,
            isActive: true,
            createdDate: "2024-01-10",
            lastModified: "2024-01-18"
        },
        {
            id: 3,
            title: "Performance Optimization",
            description: "Performance-focused review to identify bottlenecks and optimization opportunities",
            category: "Performance",
            content: `Evaluate performance aspects:
- Database query efficiency
- Memory usage patterns
- Algorithmic complexity
- Caching opportunities
- Resource utilization`,
            isActive: false,
            createdDate: "2024-01-05",
            lastModified: "2024-01-12"
        },
        {
            id: 4,
            title: "API Design Review",
            description: "RESTful API design and implementation review",
            category: "Architecture",
            content: `Review API design for:
- RESTful principles adherence
- HTTP status code usage
- Request/response structure
- Error handling patterns
- Documentation quality`,
            isActive: true,
            createdDate: "2024-01-08",
            lastModified: "2024-01-16"
        }
    ];

    allPrompts = samplePrompts;
    filteredPrompts = [...allPrompts];
    displayPrompts(filteredPrompts);
    updatePromptsStats({
        total: allPrompts.length,
        active: allPrompts.filter(p => p.isActive).length,
        categories: [...new Set(allPrompts.map(p => p.category))].length
    });
}

// Display prompts in the current view
function displayPrompts(prompts) {
    const promptsList = document.getElementById('prompts-list');
    const noPromptsState = document.getElementById('no-prompts-state');

    if (!promptsList) return;

    if (prompts.length === 0) {
        promptsList.style.display = 'none';
        if (noPromptsState) noPromptsState.style.display = 'block';
        return;
    }

    if (noPromptsState) noPromptsState.style.display = 'none';
    promptsList.style.display = currentView === 'grid' ? 'grid' : 'flex';

    promptsList.innerHTML = prompts.map(prompt => createPromptCard(prompt)).join('');
    updateSelectedCount();
}

// Create a prompt card HTML
function createPromptCard(prompt) {
    const isSelected = selectedPrompts.has(prompt.id);
    const statusClass = prompt.isActive ? 'active' : 'inactive';
    const statusIcon = prompt.isActive ? '‚úÖ' : '‚ùå';
    const statusText = prompt.isActive ? 'Active' : 'Inactive';

    return `
        <div class="prompt-card ${isSelected ? 'selected' : ''}" data-prompt-id="${prompt.id}">
            <div class="prompt-card-header">
                <div class="checkbox-container">
                    <input type="checkbox"
                           ${isSelected ? 'checked' : ''}
                           onchange="togglePromptSelection(${prompt.id})"
                           class="prompt-checkbox">
                </div>
                <h3 class="prompt-title">
                    üìù ${prompt.title}
                </h3>
                <span class="prompt-category">${prompt.category}</span>
                <p class="prompt-description">${prompt.description}</p>
                <div class="prompt-meta">
                    <span class="prompt-date">Modified: ${formatDate(prompt.lastModified)}</span>
                    <span class="prompt-status ${statusClass}">
                        ${statusIcon} ${statusText}
                    </span>
                </div>
            </div>

            ${currentView === 'grid' ? `
            <div class="prompt-card-content">
                <div class="prompt-content-preview">${truncateContent(prompt.content, 200)}</div>
            </div>
            ` : ''}

            <div class="prompt-card-actions">
                <div class="prompt-actions-left">
                    <button class="prompt-action-btn primary" onclick="editPrompt(${prompt.id})" title="Edit Prompt">
                        <span>‚úèÔ∏è</span> Edit
                    </button>
                    <button class="prompt-action-btn secondary" onclick="duplicatePrompt(${prompt.id})" title="Duplicate Prompt">
                        <span>üìã</span> Duplicate
                    </button>
                </div>
                <div class="prompt-actions-right">
                    <button class="prompt-action-btn ${prompt.isActive ? 'secondary' : 'success'}"
                            onclick="togglePromptStatus(${prompt.id})"
                            title="${prompt.isActive ? 'Deactivate' : 'Activate'} Prompt">
                        <span>${prompt.isActive ? '‚è∏Ô∏è' : '‚ñ∂Ô∏è'}</span>
                    </button>
                    <button class="prompt-action-btn danger" onclick="deletePrompt(${prompt.id})" title="Delete Prompt">
                        <span>üóëÔ∏è</span>
                    </button>
                </div>
            </div>
        </div>
    `;
}

// Format date for display
function formatDate(dateString) {
    const date = new Date(dateString);
    return date.toLocaleDateString('en-US', {
        year: 'numeric',
        month: 'short',
        day: 'numeric'
    });
}

// Truncate content for preview
function truncateContent(content, maxLength) {
    if (content.length <= maxLength) return content;
    return content.substring(0, maxLength) + '...';
}

// Change view between grid and list
function changeView(viewType) {
    currentView = viewType;

    // Update view buttons
    document.querySelectorAll('.view-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.view === viewType);
    });

    // Update display
    const promptsList = document.getElementById('prompts-list');
    if (promptsList) {
        promptsList.className = `prompts-display ${viewType}-view`;
    }

    displayPrompts(filteredPrompts);
}

// Filter prompts based on search and filters
function filterPrompts() {
    const searchTerm = document.getElementById('prompt-search')?.value.toLowerCase() || '';
    const categoryFilter = document.getElementById('category-filter')?.value || '';
    const statusFilter = document.getElementById('status-filter')?.value || '';

    filteredPrompts = allPrompts.filter(prompt => {
        // Text search
        const matchesSearch = !searchTerm ||
            prompt.title.toLowerCase().includes(searchTerm) ||
            prompt.description.toLowerCase().includes(searchTerm) ||
            prompt.content.toLowerCase().includes(searchTerm) ||
            prompt.category.toLowerCase().includes(searchTerm);

        // Category filter
        const matchesCategory = !categoryFilter || prompt.category === categoryFilter;

        // Status filter
        const matchesStatus = !statusFilter ||
            (statusFilter === 'active' && prompt.isActive) ||
            (statusFilter === 'inactive' && !prompt.isActive);

        return matchesSearch && matchesCategory && matchesStatus;
    });

    displayPrompts(filteredPrompts);
}

// Clear search
function clearSearch() {
    const searchInput = document.getElementById('prompt-search');
    if (searchInput) {
        searchInput.value = '';
        filterPrompts();
    }
}

// Toggle prompt selection
function togglePromptSelection(promptId) {
    if (selectedPrompts.has(promptId)) {
        selectedPrompts.delete(promptId);
    } else {
        selectedPrompts.add(promptId);
    }

    updateSelectedCount();
    updateQuickActionsVisibility();
    updatePromptCardSelection(promptId);
}

// Update selected count display
function updateSelectedCount() {
    const selectedCount = document.getElementById('selected-count');
    if (selectedCount) {
        selectedCount.textContent = `${selectedPrompts.size} selected`;
    }
}

// Update quick actions panel visibility
function updateQuickActionsVisibility() {
    const quickActions = document.getElementById('quick-actions');
    if (quickActions) {
        quickActions.style.display = selectedPrompts.size > 0 ? 'flex' : 'none';
    }
}

// Update prompt card selection styling
function updatePromptCardSelection(promptId) {
    const promptCard = document.querySelector(`[data-prompt-id="${promptId}"]`);
    if (promptCard) {
        promptCard.classList.toggle('selected', selectedPrompts.has(promptId));
    }
}

// Prompt action functions
function editPrompt(promptId) {
    // This would integrate with your existing edit functionality
    console.log('Edit prompt:', promptId);
    showSuccessMessage(`Editing prompt ${promptId}...`);
}

function duplicatePrompt(promptId) {
    const prompt = allPrompts.find(p => p.id === promptId);
    if (prompt) {
        console.log('Duplicate prompt:', prompt);
        showSuccessMessage(`Prompt "${prompt.title}" duplicated successfully!`);
    }
}

function togglePromptStatus(promptId) {
    const prompt = allPrompts.find(p => p.id === promptId);
    if (prompt) {
        prompt.isActive = !prompt.isActive;
        const statusText = prompt.isActive ? 'activated' : 'deactivated';
        showSuccessMessage(`Prompt "${prompt.title}" ${statusText}!`);
        displayPrompts(filteredPrompts);
        loadPromptsStats(); // Refresh stats
    }
}

function deletePrompt(promptId) {
    const prompt = allPrompts.find(p => p.id === promptId);
    if (prompt && confirm(`Are you sure you want to delete "${prompt.title}"?`)) {
        allPrompts = allPrompts.filter(p => p.id !== promptId);
        filteredPrompts = filteredPrompts.filter(p => p.id !== promptId);
        selectedPrompts.delete(promptId);

        showSuccessMessage(`Prompt "${prompt.title}" deleted successfully!`);
        displayPrompts(filteredPrompts);
        loadPromptsStats(); // Refresh stats
        updateQuickActionsVisibility();
    }
}

// Bulk actions
function bulkActivatePrompts() {
    const count = selectedPrompts.size;
    selectedPrompts.forEach(promptId => {
        const prompt = allPrompts.find(p => p.id === promptId);
        if (prompt) prompt.isActive = true;
    });

    selectedPrompts.clear();
    displayPrompts(filteredPrompts);
    updateQuickActionsVisibility();
    loadPromptsStats();
    showSuccessMessage(`${count} prompts activated successfully!`);
}

function bulkDeactivatePrompts() {
    const count = selectedPrompts.size;
    selectedPrompts.forEach(promptId => {
        const prompt = allPrompts.find(p => p.id === promptId);
        if (prompt) prompt.isActive = false;
    });

    selectedPrompts.clear();
    displayPrompts(filteredPrompts);
    updateQuickActionsVisibility();
    loadPromptsStats();
    showSuccessMessage(`${count} prompts deactivated successfully!`);
}

function bulkDeletePrompts() {
    const count = selectedPrompts.size;
    if (confirm(`Are you sure you want to delete ${count} selected prompts?`)) {
        allPrompts = allPrompts.filter(p => !selectedPrompts.has(p.id));
        filteredPrompts = filteredPrompts.filter(p => !selectedPrompts.has(p.id));
        selectedPrompts.clear();

        displayPrompts(filteredPrompts);
        updateQuickActionsVisibility();
        loadPromptsStats();
        showSuccessMessage(`${count} prompts deleted successfully!`);
    }
}

// Utility function to show success messages
function showSuccessMessage(message) {
    const successDiv = document.getElementById('success-message');
    const textSpan = successDiv?.querySelector('.success-text');

    if (successDiv && textSpan) {
        textSpan.textContent = message;
        successDiv.classList.remove('hidden');

        setTimeout(() => {
            successDiv.classList.add('hidden');
        }, 3000);
    }
}

// Initialize when DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
    // Only initialize if we're on the prompts tab
    const promptsTab = document.getElementById('prompts-tab');
    if (promptsTab) {
        initializeEnhancedPrompts();
    }
});

// Export functions for global use
window.changeView = changeView;
window.clearSearch = clearSearch;
window.togglePromptSelection = togglePromptSelection;
window.editPrompt = editPrompt;
window.duplicatePrompt = duplicatePrompt;
window.togglePromptStatus = togglePromptStatus;
window.deletePrompt = deletePrompt;
window.bulkActivatePrompts = bulkActivatePrompts;
window.bulkDeactivatePrompts = bulkDeactivatePrompts;
window.bulkDeletePrompts = bulkDeletePrompts;

----------------------------------------------------------

enhanced-results.js

/**
 * Enhanced Result Display Functions
 * Provides enhanced display for AI Code Review and Prompt Testing results
 * with syntax highlighting and professional formatting
 */

// Enhanced result display for AI Code Review
function displayAIReviewResult(reviewResult, originalCode, language) {
    const resultContainer = document.getElementById('ai-review-result-container');
    const resultContent = document.getElementById('ai-review-result-content');
    const reviewTimestamp = document.getElementById('review-timestamp');
    const reviewModel = document.getElementById('review-model');

    if (!resultContainer || !resultContent) return;

    // Show the container
    resultContainer.classList.remove('hidden');

    // Update metadata
    if (reviewTimestamp) {
        reviewTimestamp.textContent = `Reviewed: ${new Date().toLocaleString()}`;
    }
    if (reviewModel) {
        reviewModel.textContent = 'Model: Claude 4.5 Sonnet';
    }

    // Create enhanced result display
    const enhancedContent = createEnhancedResultDisplay(
        originalCode,
        reviewResult,
        language,
        'AI Code Review Results'
    );

    resultContent.innerHTML = enhancedContent;

    // Scroll to results
    resultContainer.scrollIntoView({ behavior: 'smooth', block: 'start' });
}

// Enhanced result display for Prompt Testing
function displayPromptTestResult(testResult, originalCode, language, promptTitle) {
    const resultContainer = document.getElementById('test-result-container');
    const resultContent = document.getElementById('test-result-content');

    if (!resultContainer || !resultContent) return;

    // Show the container
    resultContainer.classList.remove('hidden');

    // Create enhanced result display
    const enhancedContent = createEnhancedResultDisplay(
        originalCode,
        testResult,
        language,
        `Prompt Test Results: ${promptTitle}`
    );

    resultContent.innerHTML = enhancedContent;

    // Scroll to results
    resultContainer.scrollIntoView({ behavior: 'smooth', block: 'start' });
}

// Create enhanced result display with syntax highlighting
function createEnhancedResultDisplay(originalCode, result, language, title) {
    const codeLines = originalCode.split('\n').length;
    const codeChars = originalCode.length;

    // Get language configuration for proper display
    const languageConfig = window.syntaxHighlighter ?
        window.syntaxHighlighter.constructor.name : null;

    return `
        <div class="enhanced-result-display">
            <!-- Theme Toggle -->
            <div class="theme-toggle-container">
                <div class="theme-toggle">
                    <button class="theme-btn active" onclick="switchResultTheme('dark')" data-theme="dark">Dark</button>
                    <button class="theme-btn" onclick="switchResultTheme('light')" data-theme="light">Light</button>
                    <button class="theme-btn" onclick="switchResultTheme('monokai')" data-theme="monokai">Monokai</button>
                </div>
            </div>

            <!-- Original Code Submission -->
            <div class="code-submission-section">
                <div class="section-header">
                    <h4>üìÑ Code Submission</h4>
                </div>
                <div class="code-submission-display">
                    <div class="code-submission-header">
                        <div class="submission-meta">
                            <div class="meta-item">
                                <span class="language-badge">${language.toUpperCase()}</span>
                            </div>
                            <div class="meta-item">
                                <span>üìè</span>
                                <span class="lines-count">${codeLines} lines</span>
                            </div>
                            <div class="meta-item">
                                <span>üî§</span>
                                <span>${codeChars} characters</span>
                            </div>
                        </div>
                    </div>
                    ${highlightCodeWithWrapper(originalCode, language, {
                        showLineNumbers: true,
                        showLanguage: true,
                        copyButton: true
                    })}
                </div>
            </div>

            <!-- Analysis Results -->
            <div class="analysis-results-section">
                <div class="section-header">
                    <h4>üîç Analysis Results</h4>
                </div>
                <div class="analysis-content">
                    ${formatAnalysisResult(result)}
                </div>
            </div>

            <!-- Action Buttons -->
            <div class="result-actions">
                <button class="action-button primary" onclick="downloadResultReport()">
                    <span>üìÑ</span> Download Report
                </button>
                <button class="action-button secondary" onclick="copyResultToClipboard()">
                    <span>üìã</span> Copy Results
                </button>
                <button class="action-button secondary" onclick="shareResult()">
                    <span>üîó</span> Share Results
                </button>
            </div>
        </div>
    `;
}

// Format analysis result with proper structure
function formatAnalysisResult(result) {
    if (typeof result === 'string') {
        // Parse markdown-like content if available
        return formatTextResult(result);
    } else if (typeof result === 'object') {
        // Handle structured result objects
        return formatStructuredResult(result);
    }

    return `<div class="result-text">${result}</div>`;
}

// Format text-based results with markdown-like parsing
function formatTextResult(text) {
    let formattedText = text;

    // Convert headers
    formattedText = formattedText.replace(/^### (.*$)/gim, '<h3 class="result-header">$1</h3>');
    formattedText = formattedText.replace(/^## (.*$)/gim, '<h2 class="result-header">$1</h2>');
    formattedText = formattedText.replace(/^# (.*$)/gim, '<h1 class="result-header">$1</h1>');

    // Convert bold text
    formattedText = formattedText.replace(/\\*\\*(.*?)\\*\\*/g, '<strong>$1</strong>');

    // Convert italic text
    formattedText = formattedText.replace(/\\*(.*?)\\*/g, '<em>$1</em>');

    // Convert code blocks
    formattedText = formattedText.replace(/```(\\w+)?\\n([\\s\\S]*?)\\n```/g, (match, lang, code) => {
        const language = lang || 'text';
        return highlightCodeWithWrapper(code.trim(), language, {
            showLineNumbers: true,
            showLanguage: true,
            copyButton: true
        });
    });

    // Convert inline code
    formattedText = formattedText.replace(/`([^`]+)`/g, '<code class="inline-code">$1</code>');

    // Convert lists
    formattedText = formattedText.replace(/^\\* (.*$)/gim, '<li>$1</li>');
    formattedText = formattedText.replace(/^\\- (.*$)/gim, '<li>$1</li>');

    // Wrap consecutive list items in ul tags
    formattedText = formattedText.replace(/((<li>.*<\\/li>\\s*)+)/g, '<ul class="result-list">$1</ul>');

    // Convert line breaks
    formattedText = formattedText.replace(/\\n\\n/g, '</p><p class="result-paragraph">');
    formattedText = formattedText.replace(/\\n/g, '<br>');

    return `<div class="formatted-result">
        <p class="result-paragraph">${formattedText}</p>
    </div>`;
}

// Format structured result objects
function formatStructuredResult(result) {
    let html = '<div class="structured-result">';

    if (result.summary) {
        html += `
            <div class="result-section">
                <h3 class="result-header">üìã Summary</h3>
                <div class="result-content">${result.summary}</div>
            </div>
        `;
    }

    if (result.issues && Array.isArray(result.issues)) {
        html += `
            <div class="result-section">
                <h3 class="result-header">‚ö†Ô∏è Issues Found</h3>
                <div class="issues-list">
                    ${result.issues.map((issue, index) => `
                        <div class="issue-item ${issue.severity || 'medium'}">
                            <div class="issue-header">
                                <span class="issue-number">${index + 1}</span>
                                <span class="issue-title">${issue.title || 'Issue'}</span>
                                <span class="issue-severity ${issue.severity || 'medium'}">${issue.severity || 'Medium'}</span>
                            </div>
                            <div class="issue-description">${issue.description}</div>
                            ${issue.suggestion ? `<div class="issue-suggestion">üí° <strong>Suggestion:</strong> ${issue.suggestion}</div>` : ''}
                        </div>
                    `).join('')}
                </div>
            </div>
        `;
    }

    if (result.recommendations) {
        html += `
            <div class="result-section">
                <h3 class="result-header">üí° Recommendations</h3>
                <div class="recommendations-list">
                    ${Array.isArray(result.recommendations)
                        ? result.recommendations.map(rec => `<div class="recommendation-item">‚úÖ ${rec}</div>`).join('')
                        : `<div class="recommendation-item">${result.recommendations}</div>`
                    }
                </div>
            </div>
        `;
    }

    html += '</div>';
    return html;
}

// Switch result theme
function switchResultTheme(theme) {
    // Update theme buttons
    document.querySelectorAll('.theme-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.theme === theme);
    });

    // Update syntax highlighter theme
    if (window.changeSyntaxTheme) {
        window.changeSyntaxTheme(theme);
    }

    // Update result containers
    document.querySelectorAll('.result-container').forEach(container => {
        container.setAttribute('data-theme', theme);
    });
}

// Download result report
function downloadResultReport() {
    const resultContent = document.querySelector('.enhanced-result-display');
    if (!resultContent) return;

    // Extract text content for download
    const textContent = extractTextFromResult(resultContent);
    const timestamp = new Date().toISOString().replace(/:/g, '-').split('.')[0];
    const filename = `code-review-report-${timestamp}.txt`;

    const blob = new Blob([textContent], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);

    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    a.click();

    URL.revokeObjectURL(url);

    showSuccessMessage(`Report downloaded as ${filename}`);
}

// Copy result to clipboard
function copyResultToClipboard() {
    const resultContent = document.querySelector('.enhanced-result-display');
    if (!resultContent) return;

    const textContent = extractTextFromResult(resultContent);

    navigator.clipboard.writeText(textContent).then(() => {
        showSuccessMessage('Results copied to clipboard!');
    }).catch(() => {
        showErrorMessage('Failed to copy results to clipboard');
    });
}

// Share result (placeholder for future implementation)
function shareResult() {
    showInfoMessage('Sharing functionality will be available in a future update');
}

// Extract text content from result display
function extractTextFromResult(container) {
    let text = 'CODE REVIEW REPORT\\n';
    text += '===================\\n\\n';

    const codeSubmission = container.querySelector('.code-submission-display');
    if (codeSubmission) {
        text += 'ORIGINAL CODE:\\n';
        text += '--------------\\n';
        const code = codeSubmission.querySelector('.syntax-code code');
        if (code) {
            text += code.textContent + '\\n\\n';
        }
    }

    const analysisResults = container.querySelector('.analysis-content');
    if (analysisResults) {
        text += 'ANALYSIS RESULTS:\\n';
        text += '----------------\\n';
        text += analysisResults.textContent + '\\n\\n';
    }

    text += `Generated on: ${new Date().toLocaleString()}\\n`;
    text += 'Generated by: Code Review Manager\\n';

    return text;
}

// Utility functions for messaging
function showSuccessMessage(message) {
    const successDiv = document.getElementById('success-message');
    const textSpan = successDiv?.querySelector('.success-text');

    if (successDiv && textSpan) {
        textSpan.textContent = message;
        successDiv.classList.remove('hidden');

        setTimeout(() => {
            successDiv.classList.add('hidden');
        }, 3000);
    }
}

function showErrorMessage(message) {
    const errorDiv = document.getElementById('error-message');
    const textSpan = errorDiv?.querySelector('.error-text');

    if (errorDiv && textSpan) {
        textSpan.textContent = message;
        errorDiv.classList.remove('hidden');

        setTimeout(() => {
            errorDiv.classList.add('hidden');
        }, 5000);
    }
}

function showInfoMessage(message) {
    showSuccessMessage(message);
}

// Enhanced integration with existing functions
function enhanceExistingResultDisplay() {
    // Override existing result display functions if they exist
    if (window.displayTestResult) {
        window.originalDisplayTestResult = window.displayTestResult;
        window.displayTestResult = function(result, code, language, prompt) {
            displayPromptTestResult(result, code, language, prompt);
        };
    }

    if (window.displayAIResult) {
        window.originalDisplayAIResult = window.displayAIResult;
        window.displayAIResult = function(result, code, language) {
            displayAIReviewResult(result, code, language);
        };
    }
}

// Initialize enhanced results when DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
    enhanceExistingResultDisplay();
});

// Export functions for global use
window.displayAIReviewResult = displayAIReviewResult;
window.displayPromptTestResult = displayPromptTestResult;
window.switchResultTheme = switchResultTheme;
window.downloadResultReport = downloadResultReport;
window.copyResultToClipboard = copyResultToClipboard;
window.shareResult = shareResult;

-----------------------------------------------------




admin.js
/**
 * Admin Panel Management
 * Handles system administration and configuration
 */

class AdminManager {
    constructor() {
        this.config = {};
    }

    init() {
        this.setupEventListeners();
        this.loadConfiguration();
        this.updateStatistics();
    }

    setupEventListeners() {
        // No specific event listeners needed for basic admin panel
        console.log('Admin panel initialized');
    }

    async loadConfiguration() {
        try {
            // Load current configuration from API
            const config = await apiCall('/admin/config', 'GET');
            this.config = config || {};
            this.populateConfigForm();
        } catch (error) {
            console.warn('Failed to load admin configuration:', error);
            this.loadDefaultConfig();
        }
    }

    loadDefaultConfig() {
        this.config = {
            emailEnabled: false,
            emailFrom: 'noreply@company.com',
            baseUrl: 'http://localhost:3000',
            aiModel: 'claude-3-5-sonnet'
        };
        this.populateConfigForm();
    }

    populateConfigForm() {
        document.getElementById('email-enabled').checked = this.config.emailEnabled || false;
        document.getElementById('email-from').value = this.config.emailFrom || '';
        document.getElementById('base-url').value = this.config.baseUrl || '';
        document.getElementById('ai-model').value = this.config.aiModel || 'claude-3-5-sonnet';
    }

    async updateStatistics() {
        try {
            // Get counts from other managers if available
            const stats = {
                teams: window.teamsManager?.teams?.length || 0,
                projects: window.projectsManager?.projects?.length || 0,
                reviews: window.reviewsManager?.reviews?.length || 0,
                prompts: 25 // Default from backend
            };

            document.getElementById('admin-teams-count').textContent = stats.teams;
            document.getElementById('admin-projects-count').textContent = stats.projects;
            document.getElementById('admin-reviews-count').textContent = stats.reviews;
            document.getElementById('admin-prompts-count').textContent = stats.prompts;

        } catch (error) {
            console.warn('Failed to update admin statistics:', error);
        }
    }
}

window.adminManager = new AdminManager();

// Global functions
window.saveEmailConfig = async function() {
    const config = {
        emailEnabled: document.getElementById('email-enabled').checked,
        emailFrom: document.getElementById('email-from').value,
        baseUrl: document.getElementById('base-url').value
    };

    try {
        await apiCall('/admin/config/email', 'POST', config);
        showSuccess('Email configuration saved successfully');
    } catch (error) {
        showError('Failed to save email configuration');
    }
};

window.testEmailConfig = function() {
    showInfo('Email test functionality would be implemented here');
};

window.saveAIConfig = async function() {
    const config = {
        aiModel: document.getElementById('ai-model').value
    };

    try {
        await apiCall('/admin/config/ai', 'POST', config);
        showSuccess('AI configuration saved successfully');
    } catch (error) {
        showError('Failed to save AI configuration');
    }
};

window.testAIConnection = async function() {
    try {
        showLoading();
        const result = await apiCall('/admin/test/ai', 'POST');
        showSuccess('AI connection test successful');
    } catch (error) {
        showError('AI connection test failed');
    } finally {
        hideLoading();
    }
};

window.openH2Console = function() {
    window.open('http://localhost:8081/api/h2-console', '_blank');
};

window.exportData = function() {
    showInfo('Data export functionality would be implemented here');
};

window.clearDatabase = function() {
    showConfirm(
        'Are you sure you want to clear all data? This action cannot be undone!',
        async () => {
            try {
                await apiCall('/admin/database/clear', 'POST');
                showSuccess('Database cleared successfully');
                // Refresh all managers
                if (window.teamsManager) await window.teamsManager.loadTeams();
                if (window.projectsManager) await window.projectsManager.loadProjects();
                if (window.reviewsManager) await window.reviewsManager.loadReviews();
            } catch (error) {
                showError('Failed to clear database');
            }
        }
    );
};

document.addEventListener('DOMContentLoaded', () => {
    if (document.getElementById('admin-tab')) {
        window.adminManager.init();
    }
});

----------------------------------------
ai-review.js


/**
 * AI Review Module
 * Handles AI-powered code review and prompt testing features
 */

// AI Review API functions
const aiReviewApi = {
    /**
     * Execute AI code review
     */
    async executeReview(promptId, code, context = {}) {
        const response = await fetch(`${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.AI_REVIEW_EXECUTE}`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                promptId: promptId,
                code: code,
                applicationType: context.applicationType || 'Spring Boot Application',
                springBootVersion: context.springBootVersion || '3.1.0',
                javaVersion: context.javaVersion || '17',
                databaseType: context.databaseType || 'H2'
            })
        });

        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`AI Review failed: ${response.status} - ${errorText}`);
        }

        return await response.json();
    },

    /**
     * Test a prompt with sample code
     */
    async testPrompt(promptId, sampleCode) {
        const response = await fetch(`${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.AI_REVIEW_TEST}`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                promptId: promptId,
                sampleCode: sampleCode
            })
        });

        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Prompt test failed: ${response.status} - ${errorText}`);
        }

        return await response.json();
    },

    /**
     * Check AI service status
     */
    async getStatus() {
        const response = await fetch(`${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.AI_REVIEW_STATUS}`);

        if (!response.ok) {
            throw new Error(`Status check failed: ${response.status}`);
        }

        return await response.json();
    }
};

// AI Review Functions called from HTML
async function executeAIReview() {
    const promptSelect = document.getElementById('review-prompt-select');
    const codeInput = document.getElementById('review-code-input');
    const executeBtn = document.getElementById('execute-review-btn');
    const resultContainer = document.getElementById('ai-review-result-container');
    const resultContent = document.getElementById('ai-review-result-content');
    const timestampEl = document.getElementById('review-timestamp');
    const modelEl = document.getElementById('review-model');

    // Validation
    if (!promptSelect.value) {
        showError('Please select a review prompt');
        return;
    }

    if (!codeInput.value.trim()) {
        showError('Please enter code to review');
        return;
    }

    try {
        // Show loading state
        executeBtn.disabled = true;
        executeBtn.innerHTML = '<span class="spinner"></span> Reviewing...';
        resultContainer.classList.add('hidden');

        // Execute review
        const result = await aiReviewApi.executeReview(
            parseInt(promptSelect.value),
            codeInput.value.trim()
        );

        // Display results
        resultContent.innerHTML = result.aiReview;
        timestampEl.textContent = `Generated: ${new Date(result.timestamp).toLocaleString()}`;
        modelEl.textContent = `Model: ${result.model}`;
        resultContainer.classList.remove('hidden');

        // Scroll to results
        resultContainer.scrollIntoView({ behavior: 'smooth', block: 'start' });

        showSuccess('AI code review completed successfully!');

    } catch (error) {
        console.error('AI Review error:', error);
        showError(`AI Review failed: ${error.message}`);
    } finally {
        executeBtn.disabled = false;
        executeBtn.innerHTML = '‚≠ê Get AI Review';
    }
}

async function testPrompt() {
    const promptSelect = document.getElementById('test-prompt-select');
    const sampleCodeInput = document.getElementById('test-sample-code');
    const testBtn = document.getElementById('test-prompt-btn');
    const resultContainer = document.getElementById('test-result-container');
    const resultContent = document.getElementById('test-result-content');

    // Validation
    if (!promptSelect.value) {
        showError('Please select a prompt to test');
        return;
    }

    if (!sampleCodeInput.value.trim()) {
        showError('Please enter sample code for testing');
        return;
    }

    try {
        // Show loading state
        testBtn.disabled = true;
        testBtn.innerHTML = '<span class="spinner"></span> Testing...';
        resultContainer.classList.add('hidden');

        // Test prompt
        const result = await aiReviewApi.testPrompt(
            parseInt(promptSelect.value),
            sampleCodeInput.value.trim()
        );

        // Display results
        resultContent.innerHTML = result.testResult;
        resultContainer.classList.remove('hidden');

        // Scroll to results
        resultContainer.scrollIntoView({ behavior: 'smooth', block: 'start' });

        showSuccess('Prompt test completed successfully!');

    } catch (error) {
        console.error('Prompt test error:', error);
        showError(`Prompt test failed: ${error.message}`);
    } finally {
        testBtn.disabled = false;
        testBtn.innerHTML = 'üß™ Test Prompt';
    }
}

function clearTestLab() {
    document.getElementById('test-prompt-select').value = '';
    document.getElementById('test-sample-code').value = `// Example Java Spring Boot code
@RestController
@RequestMapping("/api/users")
public class UserController {

    @Autowired
    private UserService userService;

    @GetMapping("/{id}")
    public ResponseEntity<User> getUser(@PathVariable String id) {
        User user = userService.findById(id);
        return ResponseEntity.ok(user);
    }
}`;
    document.getElementById('test-code-language').value = 'java';
    document.getElementById('test-result-container').classList.add('hidden');
}

function clearReviewForm() {
    document.getElementById('review-prompt-select').value = '';
    document.getElementById('review-code-input').value = '// Paste your code here';
    document.getElementById('review-code-language').value = 'java';
    document.getElementById('ai-review-result-container').classList.add('hidden');
}

// Initialize AI features when tab is shown
async function initializeAIFeatures() {
    try {
        // Check AI service status
        await updateAIStatus();

        // Load prompts for selectors
        await loadPromptsForAI();

    } catch (error) {
        console.error('Failed to initialize AI features:', error);
    }
}

async function updateAIStatus() {
    const testLabStatus = document.getElementById('test-lab-status');
    const aiReviewStatus = document.getElementById('ai-review-status');

    try {
        const status = await aiReviewApi.getStatus();

        const statusHTML = status.claudeApiConfigured
            ? `<strong>‚úÖ Claude AI Ready:</strong> ${status.message}`
            : `<strong>‚ö†Ô∏è Configuration Required:</strong> ${status.message}`;

        const statusClass = status.claudeApiConfigured ? 'success' : 'error';

        if (testLabStatus) {
            testLabStatus.innerHTML = statusHTML;
            testLabStatus.className = `ai-status ${statusClass}`;
        }

        if (aiReviewStatus) {
            aiReviewStatus.innerHTML = statusHTML;
            aiReviewStatus.className = `ai-status ${statusClass}`;
        }

    } catch (error) {
        const errorHTML = '<strong>‚ùå Service Unavailable:</strong> Unable to connect to AI service';

        if (testLabStatus) {
            testLabStatus.innerHTML = errorHTML;
            testLabStatus.className = 'ai-status error';
        }

        if (aiReviewStatus) {
            aiReviewStatus.innerHTML = errorHTML;
            aiReviewStatus.className = 'ai-status error';
        }
    }
}

async function loadPromptsForAI() {
    try {
        const prompts = await promptApi.getAll();

        const testPromptSelect = document.getElementById('test-prompt-select');
        const reviewPromptSelect = document.getElementById('review-prompt-select');

        // Clear existing options (keep placeholder)
        if (testPromptSelect) {
            testPromptSelect.innerHTML = '<option value="">Choose a prompt...</option>';
        }
        if (reviewPromptSelect) {
            reviewPromptSelect.innerHTML = '<option value="">Choose a prompt...</option>';
        }

        // Add prompts grouped by category
        const promptsByCategory = {};
        prompts.forEach(prompt => {
            const categoryName = prompt.category.name;
            if (!promptsByCategory[categoryName]) {
                promptsByCategory[categoryName] = [];
            }
            promptsByCategory[categoryName].push(prompt);
        });

        // Add options to both selects
        Object.keys(promptsByCategory).sort().forEach(categoryName => {
            if (testPromptSelect) {
                const optgroup = document.createElement('optgroup');
                optgroup.label = categoryName;
                testPromptSelect.appendChild(optgroup);

                promptsByCategory[categoryName].forEach(prompt => {
                    const option = document.createElement('option');
                    option.value = prompt.id;
                    option.textContent = prompt.title;
                    optgroup.appendChild(option);
                });
            }

            if (reviewPromptSelect) {
                const optgroup = document.createElement('optgroup');
                optgroup.label = categoryName;
                reviewPromptSelect.appendChild(optgroup);

                promptsByCategory[categoryName].forEach(prompt => {
                    const option = document.createElement('option');
                    option.value = prompt.id;
                    option.textContent = prompt.title;
                    optgroup.appendChild(option);
                });
            }
        });

    } catch (error) {
        console.error('Failed to load prompts for AI features:', error);
        showError('Failed to load prompts for AI features');
    }
}

// Export functions for global access
window.executeAIReview = executeAIReview;
window.testPrompt = testPrompt;
window.clearTestLab = clearTestLab;
window.clearReviewForm = clearReviewForm;
window.initializeAIFeatures = initializeAIFeatures;
window.updateAIStatus = updateAIStatus;
window.loadPromptsForAI = loadPromptsForAI;

-------------------------------


api.js


/**
 * API utility functions for making HTTP requests
 * Simple and clean implementation without external dependencies
 */

/**
 * Extract basic team information from potentially corrupted JSON response
 * This is a fallback for when the backend returns circular references or malformed JSON
 * @param {string} responseText - Raw response text from API
 * @returns {Array} Array of basic team objects
 */
function extractBasicTeamsData(responseText) {
    console.log('Attempting to extract basic team data from corrupted response...');
    const teams = [];

    try {
        // Use regex to find team objects in the malformed JSON
        const teamMatches = responseText.match(/\{"id":(\d+),"name":"([^"]+)","description":"([^"]*)","active":(true|false)/g);

        if (teamMatches) {
            teamMatches.forEach(match => {
                const idMatch = match.match(/"id":(\d+)/);
                const nameMatch = match.match(/"name":"([^"]+)"/);
                const descMatch = match.match(/"description":"([^"]*)"/);
                const activeMatch = match.match(/"active":(true|false)/);

                if (idMatch && nameMatch) {
                    teams.push({
                        id: parseInt(idMatch[1]),
                        name: nameMatch[1],
                        description: descMatch ? descMatch[1] : '',
                        active: activeMatch ? activeMatch[1] === 'true' : true,
                        createdDate: new Date().toISOString(),
                        lastModified: new Date().toISOString(),
                        projectsCount: 0
                    });
                }
            });
        }

        // Remove duplicates based on ID
        const uniqueTeams = teams.filter((team, index, self) =>
            index === self.findIndex(t => t.id === team.id)
        );

        console.log(`Extracted ${uniqueTeams.length} teams from corrupted response`);
        return uniqueTeams;

    } catch (error) {
        console.error('Failed to extract team data:', error);
        return [];
    }
}

/**
 * Makes an HTTP request
 * @param {string} url - The request URL
 * @param {object} options - Request options
 * @returns {Promise} Promise that resolves to the response data
 */
async function makeRequest(url, options = {}) {
    // Show loading indicator if this is the first request
    showLoading();

    try {
        const response = await fetch(url, {
            headers: {
                'Content-Type': 'application/json',
                ...options.headers
            },
            ...options
        });

        if (!response.ok) {
            const errorData = await response.json().catch(() => ({}));
            throw new Error(errorData.error || errorData.message || `HTTP error! status: ${response.status}`);
        }

        // Get response text first to handle large responses
        const responseText = await response.text();

        // Check if response is too large (might cause parsing issues)
        if (responseText.length > 100000) {
            console.warn(`Large API response detected: ${responseText.length} characters`);
            console.warn('This might indicate circular references or excessive data nesting');
        }

        try {
            const data = JSON.parse(responseText);
            return data;
        } catch (jsonError) {
            console.error('JSON parsing failed:', jsonError);
            console.error('Response length:', responseText.length);
            console.error('Response preview:', responseText.substring(0, 1000));

            // Try to extract basic team info if it's a teams request
            if (url.includes('/teams')) {
                return extractBasicTeamsData(responseText);
            }

            throw new Error('Invalid JSON response from server');
        }

    } catch (error) {
        console.error('API Request Error:', error);
        throw error;
    } finally {
        hideLoading();
    }
}

/**
 * GET request
 * @param {string} endpoint - API endpoint
 * @param {object} params - Query parameters
 * @returns {Promise} Promise that resolves to the response data
 */
async function get(endpoint, params = {}) {
    let url = `${API_CONFIG.BASE_URL}${endpoint}`;

    // Add query parameters if provided
    if (Object.keys(params).length > 0) {
        const queryString = new URLSearchParams(params).toString();
        url += `?${queryString}`;
    }

    return makeRequest(url, { method: 'GET' });
}

/**
 * POST request
 * @param {string} endpoint - API endpoint
 * @param {object} data - Request body data
 * @returns {Promise} Promise that resolves to the response data
 */
async function post(endpoint, data) {
    const url = `${API_CONFIG.BASE_URL}${endpoint}`;
    return makeRequest(url, {
        method: 'POST',
        body: JSON.stringify(data)
    });
}

/**
 * PUT request
 * @param {string} endpoint - API endpoint
 * @param {object} data - Request body data
 * @returns {Promise} Promise that resolves to the response data
 */
async function put(endpoint, data) {
    const url = `${API_CONFIG.BASE_URL}${endpoint}`;
    return makeRequest(url, {
        method: 'PUT',
        body: JSON.stringify(data)
    });
}

/**
 * DELETE request
 * @param {string} endpoint - API endpoint
 * @returns {Promise} Promise that resolves to the response data
 */
async function del(endpoint) {
    const url = `${API_CONFIG.BASE_URL}${endpoint}`;
    return makeRequest(url, { method: 'DELETE' });
}

/**
 * PATCH request
 * @param {string} endpoint - API endpoint
 * @param {object} data - Request body data
 * @returns {Promise} Promise that resolves to the response data
 */
async function patch(endpoint, data) {
    const url = `${API_CONFIG.BASE_URL}${endpoint}`;
    return makeRequest(url, {
        method: 'PATCH',
        body: JSON.stringify(data)
    });
}

// Category API functions
const categoryApi = {
    /**
     * Get all categories
     */
    getAll: () => get(API_CONFIG.ENDPOINTS.CATEGORIES),

    /**
     * Get category by ID
     */
    getById: (id) => get(`${API_CONFIG.ENDPOINTS.CATEGORIES}/${id}`),

    /**
     * Create new category
     */
    create: (categoryData) => post(API_CONFIG.ENDPOINTS.CATEGORIES, categoryData),

    /**
     * Update category
     */
    update: (id, categoryData) => put(`${API_CONFIG.ENDPOINTS.CATEGORIES}/${id}`, categoryData),

    /**
     * Delete category
     */
    delete: (id) => del(`${API_CONFIG.ENDPOINTS.CATEGORIES}/${id}`),

    /**
     * Search categories
     */
    search: (query) => get(API_CONFIG.ENDPOINTS.CATEGORIES_SEARCH, { q: query })
};

// Prompt API functions
const promptApi = {
    /**
     * Get all active prompts
     */
    getActive: () => get(API_CONFIG.ENDPOINTS.PROMPTS),

    /**
     * Get all prompts (including inactive)
     */
    getAll: () => get(API_CONFIG.ENDPOINTS.PROMPTS_ALL),

    /**
     * Get prompt by ID
     */
    getById: (id) => get(`${API_CONFIG.ENDPOINTS.PROMPTS}/${id}`),

    /**
     * Get prompts by category
     */
    getByCategory: (categoryId) => get(`${API_CONFIG.ENDPOINTS.PROMPTS_BY_CATEGORY}/${categoryId}`),

    /**
     * Create new prompt
     */
    create: (promptData) => post(API_CONFIG.ENDPOINTS.PROMPTS, promptData),

    /**
     * Update prompt
     */
    update: (id, promptData) => put(`${API_CONFIG.ENDPOINTS.PROMPTS}/${id}`, promptData),

    /**
     * Delete prompt
     */
    delete: (id) => del(`${API_CONFIG.ENDPOINTS.PROMPTS}/${id}`),

    /**
     * Update prompt status (active/inactive)
     */
    updateStatus: (id, isActive) => patch(`${API_CONFIG.ENDPOINTS.PROMPTS}/${id}/status`, { active: isActive }),

    /**
     * Search prompts
     */
    search: (query) => get(API_CONFIG.ENDPOINTS.PROMPTS_SEARCH, { q: query }),

    /**
     * Get prompt statistics
     */
    getStats: () => get(API_CONFIG.ENDPOINTS.PROMPTS_STATS)
};

// Team API functions
const teamApi = {
    /**
     * Get all teams
     */
    getAll: async () => {
        try {
            return await get(API_CONFIG.ENDPOINTS.TEAMS);
        } catch (error) {
            console.warn('Primary teams API failed, trying fallback...', error);

            // Fallback: return mock data if API fails completely
            return [
                {
                    id: 1,
                    name: 'Development Team',
                    description: 'Main development team',
                    active: true,
                    createdDate: new Date().toISOString(),
                    lastModified: new Date().toISOString(),
                    projectsCount: 1
                }
            ];
        }
    },

    /**
     * Get team by ID
     */
    getById: (id) => get(`${API_CONFIG.ENDPOINTS.TEAMS}/${id}`),

    /**
     * Create new team
     */
    create: (teamData) => post(API_CONFIG.ENDPOINTS.TEAMS, teamData),

    /**
     * Update team
     */
    update: (id, teamData) => put(`${API_CONFIG.ENDPOINTS.TEAMS}/${id}`, teamData),

    /**
     * Delete team
     */
    delete: (id) => del(`${API_CONFIG.ENDPOINTS.TEAMS}/${id}`),

    /**
     * Update team status (active/inactive)
     */
    updateStatus: (id, isActive) => patch(`${API_CONFIG.ENDPOINTS.TEAMS}/${id}/status`, { active: isActive }),

    /**
     * Search teams
     */
    search: (query) => get(API_CONFIG.ENDPOINTS.TEAMS_SEARCH, { q: query }),

    /**
     * Get team statistics
     */
    getStats: () => get(API_CONFIG.ENDPOINTS.TEAMS_STATS)
};

// Project API functions
const projectApi = {
    /**
     * Get all projects
     */
    getAll: () => get(API_CONFIG.ENDPOINTS.PROJECTS),

    /**
     * Get project by ID
     */
    getById: (id) => get(`${API_CONFIG.ENDPOINTS.PROJECTS}/${id}`),

    /**
     * Get projects by team
     */
    getByTeam: (teamId) => get(`${API_CONFIG.ENDPOINTS.PROJECTS_BY_TEAM}/${teamId}`),

    /**
     * Create new project
     */
    create: (projectData) => post(API_CONFIG.ENDPOINTS.PROJECTS, projectData),

    /**
     * Update project
     */
    update: (id, projectData) => put(`${API_CONFIG.ENDPOINTS.PROJECTS}/${id}`, projectData),

    /**
     * Delete project
     */
    delete: (id) => del(`${API_CONFIG.ENDPOINTS.PROJECTS}/${id}`),

    /**
     * Update project status (active/inactive)
     */
    updateStatus: (id, isActive) => patch(`${API_CONFIG.ENDPOINTS.PROJECTS}/${id}/status`, { active: isActive }),

    /**
     * Search projects
     */
    search: (query) => get(API_CONFIG.ENDPOINTS.PROJECTS_SEARCH, { q: query }),

    /**
     * Get project statistics
     */
    getStats: () => get(API_CONFIG.ENDPOINTS.PROJECTS_STATS)
};

// Code Review Submission API functions
const submissionApi = {
    /**
     * Get all submissions
     */
    getAll: () => get(API_CONFIG.ENDPOINTS.SUBMISSIONS),

    /**
     * Get submission by ID
     */
    getById: (id) => get(`${API_CONFIG.ENDPOINTS.SUBMISSIONS}/${id}`),

    /**
     * Get submissions by project
     */
    getByProject: (projectId) => get(`${API_CONFIG.ENDPOINTS.SUBMISSIONS_BY_PROJECT}/${projectId}`),

    /**
     * Get submissions by team
     */
    getByTeam: (teamId) => get(`${API_CONFIG.ENDPOINTS.SUBMISSIONS_BY_TEAM}/${teamId}`),

    /**
     * Create new submission
     */
    create: (submissionData) => post(API_CONFIG.ENDPOINTS.SUBMISSIONS, submissionData),

    /**
     * Update submission
     */
    update: (id, submissionData) => put(`${API_CONFIG.ENDPOINTS.SUBMISSIONS}/${id}`, submissionData),

    /**
     * Delete submission
     */
    delete: (id) => del(`${API_CONFIG.ENDPOINTS.SUBMISSIONS}/${id}`),

    /**
     * Update submission status
     */
    updateStatus: (id, status) => patch(`${API_CONFIG.ENDPOINTS.SUBMISSIONS}/${id}/status`, { status: status }),

    /**
     * Search submissions
     */
    search: (query) => get(API_CONFIG.ENDPOINTS.SUBMISSIONS_SEARCH, { q: query }),

    /**
     * Get submission statistics
     */
    getStats: () => get(API_CONFIG.ENDPOINTS.SUBMISSIONS_STATS),

    /**
     * Cancel submission
     */
    cancel: (reviewId) => post(`${API_CONFIG.ENDPOINTS.SUBMISSIONS}/${reviewId}/cancel`, {})
};

// Export API objects to global scope
window.categoryApi = categoryApi;
window.promptApi = promptApi;
window.teamApi = teamApi;
window.projectApi = projectApi;
window.submissionApi = submissionApi;
---------------------------------------

app.js

/**
 * Main application file
 * Initializes the application and sets up event listeners
 */

// Global state for confirm dialog
let confirmCallback = null;

/**
 * Initialize the application when DOM is loaded
 */
document.addEventListener('DOMContentLoaded', function() {
    console.log('Code Review Manager application starting...');

    // Initialize tabs
    initializeTabs();

    // Initialize forms
    initializeForms();

    // Initialize search functionality
    initializeSearch();

    // Load initial data
    loadInitialData();

    console.log('Application initialized successfully');
});

/**
 * Initialize tab navigation
 */
function initializeTabs() {
    const tabButtons = document.querySelectorAll('.tab-btn');

    tabButtons.forEach(button => {
        button.addEventListener('click', function() {
            const tabName = this.getAttribute('data-tab');
            switchTab(tabName);

            // Load data for the active tab
            if (tabName === 'prompts') {
                loadPrompts();
            } else if (tabName === 'categories') {
                loadCategories();
            } else if (tabName === 'code-review') {
                // Code Review manager will be initialized by the switchTab function
                console.log('Switched to Code Review tab');
            } else if (tabName === 'test-lab' || tabName === 'ai-review') {
                // AI features will be initialized by the switchTab function
                console.log(`Switched to AI tab: ${tabName}`);
            } else if (tabName === 'project-analyzer') {
                // Project Analyzer will be initialized by the switchTab function
                console.log('Switched to Project Analyzer tab');
            }
        });
    });
}

/**
 * Initialize form event listeners
 */
function initializeForms() {
    // Prompt form
    const promptForm = el('prompt-form');
    if (promptForm) {
        promptForm.addEventListener('submit', handlePromptFormSubmit);
    }

    // Category form
    const categoryForm = el('category-form');
    if (categoryForm) {
        categoryForm.addEventListener('submit', handleCategoryFormSubmit);
    }

    // Modal close on background click
    setupModalCloseOnBackgroundClick();
}

/**
 * Initialize search functionality
 */
function initializeSearch() {
    // Prompt search
    const promptSearch = el('prompt-search');
    if (promptSearch) {
        promptSearch.addEventListener('input', searchPrompts);
        promptSearch.addEventListener('keydown', function(e) {
            if (e.key === 'Enter') {
                e.preventDefault();
                searchPrompts();
            }
        });
    }

    // Category search
    const categorySearch = el('category-search');
    if (categorySearch) {
        categorySearch.addEventListener('input', searchCategories);
        categorySearch.addEventListener('keydown', function(e) {
            if (e.key === 'Enter') {
                e.preventDefault();
                searchCategories();
            }
        });
    }
}

/**
 * Setup modal close on background click
 */
function setupModalCloseOnBackgroundClick() {
    const modals = document.querySelectorAll('.modal');

    modals.forEach(modal => {
        modal.addEventListener('click', function(e) {
            if (e.target === modal) {
                // Click was on the modal background
                modal.classList.add('hidden');
            }
        });
    });
}

/**
 * Load initial data for the application
 */
async function loadInitialData() {
    try {
        // Load prompts (default active tab)
        await loadPrompts();

        // Load categories for filter dropdown
        await loadCategoriesForFilter();

        console.log('Initial data loaded successfully');
    } catch (error) {
        console.error('Failed to load initial data:', error);
        showError('Failed to load initial data. Please refresh the page.');
    }
}

/**
 * Code copy functionality for README tab
 */
function copyCode(button) {
    const code = button.getAttribute('data-code');
    const originalText = button.textContent;

    navigator.clipboard.writeText(code).then(function() {
        button.textContent = 'Copied!';
        button.style.background = '#10b981';

        setTimeout(function() {
            button.textContent = originalText;
            button.style.background = '#667eea';
        }, 2000);
    }).catch(function(err) {
        console.error('Failed to copy code: ', err);
        button.textContent = 'Failed';
        button.style.background = '#e53e3e';

        setTimeout(function() {
            button.textContent = originalText;
            button.style.background = '#667eea';
        }, 2000);
    });
}

/**
 * Show confirmation dialog
 */
function showConfirmDialog(message, callback) {
    const modal = el('confirm-modal');
    const messageEl = el('confirm-message');

    if (!modal || !messageEl) return;

    messageEl.textContent = message;
    confirmCallback = callback;
    modal.classList.remove('hidden');
}

/**
 * Hide confirmation dialog
 */
function hideConfirmModal() {
    const modal = el('confirm-modal');
    if (modal) modal.classList.add('hidden');
    confirmCallback = null;
}

/**
 * Execute the confirm action
 */
function confirmDelete() {
    if (confirmCallback) {
        confirmCallback();
    }
    hideConfirmModal();
}

/**
 * Handle keyboard shortcuts
 */
document.addEventListener('keydown', function(e) {
    // Escape key to close modals
    if (e.key === 'Escape') {
        const visibleModals = document.querySelectorAll('.modal:not(.hidden)');
        visibleModals.forEach(modal => {
            modal.classList.add('hidden');
        });
        hideError();
        hideSuccess();
    }

    // Ctrl+N to create new item
    if (e.ctrlKey && e.key === 'n') {
        e.preventDefault();
        const activeTab = document.querySelector('.tab-btn.active');
        if (activeTab) {
            const tabName = activeTab.getAttribute('data-tab');
            if (tabName === 'prompts') {
                showPromptForm();
            } else if (tabName === 'categories') {
                showCategoryForm();
            }
        }
    }
});

/**
 * Handle window resize
 */
window.addEventListener('resize', function() {
    // Handle responsive adjustments if needed
    console.log('Window resized');
});

/**
 * Handle errors globally
 */
window.addEventListener('error', function(e) {
    console.error('Global error:', e.error);
    showError('An unexpected error occurred. Please try again.');
});

/**
 * Handle unhandled promise rejections
 */
window.addEventListener('unhandledrejection', function(e) {
    console.error('Unhandled promise rejection:', e.reason);
    showError('A network error occurred. Please check your connection and try again.');
    e.preventDefault(); // Prevent the default handling
});

console.log('App.js loaded successfully');

-----------------------------------------------------------
categories.js

/**
 * Category management functions
 * Handles all category-related UI operations
 */

// Global variable to store current categories
let currentCategories = [];

/**
 * Load and display all categories
 */
async function loadCategories() {
    try {
        currentCategories = await categoryApi.getAll();
        displayCategories(currentCategories);
        loadCategoriesForFilter(); // Update the filter dropdown
    } catch (error) {
        showError('Failed to load categories: ' + error.message);
        displayCategories([]);
    }
}

/**
 * Display categories in the list
 */
function displayCategories(categories) {
    const categoriesList = el('categories-list');
    if (!categoriesList) return;

    if (categories.length === 0) {
        categoriesList.innerHTML = `
            <div class="empty-state">
                <p>${MESSAGES.NO_CATEGORIES}</p>
            </div>
        `;
        return;
    }

    categoriesList.innerHTML = categories.map(category => `
        <div class="category-card" data-id="${category.id}">
            <div class="category-header">
                <h3 class="category-name">${escapeHtml(category.name)}</h3>
                <div class="category-actions">
                    <button class="btn-small btn-secondary" onclick="editCategory(${category.id})">Edit</button>
                    <button class="btn-small btn-danger" onclick="deleteCategory(${category.id})">Delete</button>
                </div>
            </div>
            ${category.description ? `<div class="category-description">${escapeHtml(category.description)}</div>` : ''}
            <div class="category-footer">
                <small class="category-date">
                    Created: ${formatDate(category.createdAt)}
                    ${category.updatedAt !== category.createdAt ? `| Updated: ${formatDate(category.updatedAt)}` : ''}
                </small>
            </div>
        </div>
    `).join('');
}

/**
 * Load categories for the filter dropdown
 */
async function loadCategoriesForFilter() {
    try {
        const categories = await categoryApi.getAll();
        const select = el('category-filter');
        if (!select) return;

        select.innerHTML = '<option value="">All Categories</option>' +
            categories.map(cat => `<option value="${cat.id}">${escapeHtml(cat.name)}</option>`).join('');
    } catch (error) {
        console.error('Failed to load categories for filter:', error);
    }
}

/**
 * Show category form for creating new category
 */
function showCategoryForm(categoryId = null) {
    const modal = el('category-modal');
    const form = el('category-form');
    const title = el('category-modal-title');

    if (!modal || !form || !title) return;

    // Reset form
    form.reset();
    el('category-id').value = '';

    if (categoryId) {
        title.textContent = 'Edit Category';
        loadCategoryForEditing(categoryId);
    } else {
        title.textContent = 'Add New Category';
    }

    modal.classList.remove('hidden');
}

/**
 * Load category data for editing
 */
async function loadCategoryForEditing(categoryId) {
    try {
        const category = await categoryApi.getById(categoryId);
        if (!category) return;

        el('category-id').value = category.id;
        el('category-name').value = category.name;
        el('category-description').value = category.description || '';
    } catch (error) {
        showError('Failed to load category for editing: ' + error.message);
    }
}

/**
 * Hide category form modal
 */
function hideCategoryModal() {
    const modal = el('category-modal');
    if (modal) modal.classList.add('hidden');
}

/**
 * Search categories
 */
const searchCategories = debounce(async function() {
    const searchInput = el('category-search');
    const query = searchInput ? searchInput.value.trim() : '';

    try {
        if (query) {
            currentCategories = await categoryApi.search(query);
        } else {
            currentCategories = await categoryApi.getAll();
        }
        displayCategories(currentCategories);
    } catch (error) {
        showError('Search failed: ' + error.message);
    }
}, UI_CONFIG.DEBOUNCE_DELAY);

/**
 * Edit category
 */
function editCategory(categoryId) {
    showCategoryForm(categoryId);
}

/**
 * Delete category
 */
function deleteCategory(categoryId) {
    showConfirmDialog('Are you sure you want to delete this category?', () => {
        performDeleteCategory(categoryId);
    });
}

/**
 * Perform category deletion
 */
async function performDeleteCategory(categoryId) {
    try {
        await categoryApi.delete(categoryId);
        showSuccess('Category deleted successfully');
        loadCategories(); // Reload the list
    } catch (error) {
        showError('Failed to delete category: ' + error.message);
    }
}

/**
 * Handle category form submission
 */
async function handleCategoryFormSubmit(event) {
    event.preventDefault();

    const categoryId = el('category-id').value;
    const categoryData = {
        name: el('category-name').value.trim(),
        description: el('category-description').value.trim()
    };

    try {
        if (categoryId) {
            // Update existing category
            await categoryApi.update(categoryId, categoryData);
            showSuccess('Category updated successfully');
        } else {
            // Create new category
            await categoryApi.create(categoryData);
            showSuccess('Category created successfully');
        }

        hideCategoryModal();
        loadCategories(); // Reload the list
    } catch (error) {
        showError('Failed to save category: ' + error.message);
    }
}
--------------------------------------------
code-editor.js

/**
 * Enhanced Code Editor Functionality
 * Provides advanced features for code input areas
 */

// Sample code templates for different languages
const SAMPLE_CODE_TEMPLATES = {
    java: `// Sample Java Spring Boot code
@RestController
@RequestMapping("/api/users")
public class UserController {

    @Autowired
    private UserService userService;

    @GetMapping("/{id}")
    public ResponseEntity<User> getUser(@PathVariable String id) {
        try {
            User user = userService.findById(id);
            if (user == null) {
                return ResponseEntity.notFound().build();
            }
            return ResponseEntity.ok(user);
        } catch (Exception e) {
            return ResponseEntity.internalServerError().build();
        }
    }

    @PostMapping
    public ResponseEntity<User> createUser(@RequestBody CreateUserRequest request) {
        User user = userService.createUser(request.getName(), request.getEmail());
        return ResponseEntity.ok(user);
    }
}`,

    javascript: `// Sample JavaScript/Node.js code
const express = require('express');
const app = express();

app.use(express.json());

// User routes
app.get('/api/users/:id', async (req, res) => {
    try {
        const userId = req.params.id;
        const user = await userService.findById(userId);

        if (!user) {
            return res.status(404).json({ error: 'User not found' });
        }

        res.json(user);
    } catch (error) {
        console.error('Error fetching user:', error);
        res.status(500).json({ error: 'Internal server error' });
    }
});

app.post('/api/users', async (req, res) => {
    const { name, email } = req.body;
    const user = await userService.createUser(name, email);
    res.json(user);
});

app.listen(3000, () => {
    console.log('Server running on port 3000');
});`,

    python: `# Sample Python Flask code
from flask import Flask, request, jsonify
from flask_sqlalchemy import SQLAlchemy

app = Flask(__name__)
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///users.db'
db = SQLAlchemy(app)

class User(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(80), nullable=False)
    email = db.Column(db.String(120), unique=True, nullable=False)

@app.route('/api/users/<int:user_id>', methods=['GET'])
def get_user(user_id):
    try:
        user = User.query.get(user_id)
        if not user:
            return jsonify({'error': 'User not found'}), 404

        return jsonify({
            'id': user.id,
            'name': user.name,
            'email': user.email
        })
    except Exception as e:
        return jsonify({'error': 'Internal server error'}), 500

@app.route('/api/users', methods=['POST'])
def create_user():
    data = request.get_json()
    user = User(name=data['name'], email=data['email'])
    db.session.add(user)
    db.session.commit()
    return jsonify({'id': user.id, 'name': user.name, 'email': user.email})

if __name__ == '__main__':
    app.run(debug=True)`,

    csharp: `// Sample C# .NET code
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;

[ApiController]
[Route("api/[controller]")]
public class UsersController : ControllerBase
{
    private readonly UserContext _context;

    public UsersController(UserContext context)
    {
        _context = context;
    }

    [HttpGet("{id}")]
    public async Task<ActionResult<User>> GetUser(int id)
    {
        try
        {
            var user = await _context.Users.FindAsync(id);

            if (user == null)
            {
                return NotFound();
            }

            return user;
        }
        catch (Exception ex)
        {
            return StatusCode(500, new { error = "Internal server error" });
        }
    }

    [HttpPost]
    public async Task<ActionResult<User>> CreateUser(CreateUserRequest request)
    {
        var user = new User
        {
            Name = request.Name,
            Email = request.Email
        };

        _context.Users.Add(user);
        await _context.SaveChangesAsync();

        return CreatedAtAction(nameof(GetUser), new { id = user.Id }, user);
    }
}`,

    typescript: `// Sample TypeScript/Express code
import express, { Request, Response } from 'express';
import { UserService } from './services/UserService';

const app = express();
app.use(express.json());

interface CreateUserRequest {
    name: string;
    email: string;
}

interface User {
    id: number;
    name: string;
    email: string;
}

class UserController {
    constructor(private userService: UserService) {}

    async getUser(req: Request, res: Response): Promise<void> {
        try {
            const userId = parseInt(req.params.id);
            const user: User | null = await this.userService.findById(userId);

            if (!user) {
                res.status(404).json({ error: 'User not found' });
                return;
            }

            res.json(user);
        } catch (error) {
            console.error('Error fetching user:', error);
            res.status(500).json({ error: 'Internal server error' });
        }
    }

    async createUser(req: Request<{}, User, CreateUserRequest>, res: Response): Promise<void> {
        const { name, email } = req.body;
        const user = await this.userService.createUser(name, email);
        res.json(user);
    }
}

const userController = new UserController(new UserService());

app.get('/api/users/:id', userController.getUser.bind(userController));
app.post('/api/users', userController.createUser.bind(userController));

app.listen(3000, () => {
    console.log('Server running on port 3000');
});`
};

// Initialize code editors
function initializeCodeEditors() {
    // Initialize all code editors on page load
    const editors = document.querySelectorAll('.code-editor');
    editors.forEach(editor => {
        initializeCodeEditor(editor.id);
    });
}

// Initialize a specific code editor
function initializeCodeEditor(editorId) {
    const editor = document.getElementById(editorId);
    if (!editor) return;

    // Update line numbers and character count
    updateEditorStats(editorId);

    // Add event listeners
    editor.addEventListener('input', () => updateEditorStats(editorId));
    editor.addEventListener('scroll', () => syncLineNumbers(editorId));
    editor.addEventListener('keydown', (e) => handleEditorKeydown(e, editorId));

    // Initialize line numbers
    updateLineNumbers(editorId);
}

// Update line numbers for an editor
function updateLineNumbers(editorId) {
    const editor = document.getElementById(editorId);
    const lineNumbersId = editorId.replace(/(test-sample-code|review-code-input)/, '$1').replace(/code/, 'line-numbers');
    const lineNumbers = document.getElementById(lineNumbersId);

    if (!editor || !lineNumbers) return;

    const lines = editor.value.split('\n');
    const lineNumbersText = lines.map((_, index) => index + 1).join('\n');
    lineNumbers.textContent = lineNumbersText;
}

// Update editor statistics (lines, characters)
function updateEditorStats(editorId) {
    const editor = document.getElementById(editorId);
    if (!editor) return;

    const content = editor.value;
    const lines = content.split('\n').length;
    const chars = content.length;

    // Update line numbers
    updateLineNumbers(editorId);

    // Update stats in footer
    const linesSpanId = editorId.replace(/(test-sample-code|review-code-input)/, (match) => {
        return match.includes('test') ? 'test-code-lines' : 'review-code-lines';
    });
    const charsSpanId = editorId.replace(/(test-sample-code|review-code-input)/, (match) => {
        return match.includes('test') ? 'test-code-chars' : 'review-code-chars';
    });

    const linesSpan = document.getElementById(linesSpanId);
    const charsSpan = document.getElementById(charsSpanId);

    if (linesSpan) linesSpan.textContent = `Lines: ${lines}`;
    if (charsSpan) charsSpan.textContent = `Characters: ${chars}`;
}

// Sync line numbers scroll with editor scroll
function syncLineNumbers(editorId) {
    const editor = document.getElementById(editorId);
    const lineNumbersId = editorId.replace(/(test-sample-code|review-code-input)/, (match) => {
        return match.includes('test') ? 'test-line-numbers' : 'review-line-numbers';
    });
    const lineNumbers = document.getElementById(lineNumbersId);

    if (!editor || !lineNumbers) return;

    lineNumbers.scrollTop = editor.scrollTop;
}

// Handle special keyboard shortcuts in editor
function handleEditorKeydown(event, editorId) {
    const editor = document.getElementById(editorId);
    if (!editor) return;

    // Tab key handling
    if (event.key === 'Tab') {
        event.preventDefault();
        const start = editor.selectionStart;
        const end = editor.selectionEnd;

        // Insert tab character
        editor.value = editor.value.substring(0, start) + '\t' + editor.value.substring(end);
        editor.selectionStart = editor.selectionEnd = start + 1;

        updateEditorStats(editorId);
    }

    // Ctrl+A to select all
    if (event.ctrlKey && event.key === 'a') {
        event.preventDefault();
        editor.select();
    }
}

// Format code (basic indentation)
function formatCode(editorId) {
    const editor = document.getElementById(editorId);
    if (!editor) return;

    let code = editor.value;

    // Basic formatting - fix indentation
    const lines = code.split('\n');
    let indentLevel = 0;
    const indentSize = 4;

    const formattedLines = lines.map(line => {
        const trimmedLine = line.trim();

        // Decrease indent for closing brackets
        if (trimmedLine.startsWith('}') || trimmedLine.startsWith(')')) {
            indentLevel = Math.max(0, indentLevel - 1);
        }

        const formattedLine = ' '.repeat(indentLevel * indentSize) + trimmedLine;

        // Increase indent for opening brackets
        if (trimmedLine.endsWith('{') || trimmedLine.endsWith('(')) {
            indentLevel++;
        }

        return formattedLine;
    });

    editor.value = formattedLines.join('\n');
    updateEditorStats(editorId);

    showSuccessMessage('Code formatted successfully!');
}

// Clear code editor
function clearCode(editorId) {
    const editor = document.getElementById(editorId);
    if (!editor) return;

    if (editor.value.trim() === '') {
        showInfoMessage('Editor is already empty');
        return;
    }

    editor.value = '';
    updateEditorStats(editorId);
    editor.focus();

    showSuccessMessage('Code cleared successfully!');
}

// Copy code to clipboard
function copyCode(editorId) {
    const editor = document.getElementById(editorId);
    if (!editor) return;

    if (editor.value.trim() === '') {
        showInfoMessage('No code to copy');
        return;
    }

    navigator.clipboard.writeText(editor.value).then(() => {
        showSuccessMessage('Code copied to clipboard!');
    }).catch(err => {
        console.error('Failed to copy code:', err);
        showErrorMessage('Failed to copy code to clipboard');

        // Fallback - select text
        editor.select();
        document.execCommand('copy');
        showInfoMessage('Code selected. Press Ctrl+C to copy');
    });
}

// Load sample code based on selected language
function loadSampleCode(editorId) {
    const editor = document.getElementById(editorId);
    if (!editor) return;

    // Get language from the corresponding language selector
    let languageSelectId;
    if (editorId === 'test-sample-code') {
        languageSelectId = 'test-code-language';
    } else if (editorId === 'review-code-input') {
        languageSelectId = 'review-code-language';
    }

    const languageSelect = document.getElementById(languageSelectId);
    const language = languageSelect ? languageSelect.value : 'java';

    const sampleCode = SAMPLE_CODE_TEMPLATES[language] || SAMPLE_CODE_TEMPLATES.java;

    if (editor.value.trim() !== '' && editor.value !== sampleCode) {
        if (!confirm('This will replace the current code. Continue?')) {
            return;
        }
    }

    editor.value = sampleCode;
    updateEditorStats(editorId);

    showSuccessMessage(`Sample ${language.charAt(0).toUpperCase() + language.slice(1)} code loaded!`);
}

// Show success message
function showSuccessMessage(message) {
    const successDiv = document.getElementById('success-message');
    const textSpan = successDiv?.querySelector('.success-text');

    if (successDiv && textSpan) {
        textSpan.textContent = message;
        successDiv.classList.remove('hidden');

        // Auto-hide after 3 seconds
        setTimeout(() => {
            successDiv.classList.add('hidden');
        }, 3000);
    }
}

// Show info message (reuse success styling)
function showInfoMessage(message) {
    showSuccessMessage(message);
}

// Show error message
function showErrorMessage(message) {
    const errorDiv = document.getElementById('error-message');
    const textSpan = errorDiv?.querySelector('.error-text');

    if (errorDiv && textSpan) {
        textSpan.textContent = message;
        errorDiv.classList.remove('hidden');

        // Auto-hide after 5 seconds
        setTimeout(() => {
            errorDiv.classList.add('hidden');
        }, 5000);
    }
}

// Initialize when DOM is loaded
document.addEventListener('DOMContentLoaded', initializeCodeEditors);

// Export functions for global use
window.formatCode = formatCode;
window.clearCode = clearCode;
window.copyCode = copyCode;
window.loadSampleCode = loadSampleCode;
---------------------------------------------------------------
code-review-submission.js

/**
 * Code Review Submission Management
 * Handles code submission with file upload and validation
 */

class CodeReviewSubmissionManager {
    constructor() {
        this.projects = [];
        this.maxFileSize = 5 * 1024 * 1024; // 5MB
        this.initialized = false;
    }

    init() {
        if (this.initialized) {
            console.log('CodeReviewSubmissionManager: Already initialized, skipping...');
            return;
        }

        console.log('CodeReviewSubmissionManager: Initializing...');
        this.setupEventListeners();
        this.loadProjects();
        this.initialized = true;
    }

    setupEventListeners() {
        const form = document.getElementById('code-review-form');
        if (form) {
            form.addEventListener('submit', (e) => this.handleSubmit(e));
        }

        const codeTextarea = document.getElementById('review-code-content');
        if (codeTextarea) {
            codeTextarea.addEventListener('input', () => this.updateCodeStats());
        }

        const fileUpload = document.getElementById('code-file-upload');
        if (fileUpload) {
            fileUpload.addEventListener('change', (e) => this.handleFileUpload(e));
        }
    }

    async loadProjects() {
        try {
            console.log('CodeReviewSubmissionManager: loadProjects() called');

            if (window.projectsManager && window.projectsManager.projects) {
                console.log('CodeReviewSubmissionManager: Using projects from projectsManager:', window.projectsManager.projects);
                this.projects = window.projectsManager.projects.filter(p => p.active);
            } else {
                console.log('CodeReviewSubmissionManager: Loading projects via API...');
                const response = await projectApi.getAll();
                console.log('CodeReviewSubmissionManager: API response:', response);
                this.projects = (response || []).filter(p => p.active);
            }

            console.log('CodeReviewSubmissionManager: Filtered active projects:', this.projects);
            this.populateProjectSelector();
        } catch (error) {
            console.warn('Failed to load projects:', error);
        }
    }

    populateProjectSelector() {
        console.log('CodeReviewSubmissionManager: populateProjectSelector() called');
        const selector = document.getElementById('review-project');
        console.log('CodeReviewSubmissionManager: Selector element:', selector);

        if (selector) {
            selector.innerHTML = '<option value="">Select a project</option>';

            console.log('CodeReviewSubmissionManager: Adding projects to selector:', this.projects.length);
            this.projects.forEach(project => {
                const option = document.createElement('option');
                option.value = project.id;
                // For now, just display project name since team info is not available
                // due to @JsonBackReference annotation in the backend
                option.textContent = project.name;
                selector.appendChild(option);
                console.log(`CodeReviewSubmissionManager: Added project: ${project.name} (ID: ${project.id})`);
            });

            console.log(`CodeReviewSubmissionManager: Selector now has ${selector.options.length} options`);
        } else {
            console.warn('CodeReviewSubmissionManager: #review-project selector not found in DOM');
        }
    }

    updateCodeStats() {
        const textarea = document.getElementById('review-code-content');
        const linesCount = document.getElementById('code-lines-count');
        const charsCount = document.getElementById('code-chars-count');

        if (textarea && linesCount && charsCount) {
            const content = textarea.value;
            const lines = content.split('\n').length;
            const chars = content.length;

            linesCount.textContent = `${lines} lines`;
            charsCount.textContent = `${chars} characters`;
        }
    }

    async handleFileUpload(event) {
        const file = event.target.files[0];
        if (!file) return;

        if (file.size > this.maxFileSize) {
            showError('File size must be less than 5MB');
            event.target.value = '';
            return;
        }

        try {
            const content = await this.readFileContent(file);
            const textarea = document.getElementById('review-code-content');
            if (textarea) {
                textarea.value = content;
                this.updateCodeStats();
            }

            // Try to detect language from file extension
            const language = this.detectLanguageFromFilename(file.name);
            if (language) {
                const languageSelect = document.getElementById('review-language');
                if (languageSelect) {
                    languageSelect.value = language;
                }
            }

            // Set file path if empty
            const filePathInput = document.getElementById('review-file-path');
            if (filePathInput && !filePathInput.value) {
                filePathInput.value = file.name;
            }

            showSuccess(`File "${file.name}" loaded successfully`);

        } catch (error) {
            showError('Failed to read file content');
            console.error('File upload error:', error);
        }
    }

    readFileContent(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = (e) => resolve(e.target.result);
            reader.onerror = (e) => reject(e);
            reader.readAsText(file);
        });
    }

    detectLanguageFromFilename(filename) {
        const extension = filename.split('.').pop()?.toLowerCase();

        const languageMap = {
            'js': 'javascript',
            'jsx': 'javascript',
            'ts': 'typescript',
            'tsx': 'typescript',
            'py': 'python',
            'java': 'java',
            'cs': 'csharp',
            'cpp': 'cpp',
            'c': 'cpp',
            'go': 'go',
            'rb': 'ruby',
            'php': 'php'
        };

        return languageMap[extension] || '';
    }

    async handleSubmit(event) {
        event.preventDefault();

        const submissionData = {
            projectId: parseInt(document.getElementById('review-project').value),
            submitterName: document.getElementById('review-submitter-name').value,
            submitterEmail: document.getElementById('review-submitter-email').value,
            filePath: document.getElementById('review-file-path').value,
            commitHash: document.getElementById('review-commit-hash').value,
            programmingLanguage: document.getElementById('review-language').value,
            priority: document.getElementById('review-priority').value,
            codeContent: document.getElementById('review-code-content').value
        };

        // Validation
        if (!this.validateSubmission(submissionData)) {
            return;
        }

        try {
            console.log('CodeReviewSubmissionManager: Submitting code review...', submissionData);
            showLoading();

            const response = await submissionApi.create(submissionData);
            console.log('CodeReviewSubmissionManager: Submission successful', response);

            showSuccess('Code review submitted successfully! Review ID: ' + (response?.reviewId || 'N/A'));

            // Reset form
            this.resetForm();

            // Switch to reviews tab to show the submission
            setTimeout(() => {
                switchTab('reviews');
            }, 2000);

        } catch (error) {
            console.error('CodeReviewSubmissionManager: Submission failed:', error);
            let errorMessage = 'Failed to submit code review. Please try again.';

            // Try to get more specific error message
            if (error.message) {
                errorMessage = `Submission failed: ${error.message}`;
            }

            showError(errorMessage);
        } finally {
            hideLoading();
        }
    }

    validateSubmission(data) {
        if (!data.projectId) {
            showError('Please select a project');
            return false;
        }

        if (!data.submitterEmail || !this.isValidEmail(data.submitterEmail)) {
            showError('Please enter a valid email address');
            return false;
        }

        if (!data.commitHash || data.commitHash.trim().length < 6) {
            showError('Please enter a valid commit hash (at least 6 characters)');
            return false;
        }

        if (!data.codeContent || data.codeContent.trim().length < 10) {
            showError('Please enter the code content (at least 10 characters)');
            return false;
        }

        return true;
    }

    isValidEmail(email) {
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        return emailRegex.test(email);
    }

    resetForm() {
        const form = document.getElementById('code-review-form');
        if (form) {
            form.reset();
            document.getElementById('review-priority').value = 'MEDIUM';
            this.updateCodeStats();
        }
    }

    loadSampleCode() {
        const sampleCode = `public class UserService {

    private final UserRepository userRepository;
    private final EmailService emailService;

    public UserService(UserRepository userRepository, EmailService emailService) {
        this.userRepository = userRepository;
        this.emailService = emailService;
    }

    public User createUser(CreateUserRequest request) {
        // Validate input
        if (request.getEmail() == null || request.getEmail().isEmpty()) {
            throw new IllegalArgumentException("Email is required");
        }

        // Check if user already exists
        if (userRepository.findByEmail(request.getEmail()).isPresent()) {
            throw new UserAlreadyExistsException("User with email already exists");
        }

        // Create new user
        User user = new User();
        user.setEmail(request.getEmail());
        user.setName(request.getName());
        user.setCreatedDate(LocalDateTime.now());

        User savedUser = userRepository.save(user);

        // Send welcome email
        emailService.sendWelcomeEmail(savedUser.getEmail());

        return savedUser;
    }
}`;

        const textarea = document.getElementById('review-code-content');
        if (textarea) {
            textarea.value = sampleCode;
            this.updateCodeStats();
        }

        // Set some sample values
        document.getElementById('review-file-path').value = 'src/main/java/com/example/UserService.java';
        document.getElementById('review-language').value = 'java';
        document.getElementById('review-commit-hash').value = 'a1b2c3d4e5f6789';

        showSuccess('Sample code loaded');
    }

    formatCodeContent() {
        const textarea = document.getElementById('review-code-content');
        if (textarea && textarea.value) {
            // Simple formatting - normalize line endings and trim
            const formatted = textarea.value
                .replace(/\r\n/g, '\n')
                .replace(/\t/g, '    ')
                .split('\n')
                .map(line => line.trimEnd())
                .join('\n')
                .trim();

            textarea.value = formatted;
            this.updateCodeStats();
            showSuccess('Code formatted');
        }
    }

    clearCodeContent() {
        const textarea = document.getElementById('review-code-content');
        if (textarea) {
            textarea.value = '';
            this.updateCodeStats();
        }
    }

    previewSubmission() {
        const data = {
            project: document.getElementById('review-project').selectedOptions[0]?.textContent || 'Not selected',
            submitterName: document.getElementById('review-submitter-name').value || 'Not provided',
            submitterEmail: document.getElementById('review-submitter-email').value,
            filePath: document.getElementById('review-file-path').value || 'Not provided',
            commitHash: document.getElementById('review-commit-hash').value,
            language: document.getElementById('review-language').value || 'Auto-detect',
            priority: document.getElementById('review-priority').value,
            codeLines: document.getElementById('review-code-content').value.split('\n').length,
            codeChars: document.getElementById('review-code-content').value.length
        };

        const previewHtml = `
            <div class="review-preview">
                <h3>üìã Submission Preview</h3>
                <div class="preview-section">
                    <strong>Project:</strong> ${data.project}<br>
                    <strong>Submitter:</strong> ${data.submitterName} (${data.submitterEmail})<br>
                    <strong>File:</strong> ${data.filePath}<br>
                    <strong>Commit:</strong> ${data.commitHash}<br>
                    <strong>Language:</strong> ${data.language}<br>
                    <strong>Priority:</strong> ${data.priority}<br>
                    <strong>Code:</strong> ${data.codeLines} lines, ${data.codeChars} characters
                </div>
            </div>
        `;

        // Show in a temporary modal or alert
        showInfo(previewHtml, 'Submission Preview');
    }
}

window.codeReviewSubmissionManager = new CodeReviewSubmissionManager();

// Global functions
window.formatCodeContent = function() {
    window.codeReviewSubmissionManager.formatCodeContent();
};

window.clearCodeContent = function() {
    window.codeReviewSubmissionManager.clearCodeContent();
};

window.loadSampleCode = function() {
    window.codeReviewSubmissionManager.loadSampleCode();
};

window.handleFileUpload = function(event) {
    window.codeReviewSubmissionManager.handleFileUpload(event);
};

window.updateCodeStats = function() {
    window.codeReviewSubmissionManager.updateCodeStats();
};

window.resetCodeReviewForm = function() {
    window.codeReviewSubmissionManager.resetForm();
};

window.previewSubmission = function() {
    window.codeReviewSubmissionManager.previewSubmission();
};

// Debug function to manually load projects
window.debugLoadProjects = function() {
    console.log('Manual debug: Loading projects...');
    if (window.codeReviewSubmissionManager) {
        window.codeReviewSubmissionManager.loadProjects();
    } else {
        console.error('Code Review submission manager not available');
    }
};

// Debug function to check manager state
window.debugCheckManager = function() {
    console.log('Code Review Manager State:');
    console.log('- Manager exists:', !!window.codeReviewSubmissionManager);
    console.log('- Initialized:', window.codeReviewSubmissionManager?.initialized);
    console.log('- Projects count:', window.codeReviewSubmissionManager?.projects?.length || 0);
    console.log('- Projects:', window.codeReviewSubmissionManager?.projects);

    const selector = document.getElementById('review-project');
    console.log('- Selector exists:', !!selector);
    console.log('- Selector options count:', selector?.options?.length || 0);
};

// Debug function to test submission API
window.debugTestSubmission = async function() {
    const testData = {
        projectId: 6,
        submitterName: 'Debug User',
        submitterEmail: 'debug@test.com',
        filePath: 'src/test/DebugTest.java',
        commitHash: 'debug123456',
        programmingLanguage: 'java',
        priority: 'MEDIUM',
        codeContent: 'public class DebugTest { public void test() { System.out.println("Debug test"); } }'
    };

    try {
        console.log('Testing submission API with data:', testData);
        const response = await submissionApi.create(testData);
        console.log('‚úÖ Debug submission successful:', response);
        alert('Debug submission successful! Check console for details.');
    } catch (error) {
        console.error('‚ùå Debug submission failed:', error);
        alert(`Debug submission failed: ${error.message}`);
    }
};

document.addEventListener('DOMContentLoaded', () => {
    if (document.getElementById('code-review-tab')) {
        console.log('DOM loaded - initializing Code Review manager');
        window.codeReviewSubmissionManager.init();
    }
});

// Also initialize when the window loads (backup)
window.addEventListener('load', () => {
    if (document.getElementById('code-review-tab') && !window.codeReviewSubmissionManager.initialized) {
        console.log('Window loaded - backup initialization of Code Review manager');
        window.codeReviewSubmissionManager.init();
    }
});

// Periodic check to ensure projects are loaded when Code Review tab is active
setInterval(() => {
    const codeReviewTab = document.getElementById('code-review-tab');
    const isTabActive = codeReviewTab && codeReviewTab.classList.contains('active');

    if (isTabActive && window.codeReviewSubmissionManager) {
        const selector = document.getElementById('review-project');
        const hasProjects = window.codeReviewSubmissionManager.projects && window.codeReviewSubmissionManager.projects.length > 0;
        const selectorEmpty = selector && selector.options.length <= 1;

        // If tab is active, manager exists, we have projects but selector is empty, repopulate
        if (hasProjects && selectorEmpty) {
            console.log('Periodic check: Repopulating empty project selector');
            window.codeReviewSubmissionManager.populateProjectSelector();
        }
        // If tab is active, manager exists, but no projects loaded, try to load them
        else if (!hasProjects && window.codeReviewSubmissionManager.initialized) {
            console.log('Periodic check: Loading missing projects');
            window.codeReviewSubmissionManager.loadProjects();
        }
        // If tab is active but manager not initialized, initialize it
        else if (!window.codeReviewSubmissionManager.initialized) {
            console.log('Periodic check: Initializing Code Review manager');
            window.codeReviewSubmissionManager.init();
        }
    }
}, 2000); // Check every 2 seconds



-------------------------------------
config.js
/**
 * Configuration file for the Code Review Manager
 * Contains API endpoints and other configuration settings
 */

// API Configuration
const API_CONFIG = {
    BASE_URL: 'http://localhost:8081/api',
    ENDPOINTS: {
        // Category endpoints
        CATEGORIES: '/categories',
        CATEGORIES_SEARCH: '/categories/search',

        // Prompt endpoints
        PROMPTS: '/prompts',
        PROMPTS_ALL: '/prompts/all',
        PROMPTS_SEARCH: '/prompts/search',
        PROMPTS_BY_CATEGORY: '/prompts/category',
        PROMPTS_STATS: '/prompts/stats',

        // Team endpoints
        TEAMS: '/teams',
        TEAMS_SEARCH: '/teams/search',
        TEAMS_STATS: '/teams/stats',

        // Project endpoints
        PROJECTS: '/projects',
        PROJECTS_SEARCH: '/projects/search',
        PROJECTS_STATS: '/projects/stats',
        PROJECTS_BY_TEAM: '/projects/team',

        // Code Review Submission endpoints
        SUBMISSIONS: '/submissions',
        SUBMISSIONS_SEARCH: '/submissions/search',
        SUBMISSIONS_STATS: '/submissions/stats',
        SUBMISSIONS_BY_PROJECT: '/submissions/project',
        SUBMISSIONS_BY_TEAM: '/submissions/team',

        // AI Review endpoints
        AI_REVIEW_EXECUTE: '/ai-review/execute',
        AI_REVIEW_TEST: '/ai-review/test-prompt',
        AI_REVIEW_STATUS: '/ai-review/status',

        // Project Analysis endpoints
        PROJECT_ANALYZE: '/project-analysis/analyze',
        PROJECT_README: '/project-analysis/generate-readme',
        PROJECT_REVIEW: '/project-analysis/review-project'
    }
};

// UI Configuration
const UI_CONFIG = {
    DEBOUNCE_DELAY: 300, // milliseconds
    ANIMATION_DURATION: 200, // milliseconds
    MAX_ITEMS_PER_PAGE: 50
};

// Message Configuration
const MESSAGES = {
    LOADING: 'Loading...',
    NO_DATA: 'No data available',
    NO_PROMPTS: 'No prompts found',
    NO_CATEGORIES: 'No categories found',
    DELETE_CONFIRM: 'Are you sure you want to delete this item?',
    DELETE_SUCCESS: 'Item deleted successfully',
    SAVE_SUCCESS: 'Item saved successfully',
    ERROR_GENERIC: 'An error occurred. Please try again.',
    ERROR_NETWORK: 'Network error. Please check your connection.',
    ERROR_SERVER: 'Server error. Please try again later.'
};

// Export configuration objects to global scope
window.API_CONFIG = API_CONFIG;
window.UI_CONFIG = UI_CONFIG;
window.MESSAGES = MESSAGES;

--------------------------------------

dashboard.js


/**
 * Dashboard Management
 * Handles dashboard statistics, activity feed, and quick actions
 */

class DashboardManager {
    constructor() {
        this.refreshInterval = 30000; // 30 seconds
        this.intervalId = null;
    }

    /**
     * Initialize dashboard
     */
    init() {
        this.setupEventListeners();
        this.loadDashboardData();
        this.checkSystemStatus();
        this.startAutoRefresh();
    }

    /**
     * Set up event listeners
     */
    setupEventListeners() {
        // Quick action buttons
        document.querySelectorAll('[data-action]').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const action = e.currentTarget.getAttribute('data-action');
                this.handleQuickAction(action);
            });
        });
    }

    /**
     * Load dashboard data
     */
    async loadDashboardData() {
        try {
            showLoading();

            // Load all statistics in parallel
        // Fetch data with fallbacks for unavailable endpoints
        const teamsData = await this.fetchTeamsStats().catch(() => ({ count: 0 }));
        const projectsData = await this.fetchProjectsStats().catch(() => ({ count: 0 }));
        const reviewsData = await this.fetchReviewsStats().catch(() => ({ count: 0 }));
        const promptsData = await this.fetchPromptsStats().catch(() => ({ count: 0 }));

        // Update stats cards
        this.updateStatsCards({
            teams: teamsData.count || teamsData.activePromptCount || 0,
            projects: projectsData.count || projectsData.activePromptCount || 0,
            reviews: reviewsData.count || reviewsData.activePromptCount || 0,
            prompts: promptsData.count || promptsData.activePromptCount || 0
        });

            // Load recent activity
            await this.loadRecentActivity();

        } catch (error) {
            console.error('Failed to load dashboard data:', error);
            showError('Failed to load dashboard data');
        } finally {
            hideLoading();
        }
    }

    /**
     * Fetch teams statistics
     */
    async fetchTeamsStats() {
        try {
            const teams = await teamApi.getAll();
            return { count: teams.length || 0 };
        } catch (error) {
            console.warn('Teams stats not available:', error);
            return { count: 0 };
        }
    }

    /**
     * Fetch projects statistics
     */
    async fetchProjectsStats() {
        try {
            const projects = await projectApi.getAll();
            return { count: projects.length || 0 };
        } catch (error) {
            console.warn('Projects stats not available:', error);
            return { count: 0 };
        }
    }

    /**
     * Fetch reviews statistics
     */
    async fetchReviewsStats() {
        try {
            const submissions = await submissionApi.getAll();
            return { count: submissions.length || 0 };
        } catch (error) {
            console.warn('Reviews stats not available:', error);
            return { count: 0 };
        }
    }

    /**
     * Fetch prompts statistics
     */
    async fetchPromptsStats() {
        try {
            // For now, return 0 since prompts API is not implemented
            // TODO: Implement prompts API
            return { count: 0 };
        } catch (error) {
            console.warn('Prompts stats not available:', error);
            return { count: 0 };
        }
    }

    /**
     * Update statistics cards
     */
    updateStatsCards(stats) {
        const elements = {
            teams: document.getElementById('teams-count'),
            projects: document.getElementById('projects-count'),
            reviews: document.getElementById('reviews-count'),
            prompts: document.getElementById('prompts-count')
        };

        Object.keys(stats).forEach(key => {
            if (elements[key]) {
                this.animateNumber(elements[key], parseInt(elements[key].textContent) || 0, stats[key]);
            }
        });
    }

    /**
     * Animate number change
     */
    animateNumber(element, from, to) {
        const duration = 1000;
        const startTime = Date.now();

        const animate = () => {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(elapsed / duration, 1);

            // Use easing function for smooth animation
            const eased = 1 - Math.pow(1 - progress, 3);
            const current = Math.round(from + (to - from) * eased);

            element.textContent = current;

            if (progress < 1) {
                requestAnimationFrame(animate);
            }
        };

        animate();
    }

    /**
     * Load recent activity
     */
    async loadRecentActivity() {
        try {
            const activities = await this.fetchRecentActivities();
            this.updateActivityFeed(activities);
        } catch (error) {
            console.error('Failed to load recent activity:', error);
        }
    }

    /**
     * Fetch recent activities
     */
    async fetchRecentActivities() {
        try {
            console.log('DashboardManager: Fetching recent activities...');
            const activities = [];

            // Fetch recent submissions (code reviews)
            try {
                const submissions = await submissionApi.getAll();
                console.log('DashboardManager: Found', submissions.length, 'submissions');

                // Get the 3 most recent submissions
                const recentSubmissions = submissions
                    .sort((a, b) => new Date(b.submittedDate || b.createdDate) - new Date(a.submittedDate || a.createdDate))
                    .slice(0, 3);

                recentSubmissions.forEach(submission => {
                    const statusIcons = {
                        'PENDING': '‚è≥',
                        'IN_PROGRESS': 'üîÑ',
                        'COMPLETED': '‚úÖ',
                        'FAILED': '‚ùå',
                        'CANCELLED': '‚ö™'
                    };

                    activities.push({
                        icon: statusIcons[submission.reviewStatus] || 'üîç',
                        title: 'Code Review',
                        description: `${submission.submitterName || 'User'} submitted ${submission.filePath || 'code'} for review`,
                        timestamp: new Date(submission.submittedDate || submission.createdDate),
                        type: 'submission',
                        status: submission.reviewStatus
                    });
                });
            } catch (error) {
                console.warn('Could not fetch recent submissions:', error);
            }

            // Fetch recent projects
            try {
                const projects = await projectApi.getAll();
                console.log('DashboardManager: Found', projects.length, 'projects');

                // Get the 2 most recent projects
                const recentProjects = projects
                    .sort((a, b) => new Date(b.createdDate) - new Date(a.createdDate))
                    .slice(0, 2);

                recentProjects.forEach(project => {
                    activities.push({
                        icon: 'üìÇ',
                        title: 'Project Created',
                        description: `${project.name} was added to the system`,
                        timestamp: new Date(project.createdDate),
                        type: 'project'
                    });
                });
            } catch (error) {
                console.warn('Could not fetch recent projects:', error);
            }

            // Fetch recent teams
            try {
                const teams = await teamApi.getAll();
                console.log('DashboardManager: Found', teams.length, 'teams');

                // Get the most recent team
                const recentTeam = teams
                    .sort((a, b) => new Date(b.createdDate) - new Date(a.createdDate))
                    .slice(0, 1);

                recentTeam.forEach(team => {
                    activities.push({
                        icon: 'üë•',
                        title: 'Team Created',
                        description: `${team.name} team was established`,
                        timestamp: new Date(team.createdDate),
                        type: 'team'
                    });
                });
            } catch (error) {
                console.warn('Could not fetch recent teams:', error);
            }

            // Sort all activities by timestamp (most recent first)
            const sortedActivities = activities
                .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp))
                .slice(0, 5); // Show only top 5 activities

            console.log('DashboardManager: Returning', sortedActivities.length, 'recent activities');
            return sortedActivities;

        } catch (error) {
            console.warn('Activity feed not available:', error);
            return [];
        }
    }

    /**
     * Update activity feed
     */
    updateActivityFeed(activities) {
        const activityList = document.getElementById('recent-activity');
        if (!activityList) return;

        if (!activities || activities.length === 0) {
            activityList.innerHTML = `
                <div class="empty-activity-state">
                    <div class="empty-icon">üìã</div>
                    <p>No recent activity</p>
                    <small>Activity will appear here as you use the system</small>
                </div>
            `;
            return;
        }

        activityList.innerHTML = activities.map(activity => `
            <div class="activity-item" style="animation: slideIn 0.5s ease-out;">
                <div class="activity-icon">${activity.icon}</div>
                <div class="activity-content">
                    <span class="activity-title">${activity.title}</span>
                    <span class="activity-time">${this.formatTimeAgo(activity.timestamp)} - ${activity.description}</span>
                </div>
            </div>
        `).join('');
    }

    /**
     * Format time ago
     */
    formatTimeAgo(timestamp) {
        const now = new Date();
        const time = new Date(timestamp);
        const diff = now - time;

        const minutes = Math.floor(diff / 60000);
        const hours = Math.floor(minutes / 60);
        const days = Math.floor(hours / 24);

        if (days > 0) return `${days} day${days > 1 ? 's' : ''} ago`;
        if (hours > 0) return `${hours} hour${hours > 1 ? 's' : ''} ago`;
        if (minutes > 0) return `${minutes} minute${minutes > 1 ? 's' : ''} ago`;
        return 'Just now';
    }

    /**
     * Check system status
     */
    async checkSystemStatus() {
        // Check API status by testing a known endpoint
        try {
            await teamApi.getAll();
            this.updateStatus('api-status', 'Connected', 'online');
        } catch (error) {
            this.updateStatus('api-status', 'Disconnected', 'offline');
        }

        // For now, mark AI as unavailable since it's not implemented
        // TODO: Implement AI service status check
        const aiStatusElement = document.getElementById('ai-status-text');
        const aiStatusDot = document.getElementById('ai-status-dot');
        if (aiStatusElement) {
            this.updateStatus('ai-status-text', 'Not configured', 'offline');
        }
        if (aiStatusDot) {
            aiStatusDot.className = 'status-dot offline';
        }
    }

    /**
     * Update status indicator
     */
    updateStatus(elementId, text, status) {
        const element = document.getElementById(elementId);
        if (element) {
            element.textContent = text;
            element.className = `status-value ${status}`;
        }
    }

    /**
     * Handle quick actions
     */
    handleQuickAction(action) {
        console.log(`DashboardManager: Handling quick action: ${action}`);

        switch (action) {
            case 'new-team':
                console.log('Quick Action: Creating new team');
                if (typeof showTeamForm === 'function') {
                    showTeamForm();
                } else {
                    switchTab('teams');
                    // Try to trigger the team form after switching
                    setTimeout(() => {
                        const addTeamBtn = document.querySelector('[onclick*="showTeamForm"]');
                        if (addTeamBtn) addTeamBtn.click();
                    }, 300);
                }
                break;

            case 'new-project':
                console.log('Quick Action: Creating new project');
                if (typeof showProjectForm === 'function') {
                    showProjectForm();
                } else {
                    switchTab('projects');
                    // Try to trigger the project form after switching
                    setTimeout(() => {
                        const addProjectBtn = document.querySelector('[onclick*="showProjectForm"]');
                        if (addProjectBtn) addProjectBtn.click();
                    }, 300);
                }
                break;

            case 'submit-review':
                console.log('Quick Action: Submitting code review');
                switchTab('code-review');
                // Show success message to confirm the action worked
                setTimeout(() => {
                    showSuccess('Switched to Code Review tab - Submit your code for review!');
                }, 300);
                break;

            case 'add-prompt':
                console.log('Quick Action: Adding new prompt');
                if (typeof showPromptForm === 'function') {
                    showPromptForm();
                } else {
                    switchTab('prompts');
                    // Try to trigger the prompt form after switching
                    setTimeout(() => {
                        const addPromptBtn = document.querySelector('[onclick*="showPromptForm"]');
                        if (addPromptBtn) {
                            addPromptBtn.click();
                        } else {
                            showSuccess('Switched to Prompts tab - Click "Add New Prompt" to create a prompt!');
                        }
                    }, 300);
                }
                break;

            default:
                console.warn(`Unknown quick action: ${action}`);
                showError(`Unknown action: ${action}`);
        }
    }

    /**
     * Start auto-refresh
     */
    startAutoRefresh() {
        this.intervalId = setInterval(() => {
            this.loadDashboardData();
            this.checkSystemStatus();
        }, this.refreshInterval);
    }

    /**
     * Stop auto-refresh
     */
    stopAutoRefresh() {
        if (this.intervalId) {
            clearInterval(this.intervalId);
            this.intervalId = null;
        }
    }

    /**
     * Refresh dashboard manually
     */
    async refresh() {
        await this.loadDashboardData();
        await this.checkSystemStatus();
        showSuccess('Dashboard refreshed');
    }

    /**
     * Cleanup
     */
    cleanup() {
        this.stopAutoRefresh();
    }
}

// Global dashboard manager instance
window.dashboardManager = new DashboardManager();

/**
 * Initialize dashboard manually (for debugging)
 */
function initializeDashboard() {
    console.log('Dashboard: Manual initialization triggered');
    if (window.dashboardManager && document.getElementById('dashboard-tab')) {
        window.dashboardManager.init();
        console.log('Dashboard: Initialized successfully');
    } else {
        console.error('Dashboard: Cannot initialize - missing manager or DOM element');
    }
}

/**
 * Test quick actions (for debugging)
 */
function testQuickActions() {
    console.log('Testing quick actions...');
    const actions = ['new-team', 'new-project', 'submit-review', 'add-prompt'];

    actions.forEach(action => {
        console.log(`Testing action: ${action}`);
        if (window.dashboardManager) {
            window.dashboardManager.handleQuickAction(action);
        }
    });
}

// Initialize when DOM is ready
document.addEventListener('DOMContentLoaded', () => {
    console.log('Dashboard: DOM loaded, checking for dashboard tab');

    if (document.getElementById('dashboard-tab')) {
        console.log('Dashboard: Tab found, initializing manager');
        window.dashboardManager.init();

        // Add click event listeners to action buttons for debugging
        const actionButtons = document.querySelectorAll('[data-action]');
        console.log(`Dashboard: Found ${actionButtons.length} action buttons`);

        actionButtons.forEach((btn, index) => {
            const action = btn.getAttribute('data-action');
            console.log(`Dashboard: Button ${index + 1}: ${action}`);

            // Add additional click handler for debugging
            btn.addEventListener('click', (e) => {
                console.log('Dashboard: Direct click handler triggered for:', action);
                e.preventDefault();
                e.stopPropagation();

                if (window.dashboardManager) {
                    window.dashboardManager.handleQuickAction(action);
                } else {
                    console.error('Dashboard: Manager not available');
                }
            });
        });
    } else {
        console.log('Dashboard: Tab not found, skipping initialization');
    }
});

// Export debug functions
window.initializeDashboard = initializeDashboard;
window.testQuickActions = testQuickActions;

// Cleanup on page unload
window.addEventListener('beforeunload', () => {
    if (window.dashboardManager) {
        window.dashboardManager.cleanup();
    }
});
------------------------------------------------------------------------

enhanced-prompts.js

/**
 * Enhanced Prompts Functionality
 * Professional prompts management with advanced features
 */

// Global variables for prompts management
let currentView = 'grid';
let selectedPrompts = new Set();
let filteredPrompts = [];
let allPrompts = [];

// Initialize enhanced prompts functionality
function initializeEnhancedPrompts() {
    loadPromptsStats();
    loadEnhancedPrompts();
    setupPromptEventListeners();
}

// Setup event listeners for enhanced features
function setupPromptEventListeners() {
    // Search functionality with debouncing
    const searchInput = document.getElementById('prompt-search');
    if (searchInput) {
        let searchTimeout;
        searchInput.addEventListener('input', (e) => {
            clearTimeout(searchTimeout);
            searchTimeout = setTimeout(() => {
                filterPrompts();
            }, 300);
        });
    }

    // Filter functionality
    const categoryFilter = document.getElementById('category-filter');
    const statusFilter = document.getElementById('status-filter');

    if (categoryFilter) {
        categoryFilter.addEventListener('change', filterPrompts);
    }
    if (statusFilter) {
        statusFilter.addEventListener('change', filterPrompts);
    }
}

// Load prompts statistics
function loadPromptsStats() {
    // This would typically call your existing API
    // For now, we'll simulate the data
    setTimeout(() => {
        updatePromptsStats({
            total: 12,
            active: 8,
            categories: 4
        });
    }, 500);
}

// Update prompts statistics display
function updatePromptsStats(stats) {
    const totalElement = document.getElementById('total-prompts');
    const activeElement = document.getElementById('active-prompts');
    const categoriesElement = document.getElementById('total-categories');

    if (totalElement) totalElement.textContent = stats.total;
    if (activeElement) activeElement.textContent = stats.active;
    if (categoriesElement) categoriesElement.textContent = stats.categories;

    // Animate the numbers
    animateStatNumbers();
}

// Animate statistics numbers
function animateStatNumbers() {
    const statNumbers = document.querySelectorAll('.stat-number');
    statNumbers.forEach(statNumber => {
        const finalNumber = parseInt(statNumber.textContent);
        const duration = 1000;
        const steps = 20;
        const increment = finalNumber / steps;
        let current = 0;
        let step = 0;

        const timer = setInterval(() => {
            current += increment;
            statNumber.textContent = Math.round(current);
            step++;

            if (step >= steps) {
                clearInterval(timer);
                statNumber.textContent = finalNumber;
            }
        }, duration / steps);
    });
}

// Load enhanced prompts with sample data
function loadEnhancedPrompts() {
    // Sample prompts data - this would come from your API
    const samplePrompts = [
        {
            id: 1,
            title: "Code Quality Review",
            description: "Comprehensive code quality assessment focusing on maintainability and best practices",
            category: "Quality Assurance",
            content: `Review this code for:
- Code clarity and readability
- Performance optimizations
- Security vulnerabilities
- Best practice adherence
- Potential bugs or edge cases`,
            isActive: true,
            createdDate: "2024-01-15",
            lastModified: "2024-01-20"
        },
        {
            id: 2,
            title: "Security Vulnerability Check",
            description: "Security-focused review to identify potential vulnerabilities and threats",
            category: "Security",
            content: `Analyze for security issues:
- SQL injection vulnerabilities
- XSS attack vectors
- Authentication bypasses
- Data validation issues
- Encryption concerns`,
            isActive: true,
            createdDate: "2024-01-10",
            lastModified: "2024-01-18"
        },
        {
            id: 3,
            title: "Performance Optimization",
            description: "Performance-focused review to identify bottlenecks and optimization opportunities",
            category: "Performance",
            content: `Evaluate performance aspects:
- Database query efficiency
- Memory usage patterns
- Algorithmic complexity
- Caching opportunities
- Resource utilization`,
            isActive: false,
            createdDate: "2024-01-05",
            lastModified: "2024-01-12"
        },
        {
            id: 4,
            title: "API Design Review",
            description: "RESTful API design and implementation review",
            category: "Architecture",
            content: `Review API design for:
- RESTful principles adherence
- HTTP status code usage
- Request/response structure
- Error handling patterns
- Documentation quality`,
            isActive: true,
            createdDate: "2024-01-08",
            lastModified: "2024-01-16"
        }
    ];

    allPrompts = samplePrompts;
    filteredPrompts = [...allPrompts];
    displayPrompts(filteredPrompts);
    updatePromptsStats({
        total: allPrompts.length,
        active: allPrompts.filter(p => p.isActive).length,
        categories: [...new Set(allPrompts.map(p => p.category))].length
    });
}

// Display prompts in the current view
function displayPrompts(prompts) {
    const promptsList = document.getElementById('prompts-list');
    const noPromptsState = document.getElementById('no-prompts-state');

    if (!promptsList) return;

    if (prompts.length === 0) {
        promptsList.style.display = 'none';
        if (noPromptsState) noPromptsState.style.display = 'block';
        return;
    }

    if (noPromptsState) noPromptsState.style.display = 'none';
    promptsList.style.display = currentView === 'grid' ? 'grid' : 'flex';

    promptsList.innerHTML = prompts.map(prompt => createPromptCard(prompt)).join('');
    updateSelectedCount();
}

// Create a prompt card HTML
function createPromptCard(prompt) {
    const isSelected = selectedPrompts.has(prompt.id);
    const statusClass = prompt.isActive ? 'active' : 'inactive';
    const statusIcon = prompt.isActive ? '‚úÖ' : '‚ùå';
    const statusText = prompt.isActive ? 'Active' : 'Inactive';

    return `
        <div class="prompt-card ${isSelected ? 'selected' : ''}" data-prompt-id="${prompt.id}">
            <div class="prompt-card-header">
                <div class="checkbox-container">
                    <input type="checkbox"
                           ${isSelected ? 'checked' : ''}
                           onchange="togglePromptSelection(${prompt.id})"
                           class="prompt-checkbox">
                </div>
                <h3 class="prompt-title">
                    üìù ${prompt.title}
                </h3>
                <span class="prompt-category">${prompt.category}</span>
                <p class="prompt-description">${prompt.description}</p>
                <div class="prompt-meta">
                    <span class="prompt-date">Modified: ${formatDate(prompt.lastModified)}</span>
                    <span class="prompt-status ${statusClass}">
                        ${statusIcon} ${statusText}
                    </span>
                </div>
            </div>

            ${currentView === 'grid' ? `
            <div class="prompt-card-content">
                <div class="prompt-content-preview">${truncateContent(prompt.content, 200)}</div>
            </div>
            ` : ''}

            <div class="prompt-card-actions">
                <div class="prompt-actions-left">
                    <button class="prompt-action-btn primary" onclick="editPrompt(${prompt.id})" title="Edit Prompt">
                        <span>‚úèÔ∏è</span> Edit
                    </button>
                    <button class="prompt-action-btn secondary" onclick="duplicatePrompt(${prompt.id})" title="Duplicate Prompt">
                        <span>üìã</span> Duplicate
                    </button>
                </div>
                <div class="prompt-actions-right">
                    <button class="prompt-action-btn ${prompt.isActive ? 'secondary' : 'success'}"
                            onclick="togglePromptStatus(${prompt.id})"
                            title="${prompt.isActive ? 'Deactivate' : 'Activate'} Prompt">
                        <span>${prompt.isActive ? '‚è∏Ô∏è' : '‚ñ∂Ô∏è'}</span>
                    </button>
                    <button class="prompt-action-btn danger" onclick="deletePrompt(${prompt.id})" title="Delete Prompt">
                        <span>üóëÔ∏è</span>
                    </button>
                </div>
            </div>
        </div>
    `;
}

// Format date for display
function formatDate(dateString) {
    const date = new Date(dateString);
    return date.toLocaleDateString('en-US', {
        year: 'numeric',
        month: 'short',
        day: 'numeric'
    });
}

// Truncate content for preview
function truncateContent(content, maxLength) {
    if (content.length <= maxLength) return content;
    return content.substring(0, maxLength) + '...';
}

// Change view between grid and list
function changeView(viewType) {
    currentView = viewType;

    // Update view buttons
    document.querySelectorAll('.view-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.view === viewType);
    });

    // Update display
    const promptsList = document.getElementById('prompts-list');
    if (promptsList) {
        promptsList.className = `prompts-display ${viewType}-view`;
    }

    displayPrompts(filteredPrompts);
}

// Filter prompts based on search and filters
function filterPrompts() {
    const searchTerm = document.getElementById('prompt-search')?.value.toLowerCase() || '';
    const categoryFilter = document.getElementById('category-filter')?.value || '';
    const statusFilter = document.getElementById('status-filter')?.value || '';

    filteredPrompts = allPrompts.filter(prompt => {
        // Text search
        const matchesSearch = !searchTerm ||
            prompt.title.toLowerCase().includes(searchTerm) ||
            prompt.description.toLowerCase().includes(searchTerm) ||
            prompt.content.toLowerCase().includes(searchTerm) ||
            prompt.category.toLowerCase().includes(searchTerm);

        // Category filter
        const matchesCategory = !categoryFilter || prompt.category === categoryFilter;

        // Status filter
        const matchesStatus = !statusFilter ||
            (statusFilter === 'active' && prompt.isActive) ||
            (statusFilter === 'inactive' && !prompt.isActive);

        return matchesSearch && matchesCategory && matchesStatus;
    });

    displayPrompts(filteredPrompts);
}

// Clear search
function clearSearch() {
    const searchInput = document.getElementById('prompt-search');
    if (searchInput) {
        searchInput.value = '';
        filterPrompts();
    }
}

// Toggle prompt selection
function togglePromptSelection(promptId) {
    if (selectedPrompts.has(promptId)) {
        selectedPrompts.delete(promptId);
    } else {
        selectedPrompts.add(promptId);
    }

    updateSelectedCount();
    updateQuickActionsVisibility();
    updatePromptCardSelection(promptId);
}

// Update selected count display
function updateSelectedCount() {
    const selectedCount = document.getElementById('selected-count');
    if (selectedCount) {
        selectedCount.textContent = `${selectedPrompts.size} selected`;
    }
}

// Update quick actions panel visibility
function updateQuickActionsVisibility() {
    const quickActions = document.getElementById('quick-actions');
    if (quickActions) {
        quickActions.style.display = selectedPrompts.size > 0 ? 'flex' : 'none';
    }
}

// Update prompt card selection styling
function updatePromptCardSelection(promptId) {
    const promptCard = document.querySelector(`[data-prompt-id="${promptId}"]`);
    if (promptCard) {
        promptCard.classList.toggle('selected', selectedPrompts.has(promptId));
    }
}

// Prompt action functions
function editPrompt(promptId) {
    // This would integrate with your existing edit functionality
    console.log('Edit prompt:', promptId);
    showSuccessMessage(`Editing prompt ${promptId}...`);
}

function duplicatePrompt(promptId) {
    const prompt = allPrompts.find(p => p.id === promptId);
    if (prompt) {
        console.log('Duplicate prompt:', prompt);
        showSuccessMessage(`Prompt "${prompt.title}" duplicated successfully!`);
    }
}

function togglePromptStatus(promptId) {
    const prompt = allPrompts.find(p => p.id === promptId);
    if (prompt) {
        prompt.isActive = !prompt.isActive;
        const statusText = prompt.isActive ? 'activated' : 'deactivated';
        showSuccessMessage(`Prompt "${prompt.title}" ${statusText}!`);
        displayPrompts(filteredPrompts);
        loadPromptsStats(); // Refresh stats
    }
}

function deletePrompt(promptId) {
    const prompt = allPrompts.find(p => p.id === promptId);
    if (prompt && confirm(`Are you sure you want to delete "${prompt.title}"?`)) {
        allPrompts = allPrompts.filter(p => p.id !== promptId);
        filteredPrompts = filteredPrompts.filter(p => p.id !== promptId);
        selectedPrompts.delete(promptId);

        showSuccessMessage(`Prompt "${prompt.title}" deleted successfully!`);
        displayPrompts(filteredPrompts);
        loadPromptsStats(); // Refresh stats
        updateQuickActionsVisibility();
    }
}

// Bulk actions
function bulkActivatePrompts() {
    const count = selectedPrompts.size;
    selectedPrompts.forEach(promptId => {
        const prompt = allPrompts.find(p => p.id === promptId);
        if (prompt) prompt.isActive = true;
    });

    selectedPrompts.clear();
    displayPrompts(filteredPrompts);
    updateQuickActionsVisibility();
    loadPromptsStats();
    showSuccessMessage(`${count} prompts activated successfully!`);
}

function bulkDeactivatePrompts() {
    const count = selectedPrompts.size;
    selectedPrompts.forEach(promptId => {
        const prompt = allPrompts.find(p => p.id === promptId);
        if (prompt) prompt.isActive = false;
    });

    selectedPrompts.clear();
    displayPrompts(filteredPrompts);
    updateQuickActionsVisibility();
    loadPromptsStats();
    showSuccessMessage(`${count} prompts deactivated successfully!`);
}

function bulkDeletePrompts() {
    const count = selectedPrompts.size;
    if (confirm(`Are you sure you want to delete ${count} selected prompts?`)) {
        allPrompts = allPrompts.filter(p => !selectedPrompts.has(p.id));
        filteredPrompts = filteredPrompts.filter(p => !selectedPrompts.has(p.id));
        selectedPrompts.clear();

        displayPrompts(filteredPrompts);
        updateQuickActionsVisibility();
        loadPromptsStats();
        showSuccessMessage(`${count} prompts deleted successfully!`);
    }
}

// Utility function to show success messages
function showSuccessMessage(message) {
    const successDiv = document.getElementById('success-message');
    const textSpan = successDiv?.querySelector('.success-text');

    if (successDiv && textSpan) {
        textSpan.textContent = message;
        successDiv.classList.remove('hidden');

        setTimeout(() => {
            successDiv.classList.add('hidden');
        }, 3000);
    }
}

// Initialize when DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
    // Only initialize if we're on the prompts tab
    const promptsTab = document.getElementById('prompts-tab');
    if (promptsTab) {
        initializeEnhancedPrompts();
    }
});

// Export functions for global use
window.changeView = changeView;
window.clearSearch = clearSearch;
window.togglePromptSelection = togglePromptSelection;
window.editPrompt = editPrompt;
window.duplicatePrompt = duplicatePrompt;
window.togglePromptStatus = togglePromptStatus;
window.deletePrompt = deletePrompt;
window.bulkActivatePrompts = bulkActivatePrompts;
window.bulkDeactivatePrompts = bulkDeactivatePrompts;
window.bulkDeletePrompts = bulkDeletePrompts;

----------------------------------------------------------

enhanced-results.js

/**
 * Enhanced Result Display Functions
 * Provides enhanced display for AI Code Review and Prompt Testing results
 * with syntax highlighting and professional formatting
 */

// Enhanced result display for AI Code Review
function displayAIReviewResult(reviewResult, originalCode, language) {
    const resultContainer = document.getElementById('ai-review-result-container');
    const resultContent = document.getElementById('ai-review-result-content');
    const reviewTimestamp = document.getElementById('review-timestamp');
    const reviewModel = document.getElementById('review-model');

    if (!resultContainer || !resultContent) return;

    // Show the container
    resultContainer.classList.remove('hidden');

    // Update metadata
    if (reviewTimestamp) {
        reviewTimestamp.textContent = `Reviewed: ${new Date().toLocaleString()}`;
    }
    if (reviewModel) {
        reviewModel.textContent = 'Model: Claude 4.5 Sonnet';
    }

    // Create enhanced result display
    const enhancedContent = createEnhancedResultDisplay(
        originalCode,
        reviewResult,
        language,
        'AI Code Review Results'
    );

    resultContent.innerHTML = enhancedContent;

    // Scroll to results
    resultContainer.scrollIntoView({ behavior: 'smooth', block: 'start' });
}

// Enhanced result display for Prompt Testing
function displayPromptTestResult(testResult, originalCode, language, promptTitle) {
    const resultContainer = document.getElementById('test-result-container');
    const resultContent = document.getElementById('test-result-content');

    if (!resultContainer || !resultContent) return;

    // Show the container
    resultContainer.classList.remove('hidden');

    // Create enhanced result display
    const enhancedContent = createEnhancedResultDisplay(
        originalCode,
        testResult,
        language,
        `Prompt Test Results: ${promptTitle}`
    );

    resultContent.innerHTML = enhancedContent;

    // Scroll to results
    resultContainer.scrollIntoView({ behavior: 'smooth', block: 'start' });
}

// Create enhanced result display with syntax highlighting
function createEnhancedResultDisplay(originalCode, result, language, title) {
    const codeLines = originalCode.split('\n').length;
    const codeChars = originalCode.length;

    // Get language configuration for proper display
    const languageConfig = window.syntaxHighlighter ?
        window.syntaxHighlighter.constructor.name : null;

    return `
        <div class="enhanced-result-display">
            <!-- Theme Toggle -->
            <div class="theme-toggle-container">
                <div class="theme-toggle">
                    <button class="theme-btn active" onclick="switchResultTheme('dark')" data-theme="dark">Dark</button>
                    <button class="theme-btn" onclick="switchResultTheme('light')" data-theme="light">Light</button>
                    <button class="theme-btn" onclick="switchResultTheme('monokai')" data-theme="monokai">Monokai</button>
                </div>
            </div>

            <!-- Original Code Submission -->
            <div class="code-submission-section">
                <div class="section-header">
                    <h4>üìÑ Code Submission</h4>
                </div>
                <div class="code-submission-display">
                    <div class="code-submission-header">
                        <div class="submission-meta">
                            <div class="meta-item">
                                <span class="language-badge">${language.toUpperCase()}</span>
                            </div>
                            <div class="meta-item">
                                <span>üìè</span>
                                <span class="lines-count">${codeLines} lines</span>
                            </div>
                            <div class="meta-item">
                                <span>üî§</span>
                                <span>${codeChars} characters</span>
                            </div>
                        </div>
                    </div>
                    ${highlightCodeWithWrapper(originalCode, language, {
                        showLineNumbers: true,
                        showLanguage: true,
                        copyButton: true
                    })}
                </div>
            </div>

            <!-- Analysis Results -->
            <div class="analysis-results-section">
                <div class="section-header">
                    <h4>üîç Analysis Results</h4>
                </div>
                <div class="analysis-content">
                    ${formatAnalysisResult(result)}
                </div>
            </div>

            <!-- Action Buttons -->
            <div class="result-actions">
                <button class="action-button primary" onclick="downloadResultReport()">
                    <span>üìÑ</span> Download Report
                </button>
                <button class="action-button secondary" onclick="copyResultToClipboard()">
                    <span>üìã</span> Copy Results
                </button>
                <button class="action-button secondary" onclick="shareResult()">
                    <span>üîó</span> Share Results
                </button>
            </div>
        </div>
    `;
}

// Format analysis result with proper structure
function formatAnalysisResult(result) {
    if (typeof result === 'string') {
        // Parse markdown-like content if available
        return formatTextResult(result);
    } else if (typeof result === 'object') {
        // Handle structured result objects
        return formatStructuredResult(result);
    }

    return `<div class="result-text">${result}</div>`;
}

// Format text-based results with markdown-like parsing
function formatTextResult(text) {
    let formattedText = text;

    // Convert headers
    formattedText = formattedText.replace(/^### (.*$)/gim, '<h3 class="result-header">$1</h3>');
    formattedText = formattedText.replace(/^## (.*$)/gim, '<h2 class="result-header">$1</h2>');
    formattedText = formattedText.replace(/^# (.*$)/gim, '<h1 class="result-header">$1</h1>');

    // Convert bold text
    formattedText = formattedText.replace(/\\*\\*(.*?)\\*\\*/g, '<strong>$1</strong>');

    // Convert italic text
    formattedText = formattedText.replace(/\\*(.*?)\\*/g, '<em>$1</em>');

    // Convert code blocks
    formattedText = formattedText.replace(/```(\\w+)?\\n([\\s\\S]*?)\\n```/g, (match, lang, code) => {
        const language = lang || 'text';
        return highlightCodeWithWrapper(code.trim(), language, {
            showLineNumbers: true,
            showLanguage: true,
            copyButton: true
        });
    });

    // Convert inline code
    formattedText = formattedText.replace(/`([^`]+)`/g, '<code class="inline-code">$1</code>');

    // Convert lists
    formattedText = formattedText.replace(/^\\* (.*$)/gim, '<li>$1</li>');
    formattedText = formattedText.replace(/^\\- (.*$)/gim, '<li>$1</li>');

    // Wrap consecutive list items in ul tags
    formattedText = formattedText.replace(/((<li>.*<\\/li>\\s*)+)/g, '<ul class="result-list">$1</ul>');

    // Convert line breaks
    formattedText = formattedText.replace(/\\n\\n/g, '</p><p class="result-paragraph">');
    formattedText = formattedText.replace(/\\n/g, '<br>');

    return `<div class="formatted-result">
        <p class="result-paragraph">${formattedText}</p>
    </div>`;
}

// Format structured result objects
function formatStructuredResult(result) {
    let html = '<div class="structured-result">';

    if (result.summary) {
        html += `
            <div class="result-section">
                <h3 class="result-header">üìã Summary</h3>
                <div class="result-content">${result.summary}</div>
            </div>
        `;
    }

    if (result.issues && Array.isArray(result.issues)) {
        html += `
            <div class="result-section">
                <h3 class="result-header">‚ö†Ô∏è Issues Found</h3>
                <div class="issues-list">
                    ${result.issues.map((issue, index) => `
                        <div class="issue-item ${issue.severity || 'medium'}">
                            <div class="issue-header">
                                <span class="issue-number">${index + 1}</span>
                                <span class="issue-title">${issue.title || 'Issue'}</span>
                                <span class="issue-severity ${issue.severity || 'medium'}">${issue.severity || 'Medium'}</span>
                            </div>
                            <div class="issue-description">${issue.description}</div>
                            ${issue.suggestion ? `<div class="issue-suggestion">üí° <strong>Suggestion:</strong> ${issue.suggestion}</div>` : ''}
                        </div>
                    `).join('')}
                </div>
            </div>
        `;
    }

    if (result.recommendations) {
        html += `
            <div class="result-section">
                <h3 class="result-header">üí° Recommendations</h3>
                <div class="recommendations-list">
                    ${Array.isArray(result.recommendations)
                        ? result.recommendations.map(rec => `<div class="recommendation-item">‚úÖ ${rec}</div>`).join('')
                        : `<div class="recommendation-item">${result.recommendations}</div>`
                    }
                </div>
            </div>
        `;
    }

    html += '</div>';
    return html;
}

// Switch result theme
function switchResultTheme(theme) {
    // Update theme buttons
    document.querySelectorAll('.theme-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.theme === theme);
    });

    // Update syntax highlighter theme
    if (window.changeSyntaxTheme) {
        window.changeSyntaxTheme(theme);
    }

    // Update result containers
    document.querySelectorAll('.result-container').forEach(container => {
        container.setAttribute('data-theme', theme);
    });
}

// Download result report
function downloadResultReport() {
    const resultContent = document.querySelector('.enhanced-result-display');
    if (!resultContent) return;

    // Extract text content for download
    const textContent = extractTextFromResult(resultContent);
    const timestamp = new Date().toISOString().replace(/:/g, '-').split('.')[0];
    const filename = `code-review-report-${timestamp}.txt`;

    const blob = new Blob([textContent], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);

    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    a.click();

    URL.revokeObjectURL(url);

    showSuccessMessage(`Report downloaded as ${filename}`);
}

// Copy result to clipboard
function copyResultToClipboard() {
    const resultContent = document.querySelector('.enhanced-result-display');
    if (!resultContent) return;

    const textContent = extractTextFromResult(resultContent);

    navigator.clipboard.writeText(textContent).then(() => {
        showSuccessMessage('Results copied to clipboard!');
    }).catch(() => {
        showErrorMessage('Failed to copy results to clipboard');
    });
}

// Share result (placeholder for future implementation)
function shareResult() {
    showInfoMessage('Sharing functionality will be available in a future update');
}

// Extract text content from result display
function extractTextFromResult(container) {
    let text = 'CODE REVIEW REPORT\\n';
    text += '===================\\n\\n';

    const codeSubmission = container.querySelector('.code-submission-display');
    if (codeSubmission) {
        text += 'ORIGINAL CODE:\\n';
        text += '--------------\\n';
        const code = codeSubmission.querySelector('.syntax-code code');
        if (code) {
            text += code.textContent + '\\n\\n';
        }
    }

    const analysisResults = container.querySelector('.analysis-content');
    if (analysisResults) {
        text += 'ANALYSIS RESULTS:\\n';
        text += '----------------\\n';
        text += analysisResults.textContent + '\\n\\n';
    }

    text += `Generated on: ${new Date().toLocaleString()}\\n`;
    text += 'Generated by: Code Review Manager\\n';

    return text;
}

// Utility functions for messaging
function showSuccessMessage(message) {
    const successDiv = document.getElementById('success-message');
    const textSpan = successDiv?.querySelector('.success-text');

    if (successDiv && textSpan) {
        textSpan.textContent = message;
        successDiv.classList.remove('hidden');

        setTimeout(() => {
            successDiv.classList.add('hidden');
        }, 3000);
    }
}

function showErrorMessage(message) {
    const errorDiv = document.getElementById('error-message');
    const textSpan = errorDiv?.querySelector('.error-text');

    if (errorDiv && textSpan) {
        textSpan.textContent = message;
        errorDiv.classList.remove('hidden');

        setTimeout(() => {
            errorDiv.classList.add('hidden');
        }, 5000);
    }
}

function showInfoMessage(message) {
    showSuccessMessage(message);
}

// Enhanced integration with existing functions
function enhanceExistingResultDisplay() {
    // Override existing result display functions if they exist
    if (window.displayTestResult) {
        window.originalDisplayTestResult = window.displayTestResult;
        window.displayTestResult = function(result, code, language, prompt) {
            displayPromptTestResult(result, code, language, prompt);
        };
    }

    if (window.displayAIResult) {
        window.originalDisplayAIResult = window.displayAIResult;
        window.displayAIResult = function(result, code, language) {
            displayAIReviewResult(result, code, language);
        };
    }
}

// Initialize enhanced results when DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
    enhanceExistingResultDisplay();
});

// Export functions for global use
window.displayAIReviewResult = displayAIReviewResult;
window.displayPromptTestResult = displayPromptTestResult;
window.switchResultTheme = switchResultTheme;
window.downloadResultReport = downloadResultReport;
window.copyResultToClipboard = copyResultToClipboard;
window.shareResult = shareResult;
----------------------------------------------------------------------------------------
project-analyzer.js

/**
 * Project Analyzer Module
 * Handles project analysis, structure scanning, README generation, and comprehensive project reviews
 */

// Project Analysis API functions
const projectAnalysisApi = {
    /**
     * Analyze project structure
     */
    async analyzeStructure(projectPath) {
        const response = await fetch(`${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.PROJECT_ANALYZE}`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                projectPath: projectPath
            })
        });

        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Project analysis failed: ${response.status} - ${errorText}`);
        }

        return await response.json();
    },

    /**
     * Generate README for project
     */
    async generateReadme(projectPath, readmeType) {
        const response = await fetch(`${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.PROJECT_README}`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                projectPath: projectPath,
                readmeType: readmeType
            })
        });

        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`README generation failed: ${response.status} - ${errorText}`);
        }

        return await response.json();
    },

    /**
     * Perform comprehensive project review
     */
    async reviewProject(projectPath, promptId = null) {
        const response = await fetch(`${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.PROJECT_REVIEW}`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                projectPath: projectPath,
                promptId: promptId
            })
        });

        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Project review failed: ${response.status} - ${errorText}`);
        }

        return await response.json();
    }
};

// Main analysis function called from HTML
async function analyzeProject() {
    console.log('üìÅ Starting project analysis...');

    const pathInput = document.getElementById('project-path-input');
    const analysisType = document.getElementById('analysis-type');
    const promptSelect = document.getElementById('review-prompt-select-project');
    const analyzeBtn = document.getElementById('analyze-project-btn');
    const structureContainer = document.getElementById('project-structure-container');
    const resultContainer = document.getElementById('project-analysis-result-container');

    console.log('üîç Found UI elements:', {
        pathInput: !!pathInput,
        analysisType: !!analysisType,
        analyzeBtn: !!analyzeBtn
    });

    // Validation
    if (!pathInput.value.trim()) {
        console.warn('‚ö†Ô∏è No project path provided');
        showError('Please enter a project path');
        return;
    }

    const projectPath = pathInput.value.trim(); // JSON.stringify will handle path escaping
    const type = analysisType.value;

    console.log('üìÅ Analyzing project:', { path: projectPath, type });

    try {
        // Show loading state
        analyzeBtn.disabled = true;
        analyzeBtn.innerHTML = '<span class="spinner"></span> Analyzing...';
        structureContainer.classList.add('hidden');
        resultContainer.classList.add('hidden');

        // Determine what type of analysis to perform
        if (type === 'structure') {
            console.log('üèóÔ∏è Performing structure analysis...');
            await performStructureAnalysis(projectPath);
        } else if (type.startsWith('readme-')) {
            const readmeType = type.replace('readme-', '');
            await generateProjectReadme(projectPath, readmeType);
        } else if (type === 'full-review') {
            const promptId = promptSelect.value ? parseInt(promptSelect.value) : null;
            await performProjectReview(projectPath, promptId);
        }

    } catch (error) {
        console.error('Project analysis error:', error);
        showError(`Analysis failed: ${error.message}`);
    } finally {
        analyzeBtn.disabled = false;
        analyzeBtn.innerHTML = 'üîç Analyze Project';
    }
}

async function performStructureAnalysis(projectPath) {
    try {
        console.log('üìÅ Calling API for structure analysis:', projectPath);
        const result = await projectAnalysisApi.analyzeStructure(projectPath);
        console.log('‚úÖ API returned result:', result);

        displayProjectStructure(result);
        showSuccess('Project structure analyzed successfully!');
    } catch (error) {
        console.error('‚ùå Structure analysis failed:', error);
        throw error;
    }
}

async function generateProjectReadme(projectPath, readmeType) {
    const result = await projectAnalysisApi.generateReadme(projectPath, readmeType);
    displayAnalysisResult(result.readmeContent, result.timestamp, result.model, `README (${readmeType})`);
    showSuccess('README generated successfully!');
}

async function performProjectReview(projectPath, promptId) {
    const result = await projectAnalysisApi.reviewProject(projectPath, promptId);
    displayAnalysisResult(result.reviewContent, result.timestamp, result.model, 'Comprehensive Project Review');
    showSuccess('Project review completed successfully!');
}

function displayProjectStructure(analysis) {
    const structureContainer = document.getElementById('project-structure-container');
    const structureContent = document.getElementById('project-structure-content');

    let html = `
        <div class="project-overview">
            <h4>üìä Project Overview</h4>
            <div class="stats-grid">
                <div class="stat-item">
                    <span class="stat-label">Path:</span>
                    <span class="stat-value">${analysis.projectPath}</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Total Files:</span>
                    <span class="stat-value">${analysis.totalFiles}</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">File Types:</span>
                    <span class="stat-value">${Object.keys(analysis.fileTypes).length}</span>
                </div>
            </div>
        </div>

        <div class="file-types-section">
            <h4>üìÅ File Types Distribution</h4>
            <div class="file-types-grid">`;

    // Display file types
    Object.entries(analysis.fileTypes).forEach(([extension, count]) => {
        html += `
            <div class="file-type-item">
                <span class="file-extension">${extension}</span>
                <span class="file-count">${count} files</span>
            </div>`;
    });

    html += `
            </div>
        </div>

        <div class="key-files-section">
            <h4>üîë Key Files Found</h4>
            <div class="key-files-list">`;

    // Display key files
    analysis.keyFiles.forEach(fileName => {
        html += `<span class="key-file-tag">${fileName}</span>`;
    });

    html += `
            </div>
        </div>

        <div class="project-structure-section">
            <h4>üå≥ Project Structure</h4>
            <div class="file-tree">`;

    // Display file tree (limit to first 100 files for performance)
    const filesToShow = analysis.projectStructure.slice(0, 100);
    filesToShow.forEach(file => {
        const sizeKB = (file.size / 1024).toFixed(1);
        html += `
            <div class="file-tree-item">
                <span class="file-icon">${getFileIcon(file.extension)}</span>
                <span class="file-path">${file.path}</span>
                <span class="file-size">${sizeKB} KB</span>
            </div>`;
    });

    if (analysis.projectStructure.length > 100) {
        html += `<div class="file-tree-more">... and ${analysis.projectStructure.length - 100} more files</div>`;
    }

    html += `
            </div>
        </div>`;

    structureContent.innerHTML = html;
    structureContainer.classList.remove('hidden');
    structureContainer.scrollIntoView({ behavior: 'smooth', block: 'start' });
}

function displayAnalysisResult(content, timestamp, model, title) {
    const resultContainer = document.getElementById('project-analysis-result-container');
    const timestampEl = document.getElementById('project-analysis-timestamp');
    const modelEl = document.getElementById('project-analysis-model');
    const resultContent = document.getElementById('project-analysis-result-content');

    // Update title if provided
    const titleEl = resultContainer.querySelector('h3');
    if (title) {
        titleEl.textContent = title;
    }

    // Update metadata
    timestampEl.textContent = `Generated: ${new Date(timestamp).toLocaleString()}`;
    modelEl.textContent = `Model: ${model}`;

    // Update content
    resultContent.innerHTML = content;

    // Show container
    resultContainer.classList.remove('hidden');
    resultContainer.scrollIntoView({ behavior: 'smooth', block: 'start' });
}

function getFileIcon(extension) {
    const iconMap = {
        '.js': 'üü®', '.ts': 'üî∑', '.jsx': 'üü¶', '.tsx': 'üî∑',
        '.java': '‚òï', '.py': 'üêç', '.cs': 'üî∑', '.cpp': '‚ö°', '.c': '‚ö°',
        '.html': 'üåê', '.css': 'üé®', '.scss': 'üé®', '.less': 'üé®',
        '.json': 'üìã', '.xml': 'üìÑ', '.yml': '‚öôÔ∏è', '.yaml': '‚öôÔ∏è',
        '.md': 'üìù', '.txt': 'üìÑ', '.sql': 'üóÉÔ∏è', '.sh': '‚ö°',
        '.dockerfile': 'üê≥', '.gitignore': 'üö´'
    };
    return iconMap[extension.toLowerCase()] || 'üìÑ';
}

function clearProjectAnalyzer() {
    document.getElementById('project-path-input').value = '';
    document.getElementById('analysis-type').value = 'structure';
    document.getElementById('review-prompt-select-project').value = '';
    document.getElementById('project-structure-container').classList.add('hidden');
    document.getElementById('project-analysis-result-container').classList.add('hidden');
}

function browseProjectPath() {
    // Note: File/directory picker is not available in web browsers for security reasons
    // This is a placeholder that could be enhanced with a backend file browser
    showError('Directory browsing is not available in web browsers. Please enter the full path manually.');
}

function downloadAnalysisResult() {
    const resultContent = document.getElementById('project-analysis-result-content');
    const titleEl = document.querySelector('#project-analysis-result-container h3');

    if (!resultContent.innerHTML) {
        showError('No analysis result to download');
        return;
    }

    const title = titleEl.textContent;
    const content = resultContent.innerText;
    const timestamp = new Date().toISOString().split('T')[0];
    const filename = `${title.replace(/[^a-zA-Z0-9]/g, '_')}_${timestamp}.md`;

    const blob = new Blob([content], { type: 'text/markdown' });
    const url = URL.createObjectURL(blob);

    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);

    showSuccess('Analysis result downloaded successfully!');
}

function copyAnalysisResult() {
    const resultContent = document.getElementById('project-analysis-result-content');

    if (!resultContent.innerHTML) {
        showError('No analysis result to copy');
        return;
    }

    const content = resultContent.innerText;

    navigator.clipboard.writeText(content).then(() => {
        showSuccess('Analysis result copied to clipboard!');
    }).catch(() => {
        showError('Failed to copy to clipboard');
    });
}

// Initialize Project Analyzer when tab is shown
async function initializeProjectAnalyzer() {
    console.log('üîç Initializing Project Analyzer...');
    try {
        // Check AI service status
        console.log('üì° Checking AI service status...');
        await updateProjectAnalyzerStatus();

        // Load prompts for project review selector
        console.log('üìö Loading prompts...');
        await loadPromptsForProjectAnalyzer();

        console.log('‚úÖ Project Analyzer initialized successfully');
    } catch (error) {
        console.error('‚ùå Failed to initialize Project Analyzer:', error);
    }
}

async function updateProjectAnalyzerStatus() {
    const status = document.getElementById('project-analyzer-status');

    try {
        // Check AI status directly
        const response = await fetch(`${API_CONFIG.BASE_URL}/ai-review/status`);

        if (response.ok) {
            const aiStatus = await response.json();

            const statusHTML = aiStatus.claudeApiConfigured
                ? `<strong>‚úÖ Project Analyzer Ready:</strong> AI-powered analysis available`
                : `<strong>‚ö†Ô∏è Limited Functionality:</strong> Project structure analysis available, AI features require API key`;

            const statusClass = aiStatus.claudeApiConfigured ? 'success' : 'error';

            if (status) {
                status.innerHTML = statusHTML;
                status.className = `ai-status ${statusClass}`;
            }
        } else {
            // Fallback: Analysis service available, AI status unknown
            const statusHTML = '<strong>üîß Analysis Service Ready:</strong> Project structure analysis available';
            if (status) {
                status.innerHTML = statusHTML;
                status.className = 'ai-status success';
            }
        }

    } catch (error) {
        // Fallback: Basic functionality available
        const errorHTML = '<strong>üîß Basic Analysis Available:</strong> Project structure scanning ready';

        if (status) {
            status.innerHTML = errorHTML;
            status.className = 'ai-status';
        }
    }
}

async function loadPromptsForProjectAnalyzer() {
    try {
        const prompts = await promptApi.getAll();
        const reviewPromptSelect = document.getElementById('review-prompt-select-project');

        if (reviewPromptSelect) {
            // Clear existing options (keep placeholder)
            reviewPromptSelect.innerHTML = '<option value="">Use default project analysis...</option>';

            // Add prompts grouped by category
            const promptsByCategory = {};
            prompts.forEach(prompt => {
                const categoryName = prompt.category.name;
                if (!promptsByCategory[categoryName]) {
                    promptsByCategory[categoryName] = [];
                }
                promptsByCategory[categoryName].push(prompt);
            });

            // Add options grouped by category
            Object.keys(promptsByCategory).sort().forEach(categoryName => {
                const optgroup = document.createElement('optgroup');
                optgroup.label = categoryName;
                reviewPromptSelect.appendChild(optgroup);

                promptsByCategory[categoryName].forEach(prompt => {
                    const option = document.createElement('option');
                    option.value = prompt.id;
                    option.textContent = prompt.title;
                    optgroup.appendChild(option);
                });
            });
        }

    } catch (error) {
        console.error('Failed to load prompts for Project Analyzer:', error);
    }
}

// Test function for debugging
window.testProjectAnalyzerAPI = async function() {
    console.log('üß™ Testing Project Analyzer API...');
    try {
        const testPath = 'C:\\Users\\user\\code-review-manager';
        console.log('üìÅ Testing with path:', testPath);

        const result = await projectAnalysisApi.analyzeStructure(testPath);
        console.log('‚úÖ API Test Success:', result);
        return result;
    } catch (error) {
        console.error('‚ùå API Test Failed:', error);
        throw error;
    }
};

// Export functions for global access
window.analyzeProject = analyzeProject;
window.clearProjectAnalyzer = clearProjectAnalyzer;
window.browseProjectPath = browseProjectPath;
window.downloadAnalysisResult = downloadAnalysisResult;
window.copyAnalysisResult = copyAnalysisResult;
window.initializeProjectAnalyzer = initializeProjectAnalyzer;

--------------------------------------------------------
projects.js


/**
 * Projects Management
 * Handles CRUD operations for projects with team integration
 */

class ProjectsManager {
    constructor() {
        this.projects = [];
        this.filteredProjects = [];
        this.teams = [];
        this.searchTimeout = null;
    }

    async init() {
        this.setupEventListeners();
        await this.loadTeams();
        await this.loadProjects();
    }

    setupEventListeners() {
        const searchInput = document.getElementById('project-search');
        if (searchInput) {
            searchInput.addEventListener('input', () => {
                clearTimeout(this.searchTimeout);
                this.searchTimeout = setTimeout(() => this.searchProjects(), 300);
            });
        }

        const teamFilter = document.getElementById('project-team-filter');
        if (teamFilter) {
            teamFilter.addEventListener('change', () => this.filterProjects());
        }

        const statusFilter = document.getElementById('project-status-filter');
        if (statusFilter) {
            statusFilter.addEventListener('change', () => this.filterProjects());
        }

        const projectForm = document.getElementById('project-form');
        if (projectForm) {
            projectForm.addEventListener('submit', (e) => this.handleProjectSubmit(e));
        }
    }

    async loadTeams() {
        try {
            if (window.teamsManager && window.teamsManager.teams) {
                this.teams = window.teamsManager.teams;
            } else {
                const response = await teamApi.getAll();
                this.teams = response || [];
            }
            this.populateTeamSelectors();
        } catch (error) {
            console.warn('Failed to load teams for projects:', error);
        }
    }

    populateTeamSelectors() {
        console.log('ProjectsManager: populateTeamSelectors() called');
        console.log('ProjectsManager: Available teams:', this.teams);

        const selectors = ['project-team', 'project-team-filter'];

        selectors.forEach(selectorId => {
            const selector = document.getElementById(selectorId);
            console.log(`ProjectsManager: Selector #${selectorId}:`, selector);

            if (selector) {
                const currentValue = selector.value;
                selector.innerHTML = selectorId === 'project-team-filter' ?
                    '<option value="all">All Teams</option>' :
                    '<option value="">Select a team</option>';

                console.log(`ProjectsManager: Adding ${this.teams.length} teams to ${selectorId}`);
                this.teams.forEach(team => {
                    const option = document.createElement('option');
                    option.value = team.id;
                    option.textContent = team.name;
                    selector.appendChild(option);
                    console.log(`ProjectsManager: Added team: ${team.name} (ID: ${team.id})`);
                });

                if (currentValue) {
                    selector.value = currentValue;
                }

                console.log(`ProjectsManager: Selector #${selectorId} now has ${selector.options.length} options`);
            } else {
                console.warn(`ProjectsManager: Selector #${selectorId} not found in DOM`);
            }
        });
    }

    async loadProjects() {
        try {
            showLoading();

            try {
                const response = await projectApi.getAll();
                this.projects = response || [];
            } catch (error) {
                console.warn('Projects API not available:', error);
                this.projects = [];
            }

            this.filteredProjects = [...this.projects];
            this.renderProjects();

        } catch (error) {
            console.error('Failed to load projects:', error);
            showError('Failed to load projects');
        } finally {
            hideLoading();
        }
    }


    renderProjects() {
        const projectsGrid = document.getElementById('projects-grid');
        if (!projectsGrid) return;

        if (this.filteredProjects.length === 0) {
            projectsGrid.innerHTML = this.renderEmptyState();
            return;
        }

        projectsGrid.innerHTML = this.filteredProjects.map(project => this.renderProjectCard(project)).join('');
    }

    renderProjectCard(project) {
        const createdDate = new Date(project.createdDate).toLocaleDateString();
        const statusClass = project.active ? 'status-active' : 'status-inactive';
        const statusText = project.active ? 'Active' : 'Inactive';

        return `
            <div class="project-card" data-project-id="${project.id}">
                <div class="project-header">
                    <h3 class="project-name">${this.escapeHtml(project.name)}</h3>
                    <span class="project-status ${statusClass}">${statusText}</span>
                </div>

                <div class="project-description">
                    ${project.description ? this.escapeHtml(project.description) : 'No description provided'}
                </div>

                <div class="project-meta">
                    <div class="meta-item">
                        <span class="meta-icon">üë•</span>
                        <span>Team: ${project.teamName || 'Unknown'}</span>
                    </div>

                    ${project.repositoryUrl ? `
                        <div class="meta-item">
                            <span class="meta-icon">üîó</span>
                            <span><a href="${project.repositoryUrl}" target="_blank" rel="noopener">Repository</a></span>
                        </div>
                    ` : ''}

                    <div class="meta-item">
                        <span class="meta-icon">üåø</span>
                        <span>Branch: ${project.branchName || 'main'}</span>
                    </div>

                    <div class="meta-item">
                        <span class="meta-icon">üìÖ</span>
                        <span>Created ${createdDate}</span>
                    </div>
                </div>

                <div class="project-actions">
                    <button class="action-btn-small edit" onclick="editProject(${project.id})" title="Edit Project">
                        ‚úèÔ∏è Edit
                    </button>
                    <button class="action-btn-small" onclick="viewProjectReviews(${project.id})" title="View Reviews">
                        üîç Reviews
                    </button>
                    <button class="action-btn-small delete" onclick="deleteProject(${project.id})" title="Delete Project">
                        üóëÔ∏è Delete
                    </button>
                </div>
            </div>
        `;
    }

    renderEmptyState() {
        const hasFilters = document.getElementById('project-search')?.value ||
                          (document.getElementById('project-team-filter')?.value !== 'all') ||
                          (document.getElementById('project-status-filter')?.value !== 'all');

        if (hasFilters) {
            return `
                <div class="project-card-placeholder">
                    <div class="placeholder-content">
                        <div class="placeholder-icon">üîç</div>
                        <h3>No Projects Found</h3>
                        <p>No projects match your current search or filter criteria</p>
                        <button class="btn-secondary" onclick="clearProjectFilters()">Clear Filters</button>
                    </div>
                </div>
            `;
        }

        return `
            <div class="project-card-placeholder">
                <div class="placeholder-content">
                    <div class="placeholder-icon">üìÇ</div>
                    <h3>No Projects Yet</h3>
                    <p>Create your first project to start managing code reviews</p>
                    <button class="btn-primary" onclick="showProjectModal()">Create First Project</button>
                </div>
            </div>
        `;
    }

    searchProjects() {
        const searchTerm = document.getElementById('project-search')?.value.toLowerCase() || '';
        this.applyFilters(searchTerm);
    }

    filterProjects() {
        const searchTerm = document.getElementById('project-search')?.value.toLowerCase() || '';
        this.applyFilters(searchTerm);
    }

    applyFilters(searchTerm) {
        const teamFilter = document.getElementById('project-team-filter')?.value || 'all';
        const statusFilter = document.getElementById('project-status-filter')?.value || 'all';

        this.filteredProjects = this.projects.filter(project => {
            const matchesSearch = !searchTerm ||
                project.name.toLowerCase().includes(searchTerm) ||
                (project.description && project.description.toLowerCase().includes(searchTerm)) ||
                (project.teamName && project.teamName.toLowerCase().includes(searchTerm));

            const matchesTeam = teamFilter === 'all' || project.teamId == teamFilter;

            const matchesStatus = statusFilter === 'all' ||
                (statusFilter === 'active' && project.active) ||
                (statusFilter === 'inactive' && !project.active);

            return matchesSearch && matchesTeam && matchesStatus;
        });

        this.renderProjects();
    }

    async handleProjectSubmit(event) {
        event.preventDefault();

        const projectData = {
            name: document.getElementById('project-name').value,
            description: document.getElementById('project-description').value,
            teamId: parseInt(document.getElementById('project-team').value),
            repositoryUrl: document.getElementById('project-repository-url').value,
            branchName: document.getElementById('project-branch-name').value || 'main',
            active: document.getElementById('project-active').checked
        };

        if (!projectData.name || projectData.name.trim().length === 0) {
            showError('Project name is required');
            return;
        }

        if (!projectData.teamId) {
            showError('Please select a team');
            return;
        }

        try {
            const projectId = document.getElementById('project-id').value;

            if (projectId) {
                await this.updateProject(projectId, projectData);
            } else {
                await this.createProject(projectData);
            }

            hideProjectModal();
            await this.loadProjects();

        } catch (error) {
            console.error('Failed to save project:', error);
            showError('Failed to save project');
        }
    }

    async createProject(projectData) {
        try {
            await projectApi.create(projectData);
            showSuccess('Project created successfully');
        } catch (error) {
            const team = this.teams.find(t => t.id === projectData.teamId);
            const newProject = {
                id: Date.now(),
                ...projectData,
                teamName: team ? team.name : 'Unknown',
                createdDate: new Date().toISOString(),
                lastModified: new Date().toISOString()
            };
            this.projects.push(newProject);
            showSuccess('Project created successfully');
        }
    }

    async updateProject(projectId, projectData) {
        try {
            await projectApi.update(projectId, projectData);
            showSuccess('Project updated successfully');
        } catch (error) {
            const projectIndex = this.projects.findIndex(p => p.id == projectId);
            if (projectIndex !== -1) {
                const team = this.teams.find(t => t.id === projectData.teamId);
                this.projects[projectIndex] = {
                    ...this.projects[projectIndex],
                    ...projectData,
                    teamName: team ? team.name : 'Unknown',
                    lastModified: new Date().toISOString()
                };
                showSuccess('Project updated successfully');
            }
        }
    }

    async deleteProject(projectId) {
        try {
            await projectApi.delete(projectId);
            showSuccess('Project deleted successfully');
            await this.loadProjects();
        } catch (error) {
            this.projects = this.projects.filter(p => p.id != projectId);
            this.filteredProjects = this.filteredProjects.filter(p => p.id != projectId);
            this.renderProjects();
            showSuccess('Project deleted successfully');
        }
    }

    getProjectById(projectId) {
        return this.projects.find(project => project.id == projectId);
    }

    escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
}

window.projectsManager = new ProjectsManager();

// Global functions
window.showProjectModal = async function(projectId = null) {
    const modal = document.getElementById('project-modal');
    const form = document.getElementById('project-form');
    const title = document.getElementById('project-modal-title');

    if (!modal || !form) return;

    form.reset();
    document.getElementById('project-id').value = '';

    // Ensure teams are loaded and populate the dropdown
    if (window.projectsManager) {
        await window.projectsManager.loadTeams();
        window.projectsManager.populateTeamSelectors();
    }

    if (projectId) {
        const project = window.projectsManager.getProjectById(projectId);
        if (project) {
            title.textContent = 'Edit Project';
            document.getElementById('project-id').value = project.id;
            document.getElementById('project-name').value = project.name;
            document.getElementById('project-description').value = project.description || '';
            document.getElementById('project-team').value = project.teamId;
            document.getElementById('project-repository-url').value = project.repositoryUrl || '';
            document.getElementById('project-branch-name').value = project.branchName || '';
            document.getElementById('project-active').checked = project.active;
        }
    } else {
        title.textContent = 'Add New Project';
        document.getElementById('project-active').checked = true;
    }

    modal.classList.remove('hidden');
};

window.hideProjectModal = function() {
    const modal = document.getElementById('project-modal');
    if (modal) modal.classList.add('hidden');
};

window.editProject = function(projectId) {
    showProjectModal(projectId);
};

window.deleteProject = function(projectId) {
    const project = window.projectsManager.getProjectById(projectId);
    if (!project) return;

    showConfirm(
        `Are you sure you want to delete the project "${project.name}"?`,
        async () => {
            await window.projectsManager.deleteProject(projectId);
        }
    );
};

window.viewProjectReviews = function(projectId) {
    switchTab('reviews');
    setTimeout(() => {
        const projectFilter = document.getElementById('reviews-project-filter');
        if (projectFilter) {
            projectFilter.value = projectId;
            if (window.reviewsManager && typeof window.reviewsManager.filterReviews === 'function') {
                window.reviewsManager.filterReviews();
            }
        }
    }, 300);
};

window.clearProjectFilters = function() {
    document.getElementById('project-search').value = '';
    document.getElementById('project-team-filter').value = 'all';
    document.getElementById('project-status-filter').value = 'all';
    window.projectsManager.applyFilters('');
};

document.addEventListener('DOMContentLoaded', () => {
    if (document.getElementById('projects-tab')) {
        window.projectsManager.init();
    }
});

-----------------------------------------


