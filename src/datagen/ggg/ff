-- schema.sql
-- Create necessary types and enums
CREATE TYPE operator_type AS ENUM (
    'PythonOperator',
    'BashOperator',
    'PostgresOperator',
    'EmptyOperator',
    'BranchPythonOperator',
    'ExternalTaskSensor',
    'HttpOperator',
    'SqlOperator',
    'EmailOperator',
    'DummyOperator'
);

CREATE TYPE env_type AS ENUM ('dev', 'staging', 'prod');

CREATE TYPE trigger_rule_type AS ENUM (
    'all_success',
    'all_failed',
    'all_done',
    'one_success',
    'one_failed',
    'none_failed',
    'none_skipped'
);

-- Create tables
CREATE TABLE IF NOT EXISTS dag_metadata (
    dag_id VARCHAR PRIMARY KEY,
    owner VARCHAR NOT NULL,
    description TEXT,
    schedule_interval VARCHAR NOT NULL,
    start_date TIMESTAMP NOT NULL,
    end_date TIMESTAMP,
    catchup BOOLEAN DEFAULT false,
    tags JSONB DEFAULT '[]',
    max_active_runs INT DEFAULT 1,
    default_args JSONB DEFAULT '{}',
    concurrency INT,
    is_active BOOLEAN DEFAULT true,
    is_paused BOOLEAN DEFAULT false,
    environment env_type DEFAULT 'dev',
    depends_on_past BOOLEAN DEFAULT false,
    wait_for_downstream BOOLEAN DEFAULT false,
    email_on_failure BOOLEAN DEFAULT true,
    email_on_retry BOOLEAN DEFAULT false,
    retries INT DEFAULT 3,
    retry_delay INTERVAL DEFAULT '5 minutes',
    sla INTERVAL,
    on_success_callback TEXT,
    on_failure_callback TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS task_configs (
    task_id VARCHAR NOT NULL,
    dag_id VARCHAR REFERENCES dag_metadata(dag_id),
    operator_type operator_type NOT NULL,
    task_params JSONB DEFAULT '{}',
    python_callable TEXT,
    bash_command TEXT,
    sql_query TEXT,
    trigger_rule trigger_rule_type DEFAULT 'all_success',
    retries INT DEFAULT 3,
    retry_delay INTERVAL DEFAULT '5 minutes',
    priority_weight INT DEFAULT 1,
    queue VARCHAR,
    pool VARCHAR DEFAULT 'default_pool',
    execution_timeout INTERVAL,
    depends_on_past BOOLEAN DEFAULT false,
    wait_for_downstream BOOLEAN DEFAULT false,
    email_on_failure BOOLEAN DEFAULT true,
    email_on_retry BOOLEAN DEFAULT false,
    on_success_callback TEXT,
    on_failure_callback TEXT,
    on_retry_callback TEXT,
    sla INTERVAL,
    group_id INT,
    doc TEXT,
    doc_md TEXT,
    doc_rst TEXT,
    doc_json TEXT,
    doc_yaml TEXT,
    PRIMARY KEY (task_id, dag_id)
);

CREATE TABLE IF NOT EXISTS task_dependencies (
    id SERIAL PRIMARY KEY,
    dag_id VARCHAR REFERENCES dag_metadata(dag_id),
    upstream_task_id VARCHAR,
    downstream_task_id VARCHAR,
    dependency_type VARCHAR DEFAULT 'direct',  -- direct, cross_downstream
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (dag_id, upstream_task_id) REFERENCES task_configs(dag_id, task_id),
    FOREIGN KEY (dag_id, downstream_task_id) REFERENCES task_configs(dag_id, task_id)
);

CREATE TABLE IF NOT EXISTS task_groups (
    group_id SERIAL PRIMARY KEY,
    dag_id VARCHAR REFERENCES dag_metadata(dag_id),
    group_name VARCHAR NOT NULL,
    parent_group_id INT REFERENCES task_groups(group_id),
    tooltip TEXT,
    prefix_group_id BOOLEAN DEFAULT true,
    tag VARCHAR,
    owner VARCHAR,
    description TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE (dag_id, group_name)
);

CREATE TABLE IF NOT EXISTS connections (
    conn_id VARCHAR PRIMARY KEY,
    conn_type VARCHAR NOT NULL,
    host VARCHAR,
    schema VARCHAR,
    login VARCHAR,
    password VARCHAR,
    port INT,
    extra JSONB DEFAULT '{}',
    is_encrypted BOOLEAN DEFAULT false,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS variables (
    var_id SERIAL PRIMARY KEY,
    var_key VARCHAR UNIQUE NOT NULL,
    var_value TEXT,
    description TEXT,
    is_encrypted BOOLEAN DEFAULT false,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Create indexes
CREATE INDEX idx_dag_metadata_env ON dag_metadata(environment);
CREATE INDEX idx_task_configs_dag_id ON task_configs(dag_id);
CREATE INDEX idx_task_dependencies_dag_id ON task_dependencies(dag_id);
CREATE INDEX idx_task_groups_dag_id ON task_groups(dag_id);

-- Create update trigger for updated_at
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ language 'plpgsql';

CREATE TRIGGER update_dag_metadata_updated_at
    BEFORE UPDATE ON dag_metadata
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();