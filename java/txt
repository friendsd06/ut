package com.banking.mcr.validation;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import lombok.Data;
import lombok.Builder;
import lombok.AllArgsConstructor;

import java.util.*;
import java.util.stream.Collectors;

/**
 * Clean MCR Validation Service Implementation
 *
 * This service provides clean validation methods with proper return objects
 * and comprehensive data flow processing for financial records.
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class MCRValidationService {

    // Dependencies
    private final StorageServiceProcessor storageServiceProcessor;
    private final AdapterService adapterService;

    // Configuration
    @Value("${query.filter-chunk-size:1000}")
    private Integer chunkSize;

    // Sample providers for testing
    private final SampleDataProvider dataProvider = new SampleDataProvider();
    private final ValidationUtils validationUtils = new ValidationUtils();

    // Constants
    private static final String DAILY_FREQ = "D";
    private static final String MONTHLY_FREQ = "M";
    private static final String PIPE_DELIMITER = "|";
    private static final String VALIDATION_ERROR_MSG = "VALIDATION_ERROR";

    /**
     * Validates position codes and returns simple response object
     *
     * SAMPLE INPUT:
     * positionCodes = ["POS-001", "POS-002", "INVALID-999"]
     * request = GenericRequest with entity data
     * validationColumn = "POSITION_CODE"
     * validationTable = "POSITION_TABLE"
     *
     * SAMPLE PROCESSING:
     * 1. Check if AMU request -> Skip validation
     * 2. Multi-column check -> Route to appropriate method
     * 3. Single column -> Validate against position codes list
     * 4. Mark errors for invalid codes
     *
     * SAMPLE OUTPUT:
     * ChildEntityResponse{isValid: false}
     *
     * @param positionCodes List of valid position codes
     * @param request The validation request
     * @param validationColumn Column to validate
     * @param validationTable Table for validation
     * @return ChildEntityResponse object with validation status
     */
    public ChildEntityResponse validatePositionCode(List<String> positionCodes,
                                                  GenericRequest request,
                                                  String validationColumn,
                                                  String validationTable) {

        log.info("🔍 Starting position code validation for column: {} in table: {}",
                validationColumn, validationTable);

        // Early return for AMU requests
        if (isAMURequest(request)) {
            log.info("⏭️ Skipping validation for AMU request");
            return new ChildEntityResponse(true);
        }

        try {
            // Route to appropriate validation method
            if (validationColumn.contains(PIPE_DELIMITER)) {
                return validateMultipleColumnsForDuplicates(request, validationColumn, validationTable);
            } else {
                return validateSingleColumnRequest(request, validationColumn, validationTable, positionCodes);
            }

        } catch (Exception e) {
            log.error("❌ Validation failed with exception: {}", e.getMessage(), e);
            return new ChildEntityResponse(false);
        }
    }

    /**
     * Validates multiple columns for duplicate combinations with complete data flow
     *
     * DETAILED DATA FLOW:
     *
     * 📥 INPUT:
     * request = {
     *   frequency: "DAILY",
     *   cohData: "2024-01-15",
     *   requestId: "REQ-001",
     *   data: [{
     *     entity: "POSITION_TABLE",
     *     attributeData: [
     *       {"ACCOUNT_ID": "ACC-123", "CURRENCY": "USD", "BRANCH": "NYC"},
     *       {"ACCOUNT_ID": "ACC-456", "CURRENCY": "EUR", "BRANCH": "LON"},
     *       {"ACCOUNT_ID": "ACC-789", "CURRENCY": "GBP", "BRANCH": "NYC"}
     *     ]
     *   }]
     * }
     * validationColumn = "ACCOUNT_ID|CURRENCY|BRANCH"
     * validationTable = "POSITION_TABLE"
     *
     * 🔄 PROCESSING STEPS:
     *
     * Step 1: Frequency Normalization
     *   "DAILY" -> "D"
     *
     * Step 2: Extract Concatenated Values
     *   Record 1: "ACC-123" + "|" + "USD" + "|" + "NYC" = "ACC-123|USD|NYC"
     *   Record 2: "ACC-456" + "|" + "EUR" + "|" + "LON" = "ACC-456|EUR|LON"
     *   Record 3: "ACC-789" + "|" + "GBP" + "|" + "NYC" = "ACC-789|GBP|NYC"
     *   concatenatedValues = ["ACC-123|USD|NYC", "ACC-456|EUR|LON", "ACC-789|GBP|NYC"]
     *
     * Step 3: Database Query for Duplicates
     *   Query: Check which combinations already exist in database
     *   Result: invalidCombinations = ["ACC-456|EUR|LON"] // This exists as duplicate
     *
     * Step 4: Mark Errors for Invalid Combinations
     *   Record 1: "ACC-123|USD|NYC" -> Not in invalid list -> ✅ Valid
     *   Record 2: "ACC-456|EUR|LON" -> Found in invalid list -> ❌ Add error key
     *   Record 3: "ACC-789|GBP|NYC" -> Not in invalid list -> ✅ Valid
     *
     * 📤 OUTPUT:
     * ChildEntityResponse{isValid: false}
     *
     * Modified request data:
     * [{
     *   entity: "POSITION_TABLE",
     *   attributeData: [
     *     {"ACCOUNT_ID": "ACC-123", "CURRENCY": "USD", "BRANCH": "NYC"},                    // ✅ Unchanged
     *     {"ACCOUNT_ID": "ACC-456|VALIDATION_ERROR", "CURRENCY": "EUR|VALIDATION_ERROR",
     *      "BRANCH": "LON|VALIDATION_ERROR"},                                              // ❌ All fields marked with error
     *     {"ACCOUNT_ID": "ACC-789", "CURRENCY": "GBP", "BRANCH": "NYC"}                    // ✅ Unchanged
     *   ]
     * }]
     *
     * @param request The validation request
     * @param validationColumn Pipe-separated column names
     * @param validationTable Table for validation
     * @return ChildEntityResponse with simple validation status
     */
    public ChildEntityResponse validateMultipleColumnsForDuplicates(GenericRequest request,
                                                                  String validationColumn,
                                                                  String validationTable) {

        log.info("🔍 Starting multi-column validation for table: {}", validationTable);
        log.info("📊 Validation columns: {}", validationColumn);

        // Step 1: Normalize frequency
        String frequencyCode = normalizeFrequency(request.getFrequency());
        log.info("📅 Frequency normalized: {} -> {}", request.getFrequency(), frequencyCode);

        // Step 2: Extract concatenated values from all records
        Set<String> concatenatedValues = extractConcatenatedValues(request, validationColumn);
        log.info("🔗 Extracted {} concatenated values: {}",
                concatenatedValues.size(), concatenatedValues);

        // Step 3: Query database for duplicate combinations
        List<String> invalidCombinations = queryDatabaseForDuplicates(
            request, validationTable, validationColumn, frequencyCode, concatenatedValues);

        log.info("🚨 Found {} invalid combinations: {}", invalidCombinations.size(), invalidCombinations);

        // Step 4: Mark errors and build result
        boolean hasErrors = markValidationErrors(request, validationTable, validationColumn, invalidCombinations);

        // Build final simple response
        boolean isValid = !hasErrors;

        log.info("✅ Multi-column validation completed: isValid={}", isValid);
        return new ChildEntityResponse(isValid);
    }

    // =====================================
    // HELPER METHODS
    // =====================================

    /**
     * Validates single column requests
     */
    private ChildEntityResponse validateSingleColumnRequest(GenericRequest request,
                                                           String validationColumn,
                                                           String validationTable,
                                                           List<String> positionCodes) throws Exception {

        log.info("🔍 Starting single column validation for column: {}", validationColumn);

        // Handle large position code lists with chunking
        if (positionCodes.size() > chunkSize) {
            handleLargePositionCodeList(request, validationColumn, positionCodes);
        }

        // Validate attributes
        boolean hasErrors = validateSingleColumnAttributes(request, validationColumn, positionCodes);

        boolean isValid = !hasErrors;
        return new ChildEntityResponse(isValid);
    }

    /**
     * Extracts concatenated values and data source codes from request
     */
    private Set<String> extractConcatenatedValues(GenericRequest request, String validationColumn) {
        Set<String> concatenatedValues = new HashSet<>();

        for (EntityRequestData dataItem : request.getData()) {
            for (Map<String, String> attributes : dataItem.getAttributeData()) {
                String concatenated = validationUtils.concatAllColumnValues(attributes, validationColumn);
                concatenatedValues.add(concatenated);
            }
        }

        return concatenatedValues;
    }

    /**
     * Queries database for duplicate combinations
     */
    private List<String> queryDatabaseForDuplicates(GenericRequest request,
                                                   String validationTable,
                                                   String validationColumn,
                                                   String frequencyCode,
                                                   Set<String> concatenatedValues) {

        return dataProvider.getColumnValidationCodes(
            request.getCohData(),
            new ArrayList<>(concatenatedValues),
            request.getRequestId(),
            validationTable,
            validationColumn,
            new ArrayList<>(), // Empty data source codes
            frequencyCode
        );
    }

    /**
     * Marks validation errors for invalid combinations
     */
    private boolean markValidationErrors(GenericRequest request,
                                       String validationTable,
                                       String validationColumn,
                                       List<String> invalidCombinations) {

        boolean hasErrors = false;

        for (EntityRequestData dataItem : request.getData()) {
            if (validationTable.equalsIgnoreCase(dataItem.getEntity())) {

                for (Map<String, String> attributes : dataItem.getAttributeData()) {
                    String concatenatedValue = validationUtils.concatAllColumnValues(attributes, validationColumn);

                    if (invalidCombinations.contains(concatenatedValue)) {
                        // Add error to each individual field in the combination
                        createMultiColumnValidationError(attributes, validationColumn);
                        hasErrors = true;
                        log.debug("❌ Invalid combination: {}", concatenatedValue);
                    } else {
                        log.debug("✅ Valid combination: {}", concatenatedValue);
                    }
                }
            }
        }

        return hasErrors;
    }

    /**
     * Creates validation error for multi-column validation failure
     * Adds error messages to ALL individual columns in the validation set
     *
     * SAMPLE INPUT:
     * attributes = {"ACCOUNT_ID": "ACC-456", "CURRENCY": "EUR", "BRANCH": "LON"}
     * validationColumn = "ACCOUNT_ID|CURRENCY|BRANCH"
     *
     * SAMPLE OUTPUT:
     * attributes = {
     *   "ACCOUNT_ID": "ACC-456|VALIDATION_ERROR",     // ❌ Error added to each field
     *   "CURRENCY": "EUR|VALIDATION_ERROR",           // ❌ Error added to each field
     *   "BRANCH": "LON|VALIDATION_ERROR"              // ❌ Error added to each field
     * }
     */
    private void createMultiColumnValidationError(Map<String, String> attributes,
                                                String validationColumn) {

        String[] columns = validationColumn.split("\\" + PIPE_DELIMITER);

        for (String column : columns) {
            String originalValue = attributes.get(column);
            if (originalValue != null) {
                String errorValue = originalValue + PIPE_DELIMITER + VALIDATION_ERROR_MSG;
                attributes.put(column, errorValue);
                log.debug("🔧 Added validation error to field {}: {} -> {}", column, originalValue, errorValue);
            }
        }
    }

    /**
     * Validates single column attributes against position codes
     */
    private boolean validateSingleColumnAttributes(GenericRequest request,
                                                  String validationColumn,
                                                  List<String> positionCodes) {
        boolean hasErrors = false;

        for (EntityRequestData dataItem : request.getData()) {
            for (Map<String, String> attributes : dataItem.getAttributeData()) {
                String columnValue = attributes.get(validationColumn);

                if (positionCodes.contains(columnValue)) {
                    // Mark as invalid
                    attributes.put(validationColumn,
                        columnValue + PIPE_DELIMITER + VALIDATION_ERROR_MSG);
                    hasErrors = true;
                }
            }
        }

        return hasErrors;
    }

    /**
     * Handles large position code lists with chunking
     */
    private void handleLargePositionCodeList(GenericRequest request,
                                           String validationColumn,
                                           List<String> positionCodes) throws Exception {

        log.info("📦 Handling large position code list with {} items (chunk size: {})",
                positionCodes.size(), chunkSize);

        QueryRequest queryRequest = adapterService.getQueryRequestForFilter(request, validationColumn, positionCodes);
        Map<String, String> attributePathMap = storageServiceProcessor.getAttributeOfFilePathMap(queryRequest);

        log.debug("🗄️ Retrieved attribute path map with {} entries", attributePathMap.size());
    }

    /**
     * Normalizes frequency to standard codes
     */
    private String normalizeFrequency(String frequency) {
        if (frequency == null) return "";

        String freq = frequency.trim().toUpperCase();
        if ("DAILY".equals(freq) || "D".equals(freq)) return DAILY_FREQ;
        if ("MONTHLY".equals(freq) || "M".equals(freq)) return MONTHLY_FREQ;

        return frequency;
    }

    /**
     * Checks if request is AMU type
     */
    private boolean isAMURequest(GenericRequest request) {
        return "AMU".equals(request.getRequestType());
    }

    // =====================================
    // COMPREHENSIVE TESTING
    // =====================================

    public static void main(String[] args) {
        System.out.println("🏦 Clean MCR Validation Service - Complete Test Suite");
        System.out.println("====================================================");

        MCRValidationService service = createTestService();

        testPositionCodeValidation(service);
        testMultiColumnValidationDataFlow(service);

        System.out.println("\n✅ All tests completed successfully!");
    }

    /**
     * Creates test service with mock dependencies
     */
    private static MCRValidationService createTestService() {
        return new MCRValidationService(
            new MockStorageServiceProcessor(),
            new MockAdapterService()
        );
    }

    /**
     * Tests position code validation with custom return object
     */
    private static void testPositionCodeValidation(MCRValidationService service) {
        System.out.println("\n📋 Testing Position Code Validation with ChildEntityResponse");
        System.out.println("==========================================================");

        List<String> validPositionCodes = Arrays.asList("POS-001", "POS-002", "POS-003");
        GenericRequest request = createTestRequest();

        ChildEntityResponse result = service.validatePositionCode(
            validPositionCodes, request, "POSITION_CODE", "POSITION_TABLE");

        System.out.println("Validation Result: " + result);
        System.out.println("  Is Valid: " + result.isValid());
        System.out.println("  Test Result: " + (!result.isValid() ? "✅ PASSED" : "❌ FAILED"));
    }

    /**
     * Tests multi-column validation with complete data flow
     */
    private static void testMultiColumnValidationDataFlow(MCRValidationService service) {
        System.out.println("\n🔍 Testing Multi-Column Validation Data Flow");
        System.out.println("===========================================");

        GenericRequest request = createMultiColumnTestRequest();

        System.out.println("📥 INPUT DATA:");
        displayRequestData(request, "BEFORE VALIDATION");

        ChildEntityResponse result = service.validateMultipleColumnsForDuplicates(
            request, "ACCOUNT_ID|CURRENCY|BRANCH", "POSITION_TABLE");

        System.out.println("\n📊 VALIDATION RESULT:");
        System.out.println("  " + result);
        System.out.println("  Is Valid: " + result.isValid());

        System.out.println("\n📤 OUTPUT DATA:");
        displayRequestData(request, "AFTER VALIDATION");

        System.out.println("\n🎯 Test Result: " + (!result.isValid() ? "✅ PASSED" : "❌ FAILED"));
    }

    /**
     * Creates realistic test request for multi-column validation
     */
    private static GenericRequest createMultiColumnTestRequest() {
        GenericRequest request = new GenericRequest();
        request.setFrequency("DAILY");
        request.setCohData("2024-01-15");
        request.setRequestId("REQ-001");
        request.setRequestType("MCR");

        EntityRequestData entityData = new EntityRequestData();
        entityData.setEntity("POSITION_TABLE");

        List<Map<String, String>> attributeData = new ArrayList<>();

        // Record 1 - Valid combination
        Map<String, String> record1 = new HashMap<>();
        record1.put("ACCOUNT_ID", "ACC-123");
        record1.put("CURRENCY", "USD");
        record1.put("BRANCH", "NYC");
        attributeData.add(record1);

        // Record 2 - Invalid combination (will be flagged by mock)
        Map<String, String> record2 = new HashMap<>();
        record2.put("ACCOUNT_ID", "ACC-456");
        record2.put("CURRENCY", "EUR");
        record2.put("BRANCH", "LON");
        attributeData.add(record2);

        // Record 3 - Valid combination
        Map<String, String> record3 = new HashMap<>();
        record3.put("ACCOUNT_ID", "ACC-789");
        record3.put("CURRENCY", "GBP");
        record3.put("BRANCH", "NYC");
        attributeData.add(record3);

        entityData.setAttributeData(attributeData);
        request.setData(Arrays.asList(entityData));

        return request;
    }

    /**
     * Creates simple test request
     */
    private static GenericRequest createTestRequest() {
        GenericRequest request = new GenericRequest();
        request.setRequestType("MCR");
        request.setFrequency("DAILY");

        EntityRequestData entityData = new EntityRequestData();
        List<Map<String, String>> attributeData = new ArrayList<>();

        Map<String, String> record = new HashMap<>();
        record.put("POSITION_CODE", "INVALID-999");
        attributeData.add(record);

        entityData.setAttributeData(attributeData);
        request.setData(Arrays.asList(entityData));

        return request;
    }

    /**
     * Displays request data for visualization
     */
    private static void displayRequestData(GenericRequest request, String phase) {
        System.out.println(phase + ":");
        int recordNum = 1;

        for (EntityRequestData data : request.getData()) {
            for (Map<String, String> attributes : data.getAttributeData()) {
                System.out.printf("  Record %d: ACCOUNT_ID=%s, CURRENCY=%s, BRANCH=%s%n",
                                recordNum++,
                                attributes.get("ACCOUNT_ID"),
                                attributes.get("CURRENCY"),
                                attributes.get("BRANCH"));

                // Check for error fields
                boolean hasError = false;
                for (Map.Entry<String, String> entry : attributes.entrySet()) {
                    if (entry.getKey().contains("|") && entry.getValue().contains("VALIDATION_ERROR")) {
                        System.out.println("    ❌ ERROR: \"" + entry.getKey() + "\": \"" + entry.getValue() + "\"");
                        hasError = true;
                    }
                }

                if (!hasError) {
                    System.out.println("    ✅ VALID");
                }
            }
        }
    }
}

// =====================================
// CUSTOM RETURN MODELS
// =====================================

/**
 * Simple custom response model with single boolean attribute
 */
@Data
@Builder
@AllArgsConstructor
class ChildEntityResponse {
    private boolean isValid;

    // Default constructor
    public ChildEntityResponse() {}

    public ChildEntityResponse(boolean isValid) {
        this.isValid = isValid;
    }

    @Override
    public String toString() {
        return String.format("ChildEntityResponse{isValid=%s}", isValid);
    }
}

// =====================================
// SUPPORTING CLASSES
// =====================================

/**
 * Validation utilities
 */
class ValidationUtils {
    public String concatAllColumnValues(Map<String, String> attributes, String validationColumn) {
        return Arrays.stream(validationColumn.split("\\|"))
                .map(column -> attributes.getOrDefault(column.trim(), ""))
                .collect(Collectors.joining("|"));
    }
}

/**
 * Sample data provider for testing
 */
class SampleDataProvider {
    public List<String> getColumnValidationCodes(String cohData,
                                                List<String> concatenatedValues,
                                                String requestId,
                                                String validationTable,
                                                String validationColumn,
                                                List<String> dataSourceCodes,
                                                String frequencyCode) {

        System.out.println("🗄️ Mock Database Query executed");
        System.out.println("  📊 Checking: " + concatenatedValues);

        // Mock: Return ACC-456|EUR|LON as duplicate
        List<String> duplicates = Arrays.asList("ACC-456|EUR|LON");
        System.out.println("  🚨 Duplicates found: " + duplicates);

        return duplicates;
    }
}

// =====================================
// DATA MODELS
// =====================================

class GenericRequest {
    private String frequency;
    private String cohData;
    private String requestId;
    private String requestType;
    private List<EntityRequestData> data;

    // Getters and setters
    public String getFrequency() { return frequency; }
    public void setFrequency(String frequency) { this.frequency = frequency; }

    public String getCohData() { return cohData; }
    public void setCohData(String cohData) { this.cohData = cohData; }

    public String getRequestId() { return requestId; }
    public void setRequestId(String requestId) { this.requestId = requestId; }

    public String getRequestType() { return requestType; }
    public void setRequestType(String requestType) { this.requestType = requestType; }

    public List<EntityRequestData> getData() { return data; }
    public void setData(List<EntityRequestData> data) { this.data = data; }
}

class EntityRequestData {
    private String entity;
    private List<Map<String, String>> attributeData;

    public String getEntity() { return entity; }
    public void setEntity(String entity) { this.entity = entity; }

    public List<Map<String, String>> getAttributeData() { return attributeData; }
    public void setAttributeData(List<Map<String, String>> attributeData) { this.attributeData = attributeData; }
}

class QueryRequest {
    private String query;
    private List<String> parameters;

    public String getQuery() { return query; }
    public void setQuery(String query) { this.query = query; }

    public List<String> getParameters() { return parameters; }
    public void setParameters(List<String> parameters) { this.parameters = parameters; }
}

// =====================================
// INTERFACES
// =====================================

interface StorageServiceProcessor {
    Map<String, String> getAttributeOfFilePathMap(QueryRequest queryRequest) throws Exception;
}

interface AdapterService {
    QueryRequest getQueryRequestForFilter(GenericRequest request, String validationColumn, List<String> positionCodes);
}

// =====================================
// MOCK IMPLEMENTATIONS
// =====================================

class MockStorageServiceProcessor implements StorageServiceProcessor {
    @Override
    public Map<String, String> getAttributeOfFilePathMap(QueryRequest queryRequest) {
        return new HashMap<>();
    }
}

class MockAdapterService implements AdapterService {
    @Override
    public QueryRequest getQueryRequestForFilter(GenericRequest request, String validationColumn, List<String> positionCodes) {
        QueryRequest queryRequest = new QueryRequest();
        queryRequest.setQuery("SELECT * FROM validation WHERE column = ?");
        queryRequest.setParameters(positionCodes);
        return queryRequest;
    }
}