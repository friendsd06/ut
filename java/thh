

Thought for 4 seconds
Below is an in-depth explanation of how DRL files, Guided Decision Tables, and other assets are stored internally by KIE Workbench (a.k.a. Business Central), and which databases can be used to persist the application’s metadata.

1. Where Are DRL Files and Guided Decision Tables Stored?
1.1 Git-Based Storage
All project assets (DRL files, Guided Decision Table files (.gdst), BPMN2 process files, test scenarios, etc.) in KIE Workbench are stored in an internal Git repository structure. By default, when you install KIE Workbench (or “Business Central”), it uses the JGit library under the hood and places these Git repositories in a .niogit directory on the file system.

.niogit directory: Inside this folder, you will find subfolders for each space/organization (e.g., “myspace”) and each Git repository that corresponds to a project in the Workbench.

Files: Within that Git repository folder, you’ll see standard Git branches (refs/heads), objects, and so on. The actual rule assets (like .drl, .gdst) are stored as regular text (or binary, depending on the asset) inside the Git repo structure.

Hence, physically on the KIE Workbench server:

You have a directory named .niogit.
Inside .niogit, you have something like myspace/myproject.git/ (plus Git internal structures).
Within that .git structure, the rule files are versioned just like normal Git content.
When you open your project in KIE Workbench, you’re effectively editing files in a Git repository. When you commit changes (e.g., saving a new DRL), it’s recorded as a Git commit. You can even push/pull these repos externally to a remote Git server if configured.

1.2 Asset Types
DRL files: Appear in the repository with a .drl extension.
Guided Decision Tables: Appear as .gdst files (or .gdrl in older versions).
BPMN2 processes: Appear as .bpmn or .bpmn2.
Data objects: Appear as .java or .xml definitions that the Workbench manages under the covers.
In short, all these are versioned inside the Workbench’s internal Git (or external Git if configured).

2. What Are the Databases Used For?
Although rule assets (like DRL, BPMN, etc.) are stored in Git on the file system, the Workbench (and entire KIE suite) also needs a relational database to store runtime and metadata such as:

JBPM or RHPAM process data (process instances, task details, history logs).
Jobs (timer jobs, scheduling).
Executor service data.
User task information for BPM or advanced use cases.
Audit logs (if you enable auditing or logging).
Deployment descriptors (internal references).
So, the database is primarily for the runtime aspects (like process instance states, task assignments, logs, etc.) and for certain “metadata” beyond the actual Git-managed assets.

In Red Hat Process Automation Manager (RHPAM) or Drools/jBPM community distribution, you configure the data source in the standalone.xml (or application.properties) so the Workbench knows which DB to use for these runtime or operational records.

3. Which Databases Are Supported?
KIE Workbench / Business Central can be configured to persist its data (runtime process data, jobs, etc.) in virtually any relational database that has a JDBC driver and is JPA-compatible. Commonly tested and fully supported DBs include:

PostgreSQL
MySQL / MariaDB
Oracle
Microsoft SQL Server
IBM DB2 (in older versions)
H2 (for demo/dev environments)
In production, you typically configure one of these enterprise databases (Postgres, Oracle, MS SQL, etc.) as the main data source.

3.1 How to Configure
Add the JDBC driver to your application server (e.g., WildFly, Tomcat).
In standalone.xml (WildFly) or application-*.properties (Spring Boot approach):
Define a JNDI data source (e.g., java:jboss/datasources/ExampleDS) pointing to your DB.
Configure Hibernate or JPA settings so KIE Workbench can store runtime data there.
Example excerpt from standalone.xml:

xml
Copy
<subsystem xmlns="urn:jboss:domain:datasources:4.0">
    <datasources>
        <data-source jndi-name="java:jboss/datasources/ExampleDS" pool-name="ExampleDS" enabled="true" use-java-context="true">
            <connection-url>jdbc:postgresql://localhost:5432/kie_db</connection-url>
            <driver>postgresql</driver>
            <security>
                <user-name>kieuser</user-name>
                <password>kiepass</password>
            </security>
        </data-source>
        <drivers>
            <driver name="postgresql" module="org.postgresql">
                <xa-datasource-class>org.postgresql.xa.PGXADataSource</xa-datasource-class>
            </driver>
        </drivers>
    </datasources>
</subsystem>
4. Putting It All Together
Assets (DRL, .gdst, BPMN) are stored in a Git repository inside .niogit on the server. This is how the Workbench version-controls your project files.
Runtime data (process instances, tasks, logs, job schedules) goes into a relational database (Postgres, MySQL, Oracle, etc.) that you configure for KIE Workbench or KIE Server.
Why a DB? Because the BPM engine (jBPM or RHPAM) needs a transactionally consistent store for all running process instances, tasks, history, etc. The database also houses certain operational metadata for large projects (like user task data, persistence of job executor, etc.).
Summary:

Where are DRL/Decision Tables stored? In the internal Git repo (.niogit) on the file system, or an external Git if you set that up.
Which DBs can be used for metadata? Essentially any widely used relational DB that you can configure in the server’s data source (PostgreSQL, MySQL, Oracle, MSSQL, etc.).
That’s the complete picture of how KIE Workbench stores assets vs. how it stores operational metadata.






You said:
How to implement security in kie workbench
ChatGPT

Thought for a couple of seconds
Below is a step-by-step guide showing how to implement security in KIE Workbench (a.k.a. Business Central) so you can control user access, roles, and authentication. We’ll cover:

Overview of KIE Security
Default Security (Application Realm)
Setting Up Users and Roles (WildFly Example)
Role-Based Access in KIE Workbench
External Identity Management (LDAP, Keycloak, etc.)
Advanced Topics
<a name="overview"></a>

1. Overview of KIE Security
KIE Workbench (or Business Central) is a Java-based web application that uses Java EE container-managed security. That means:

Authentication (who you are) is delegated to the application server (e.g., WildFly) via security realms or external identity providers.
Authorization (what you can do) is handled by roles in KIE. For example, users with the “admin” role can do everything, while other roles have restricted access.
Key Points:

By default, KIE Workbench relies on basic HTTP authentication (or form-based) where credentials are verified against the ApplicationRealm in WildFly (or another app server realm).
You can create or import users and assign them roles, e.g., admin, rest-all, analyst, etc.
For more advanced or enterprise setups, you can integrate with LDAP or Keycloak so that your users and roles come from a central identity management system.
<a name="default-security"></a>

2. Default Security (Application Realm)
When you download and run KIE Workbench on WildFly (or EAP), there is typically a default configuration:

A standalone.xml (or similar) referencing the ApplicationRealm.
The Workbench app uses the container-based authentication approach to check the user’s credentials against that realm.
You manage users by editing application-users.properties and application-roles.properties or using the add-user.sh script.
In a demo environment, you might have a small number of users manually defined there. In production, you might move to an external realm.

<a name="users-roles"></a>

3. Setting Up Users and Roles (WildFly Example)
3.1 Add an Application User
Stop WildFly if it’s running.
Navigate to WILDFLY_HOME/bin.
Run:
bash
Copy
./add-user.sh
Choose b (Application user).
Enter a username and password when prompted.
Add the user to certain roles. For example:
sql
Copy
Please enter the roles associated with this user: admin, rest-all
or if you want additional roles (like kiemanager, kieserver), add them as well.
This updates two files in WILDFLY_HOME/standalone/configuration/:

application-users.properties (stores username & encrypted password)
application-roles.properties (maps the username to roles)
Example line in application-roles.properties:

css
Copy
kieuser=admin,rest-all
3.2 Restart and Test
Start WildFly again (./standalone.sh).
Open KIE Workbench (Business Central) at http://localhost:8080/business-central/.
Login with kieuser / the password you set.
If the user has the admin role, you’ll see the full Workbench capabilities.
<a name="rbac"></a>

4. Role-Based Access in KIE Workbench
KIE Workbench checks your roles via container-managed security. Here are some of the common roles:

admin or administrator: Full control over the Workbench (including viewing/editing all assets, managing projects).
rest-all: Access to the REST endpoints.
kiemanager: Typically for managing KIE Servers / Server Templates.
developer: May create and modify assets but have fewer privileges than admin.
analyst: May see certain projects or analytics, depending on your version.
Exactly which roles are used can vary by version or by your roles configuration in the security settings. For Red Hat Process Automation Manager, the official docs list roles like “kie-server”, “rhpamManager”, etc.

Controlling Access to Spaces/Projects:

In recent versions, you can define “teams” or “spaces,” which can be restricted to certain roles. For instance, only “admin” can see the “IT_Projects” space, while “analyst” can see “Analytics_Projects” space.
<a name="external-idm"></a>

5. External Identity Management (LDAP, Keycloak, etc.)
For enterprise or advanced setups, you likely don’t want to manage users in application-users.properties. Instead, you can configure:

LDAP Integration

Configure WildFly’s standalone.xml to reference an LDAP realm.
Map LDAP groups to KIE roles (e.g., LDAP group “DroolsAdmins” → role “admin”).
Keycloak SSO

Use Keycloak as an identity provider.
Install the Keycloak subsystem or Keycloak adapter in WildFly.
Configure your realm and client.
This approach allows Single Sign-On across multiple apps.
Basic Outline (Keycloak):

Install Keycloak and create a realm (e.g. “KIE-REALM”).
Create a client for “business-central” or “kie-server.”
Add user(s) in Keycloak, assign them to Keycloak roles or groups.
In WildFly, add the Keycloak adapter and configure a security domain that points to Keycloak.
Map Keycloak roles to KIE roles (e.g., “KIE_ADMIN” → “admin”).
Start the server, test login.
<a name="advanced-topics"></a>

6. Advanced Topics
Multitenancy: If you have multiple Spaces (a.k.a. “Organizations” in older versions), you can set different role constraints for each.
RBAC for KIE Server: If you also deploy a KIE Server for remote rule execution, you can protect it with roles like kie-server, rest-all, etc. The KIE Server can require a separate user with the “kie-server” role to connect to Workbench.
SSL/TLS: For secure communications, configure HTTPS on WildFly. Then your KIE Workbench login credentials are encrypted in transit.
Custom Auth Mechanisms: If you prefer a custom realm or a custom JAAS module, you can code that and point the container to it.
Summary
KIE Workbench uses standard Java container-managed security, typically in WildFly or EAP.
Create users in the ApplicationRealm (or an external realm) and assign roles.
Common Roles: admin, rest-all, kiemanager, kieserver, etc.
RBAC: The user’s roles determine which features, projects, spaces, or REST endpoints they can access in the Workbench.
LDAP / Keycloak: For enterprise SSO or advanced identity management, integrate the app server with an external provider and map groups → roles.
That’s how you implement security in KIE Workbench, from the basic built-in user-props approach to more advanced external identity providers.






You said:
how  to deploy kie workbech for production write complement deployment step
ChatGPT

Thought for 6 seconds
Below is a comprehensive, production-focused deployment guide for KIE Workbench (a.k.a. Business Central) on WildFly or Red Hat JBoss EAP. These steps assume you are moving beyond a simple development/demo setup and want a highly available, secure, and robust environment.

Note: Red Hat’s supported product is Red Hat Process Automation Manager (RHPAM), which provides Business Central and KIE Server with official support. The community version (Drools, jBPM) follows the same approach but without enterprise support and may differ slightly in naming.

Table of Contents
Pre-Requisites and Overview
Obtain the KIE Workbench WAR
Prepare the Application Server
Configure a Production Database
Configure Security and Users
Externalize Git Repository (Optional)
Tune Server Settings
Deploy the KIE Workbench WAR
Configure HTTPS / SSL (Recommended)
Set Up Clustering or HA (Optional)
Post-Deployment Verification
Ongoing Maintenance
<a name="prereqs"></a>

1. Pre-Requisites and Overview
You have a WildFly or JBoss EAP server (version typically >= 7.x).
You have Java 11 or Java 17 (depending on your KIE version requirements).
You have the KIE Workbench (Business Central) WAR file (e.g., business-central.war) from either:
Red Hat Process Automation Manager (official product)
Drools / jBPM community distribution
You want to run with an external database (e.g., PostgreSQL, Oracle, MySQL) for runtime data and job execution logs (not the embedded H2).
You want secure authentication (e.g., container-managed security with roles) and possibly SSL.
<a name="obtain-war"></a>

2. Obtain the KIE Workbench WAR
Red Hat Customers: Download rhpam-business-central.war from the Red Hat Customer Portal.
Community: Obtain business-central-<version>.war from the Drools/jBPM website or by building from source.
(Optional) Rename the WAR to something like business-central.war if needed.
<a name="prepare-wildfly"></a>

3. Prepare the Application Server
Download and unzip WildFly or JBoss EAP to your production server.
Decide whether you’ll run in:
Standalone mode (simpler for single-node)
Domain mode (useful for multi-node clusters, shared config).
Set environment variables if needed:
JAVA_HOME pointing to your JDK or JRE.
Possibly JBOSS_HOME or WILDFLY_HOME.
Test by running standalone.sh (or .bat) and checking http://localhost:8080.
<a name="configure-db"></a>

4. Configure a Production Database
Why?
By default, KIE Workbench uses the embedded H2 for the jBPM runtime data. This is not recommended for production because it’s not robust for scaling, backups, or concurrency.

Steps:

Install a database server (e.g., PostgreSQL, MySQL, Oracle, SQL Server) or ensure you have an existing DB instance.
Create a database/schema (e.g., kie_db).
Add JDBC driver to WildFly:
Copy the driver JAR to WILDFLY_HOME/standalone/deployments/ or create a module in WILDFLY_HOME/modules/org/postgresql/main/ (example for Postgres).
In standalone.xml, define a driver element and a datasource.
Configure a datasource in standalone.xml (or use the WildFly admin console):
xml
Copy
<subsystem xmlns="urn:jboss:domain:datasources:4.0">
  <datasources>
    <data-source jndi-name="java:jboss/datasources/KIEDataSource" pool-name="KIEDataSource" enabled="true" use-java-context="true">
      <connection-url>jdbc:postgresql://dbhost:5432/kie_db</connection-url>
      <driver>postgresql</driver>
      <security>
        <user-name>kieuser</user-name>
        <password>kiepass</password>
      </security>
    </data-source>
    <drivers>
      <driver name="postgresql" module="org.postgresql">
        <xa-datasource-class>org.postgresql.xa.PGXADataSource</xa-datasource-class>
      </driver>
    </drivers>
  </datasources>
</subsystem>
In your Workbench configuration (via system properties or environment variables), set:
org.kie.persistence.ds = java:jboss/datasources/KIEDataSource
Possibly org.kie.server.persistence.dialect = org.hibernate.dialect.PostgreSQLDialect (change based on DB).
<a name="configure-security"></a>

5. Configure Security and Users
5.1 Container-Managed Security
Create a management user (for WildFly admin console) if desired:
bash
Copy
cd $WILDFLY_HOME/bin
./add-user.sh
a) for management user
Create an application user (for KIE login):
bash
Copy
./add-user.sh
b) for application user
Provide username (e.g., kiewbUser), password, and roles, e.g., admin,rest-all.
Result: application-users.properties and application-roles.properties get updated. The user has roles that KIE recognizes (admin, rest-all, analyst, kiemanager, etc.).

5.2 External Identity (Optional)
For production setups, you often integrate with:

LDAP / Active Directory
Keycloak for SSO
This involves configuring a security realm in WildFly’s standalone.xml referencing your LDAP/SSO, then mapping groups to KIE roles. The approach is more advanced, but ensures enterprise-grade authentication/authorization.

<a name="external-git"></a>

6. Externalize Git Repository (Optional)
By default, KIE Workbench keeps your assets (DRL, BPMN, Decision Tables) in a local .niogit folder. In production, you might:

Use an external Git server (e.g., GitHub, GitLab) for better CI/CD.
Or backup the .niogit folder regularly.
Configure KIE Workbench to push/pull from a remote repo for version control.
This ensures you don’t lose rule artifacts if the server fails.

<a name="tune-server"></a>

7. Tune Server Settings
Production typically means:

Configure JVM Heap: Adjust -Xmx and -Xms in standalone.conf or environment variables. For example:
diff
Copy
-Xms2g -Xmx4g -XX:MaxPermSize=256m
Enable or tune the executor (jobs, timers).
Turn on appropriate logging (log to external system if needed).
Disable debug or dev-specific features.
Review the server’s concurrency settings or thread pools, especially if you expect high load.
<a name="deploy-war"></a>

8. Deploy the KIE Workbench WAR
You have two main approaches:

8.1 Copy/Move the WAR to Deployments
Stop WildFly:

bash
Copy
$WILDFLY_HOME/bin/jboss-cli.sh --connect command=:shutdown
or just close it from the console.

Copy business-central.war into:

bash
Copy
$WILDFLY_HOME/standalone/deployments/
Start WildFly:

bash
Copy
$WILDFLY_HOME/bin/standalone.sh
Check server.log for a successful deployment message.

8.2 Use the Admin Console
Start WildFly.
Navigate to http://localhost:9990.
Log in with the management user.
Go to Deployments → Upload Deployment.
Choose business-central.war.
Click Enable.
<a name="configure-ssl"></a>

9. Configure HTTPS / SSL (Recommended)
Obtain or generate a valid certificate (e.g., from your corporate CA).

Import it into a Java keystore.

Edit standalone.xml to enable an HTTPS connector, for example:

xml
Copy
<subsystem xmlns="urn:jboss:domain:web:4.0">
    <connector name="https" protocol="HTTP/1.1" scheme="https" socket-binding="https" secure="true">
        <ssl name="ssl" key-alias="myalias" password="changeit" certificate-key-file="/path/to/keystore.jks" protocol="TLSv1.2"/>
    </connector>
</subsystem>
Access KIE Workbench via https://yourhost:8443/business-central/.

<a name="ha-cluster"></a>

10. Set Up Clustering or HA (Optional)
For higher availability or load balancing:

Domain Mode with multiple WildFly/EAP hosts.
A shared database for the jBPM runtime data.
A shared or external Git repository for your KIE projects.
A load balancer or reverse proxy (e.g., Apache, NGINX, or mod_cluster) in front of the cluster nodes.
Configure session replication if needed.
This ensures that if one node goes down, another can continue serving the KIE Workbench.

<a name="post-deploy"></a>

11. Post-Deployment Verification
Check logs in $WILDFLY_HOME/standalone/log/server.log. Look for INFO lines indicating a successful deployment of business-central.war.
Navigate to:
arduino
Copy
http://<server>:8080/business-central/
or if HTTPS is configured:
arduino
Copy
https://<server>:8443/business-central/
Login with your application user credentials.
Create a test project or import a sample project.
Build & Deploy to ensure the database and everything else is functioning.
<a name="maintenance"></a>

12. Ongoing Maintenance
Backup Strategy:
Database: regular backups, snapshots, or replication.
.niogit folder (if using embedded Git): regularly backup or push to external Git.
Logging/Monitoring:
Use JBoss/WildFly logs for errors or warnings.
Integrate with corporate monitoring (e.g., Prometheus, Splunk, ELK).
Security Patches:
Keep the app server and Java up to date.
Scaling:
If load increases, add more nodes to a cluster.
Possibly separate KIE Workbench from KIE Servers (since Workbench is typically for design time, KIE Servers for runtime).
Final Recap
Get the KIE Workbench WAR (community or Red Hat distribution).
Install WildFly/EAP in production mode (with external DB, recommended security realm).
Configure your data source in standalone.xml for persistent BPM data.
Set up users/roles via the add-user.sh script or integrate with LDAP/Keycloak.
Deploy the WAR (in deployments/ or via the admin console).
Secure with SSL/HTTPS and test.
(Optional) Set up HA (domain mode, load balancer, shared DB).
Backup your .niogit and DB for production resilience.
Following these steps will give you a stable, secure, and scalable production deployment of KIE Workbench.






You said:
How to test and deploy rules in kie workbench write all steps, I am more interested in drl rule testing and decision guided rule testing
ChatGPT

Thought for 9 seconds
Below is a step-by-step guide on how to test and deploy both DRL rules and Guided Decision Tables in KIE Workbench (sometimes called Business Central). We will cover:

Setting Up the Project
Creating or Uploading DRL Files
Creating Guided Decision Tables
Testing Rules in KIE Workbench
4.1 Scenario Testing (Test Scenario / Scenario Simulation)
4.2 Previewing the Generated DRL
Building & Deploying
External Testing Approaches
<a name="step1"></a>

1. Setting Up the Project
Log in to KIE Workbench (Business Central).
Navigate to Design → Projects (menu label may vary).
Click New Project (or Create Project).
Group ID: com.mycompany
Artifact ID: my-rules-project
Version: 1.0.0-SNAPSHOT
Click Create & Import.
You now have an empty project. Inside this project, you can store DRL files, Guided Decision Tables (.gdst), BPMN processes, test scenarios, etc.

<a name="step2"></a>

2. Creating or Uploading DRL Files
If you already have DRL files, you can upload them directly. If not, you can create them in the Workbench.

2.1 Create a New DRL
Within your project, click Add Asset → Rule (or “DRL file”).

Give it a name (e.g. LoanRules).

In the DRL editor, write or paste your rules:

java
Copy
rule "High Credit Score Approval"
when
    $applicant : Applicant( creditScore >= 700, income >= 50000 )
    $loan : Loan( amount <= 200000 )
then
    $loan.setStatus("APPROVED");
    System.out.println("Rule fired: High Credit Score Approval");
end
Save the file. The DRL is now version-controlled in KIE Workbench.

2.2 Upload an Existing DRL
Click Add Asset → Upload.
Select the .drl file from your local machine.
Confirm and upload it to your project.
Either way, you now have a DRL file in your project.

<a name="step3"></a>

3. Creating Guided Decision Tables
Guided Decision Tables (GDT) are .gdst files that KIE Workbench translates into DRL behind the scenes.

Click Add Asset → Guided Decision Table.

Name it (e.g., LoanApprovalTable).

Pick “Spreadsheet-like” or “Extended” (depending on your version).

Define condition columns (e.g. Applicant.creditScore >= ?), action columns (e.g. loanDecision.setDecision("...")), and so on.

Add rows for specific rules. For example:

Row	creditScore ≥	income ≥	amount ≤	Then decision
1	700	50000	200000	APPROVED
2	600	30000	100000	CONDITIONAL
3	(blank)	(blank)	(blank)	DENIED
Click Save.

KIE Workbench generates DRL from the table automatically. You can see it in the Source tab.

<a name="step4"></a>

4. Testing Rules in KIE Workbench
Testing directly in KIE Workbench usually involves creating a Scenario test (called “Test Scenario” in older versions, “Scenario Simulation” in newer versions). This lets you define input data (facts) and expected results, run the scenario, and see pass/fail outcomes.

<a name="scenario-testing"></a>

4.1 Scenario Testing (Test Scenario / Scenario Simulation)
In your project, click Add Asset → Test Scenario (or “Scenario Simulation”).
Name it (e.g., LoanApprovalScenario).
Configure the scenario:
Given (Input): define an Applicant object with fields: creditScore, income, etc.
And a Loan object with amount.
When the rules are fired.
Then (Expected Outcome): check that loan.status or loanDecision.decision is "APPROVED" (or whatever you expect).
Example:

Given: Applicant( creditScore=750, income=60000 ), Loan( amount=150000 )
Expect: loan.status == "APPROVED" or loanDecision.decision == "APPROVED"
Run the scenario.
If the test result (the actual outcome) matches the expected outcome, it passes. If not, it fails and shows a discrepancy.
This approach is convenient for business users to test DRL or Guided Decision Tables without writing Java JUnit tests.

<a name="preview-drl"></a>

4.2 Previewing the Generated DRL
For DRL files, you already see them in the DRL editor.
For Guided Decision Tables, open the .gdst, switch to Source or View Source. The rules appear in standard DRL form.
You can also see the resulting DRL in the Project Explorer if you build the project and check the target folder (in advanced setups).
<a name="step5"></a>

5. Building & Deploying
Once your rules pass local tests:

Go to the Project Editor (the screen with pom.xml, dependencies, etc.).
Click Build & Deploy (top-right in many versions).
This compiles your DRL/GDT into a KJAR (knowledge JAR).
The KJAR is installed in the KIE Workbench’s Maven repository.
Note:

If you also have a KIE Server connected (via “Servers” / “Execution Servers” in Business Central), you can configure a container for your newly built KJAR. The KIE Server will run the rules at runtime.
Once deployed, your rules are ready to be executed either inside Business Central’s test scenario or from external clients via KIE Server (REST calls, JMS calls) or by using the embedded Drools engine in a Java application.

<a name="step6"></a>

6. External Testing Approaches
Often you’ll want to:

Integrate your rules with a Java application or microservice.
Test from external code to ensure real-world usage matches your scenario tests.
6.1 Testing from a Java Application
In your pom.xml, reference the KJAR as a dependency:

xml
Copy
<dependency>
    <groupId>com.mycompany</groupId>
    <artifactId>my-rules-project</artifactId>
    <version>1.0.0-SNAPSHOT</version>
</dependency>
Create a KieContainer and KieSession:

java
Copy
KieServices ks = KieServices.Factory.get();
KieContainer kContainer = ks.newKieContainer(
    ks.newReleaseId("com.mycompany", "my-rules-project", "1.0.0-SNAPSHOT")
);
KieSession kSession = kContainer.newKieSession();

Applicant applicant = new Applicant("John", 750, 60000);
Loan loan = new Loan(150000);

kSession.insert(applicant);
kSession.insert(loan);
kSession.fireAllRules();

System.out.println("Loan status: " + loan.getStatus());
Run the app, verify the outcome (“APPROVED” etc.).

6.2 Using KIE Server REST API
If your KIE Workbench is managing a KIE Server:

Deploy your project to a KIE Server container.

Send a JSON payload with your facts to the KIE Server’s REST endpoint, e.g.:

bash
Copy
POST http://<host>:8080/kie-server/services/rest/server/containers/instances/myContainerID
Content-Type: application/json

{
  "lookup": "defaultKieSession",
  "commands": [
    {
      "insert": {
        "object": {
          "com.mycompany.Applicant": {
            "name": "Jane",
            "creditScore": 780,
            "income": 65000
          }
        },
        "out-identifier": "applicant"
      }
    },
    {
      "insert": {
        "object": {
          "com.mycompany.Loan": {
            "amount": 120000
          }
        },
        "out-identifier": "loan"
      }
    },
    {
      "fire-all-rules": {}
    }
  ]
}
Check the response JSON to see updated fields (like loan.status).

This approach is ideal if your main app is in another language (Python, .NET, etc.) but you still want to leverage the same DRL or Decision Table from KIE Workbench.

Final Recap
Create a project in KIE Workbench.
Add your rules as DRL or Guided Decision Tables.
Test them using Scenario Tests (Test Scenarios or Scenario Simulation) inside the Workbench.
Build & Deploy to produce a KJAR artifact.
For external usage, either reference the KJAR from Java or deploy it on a KIE Server and call via REST.
This covers both DRL rule testing and Guided Decision Table testing, plus how to deploy them in a typical KIE Workbench environment.






You said:
how to configure  git so that it store all asset in git repo, write all steps
ChatGPT

Thought for 9 seconds
Below is a step-by-step guide on how to set up KIE Workbench (Business Central) so that your project assets (DRL files, Guided Decision Tables, BPMN, etc.) are stored in Git—either by cloning your KIE Workbench-managed Git repository to an external Git server or importing from an existing external Git repo.

In KIE Workbench, every Space (and each project within that Space) corresponds to a Git repository in the underlying .niogit folder. By default, this Git repo is internal to the Workbench. If you want to keep your assets in a separate or remote Git service (e.g., GitHub, GitLab, internal Git server), you can configure a push/pull workflow.

Table of Contents
High-Level Overview
Check or Create Your KIE Space and Project
Locate the KIE Workbench Git URL
Clone the Repository Externally
Add a Remote to an External Git Server
Push Changes to the External Git Repository
Pull Changes Back into KIE Workbench
Alternate: Creating a Space from an External Git Repo
Notes on Automatic Mirroring
Tips and Best Practices
<a name="overview"></a>

1. High-Level Overview
By Default: KIE Workbench stores all assets in an internal Git structure under the \.niogit folder on the server.
Expose or Mirror: You can clone that internal Git repo externally and then push it to another Git server (e.g., GitHub, GitLab).
Two-Way Sync: You can pull changes from your external Git repo back into Workbench so they show up in the UI.
Spaces: Each Space in KIE Workbench is effectively a Git “organization” containing one or more Git repos (one per project).
<a name="step1"></a>

2. Check or Create Your KIE Space and Project
Log in to KIE Workbench.
Click Design → Spaces (or “Projects,” depending on version).
If needed, create a new Space (like MySpace) or use an existing one.
Inside that Space, create or open a Project (e.g., my-rules-project).
Under the covers, KIE Workbench creates a Git repository named something like my-rules-project.git in the .niogit folder.

<a name="step2"></a>

3. Locate the KIE Workbench Git URL
For each Space and Project:

Navigate to Settings or Project Explorer for the project.
Look for the Git URL.
Sometimes under Project Settings → Details.
Or in the Administration → Repositories view.
You might see something like:

perl
Copy
http://<username>:<password>@localhost:8080/business-central/git/MySpace/my-rules-project.git
or, in older versions, something like git:// or ssh:// if you set it up that way.

Note: The exact URL format depends on your Workbench version and security settings.

<a name="step3"></a>

4. Clone the Repository Externally
From your local machine (or CI/CD server), do:

bash
Copy
git clone http://<user>:<pass>@localhost:8080/business-central/git/MySpace/my-rules-project.git
cd my-rules-project
Now you have a local copy of the same Git repo that KIE Workbench uses internally.

<a name="step4"></a>

5. Add a Remote to an External Git Server
If you have an external Git service (GitHub, GitLab, corporate Git server), create a new empty repository there. Let’s say the remote URL is something like:

perl
Copy
https://github.com/myorg/my-rules-project.git
or maybe your internal server:

perl
Copy
https://git.mycompany.com/repos/my-rules-project.git
In your local clone (the one you just cloned from KIE Workbench), add that external Git remote:

bash
Copy
cd my-rules-project
git remote add external https://github.com/myorg/my-rules-project.git
(You can name the remote something like “origin” if you want, but you already have an “origin” pointing to the KIE server. So “external” or “upstream” is usually better.)

<a name="step5"></a>

6. Push Changes to the External Git Repository
Make sure everything is committed locally (it should be, if you cloned from KIE).
Push to the external remote:
bash
Copy
git push external master
or

bash
Copy
git push external main
(Depending on which branch name your KIE repo uses, typically “master.”)

Now your KIE Workbench project is also stored in GitHub (or whichever external service you use).

<a name="step6"></a>

7. Pull Changes Back into KIE Workbench
If you or a teammate make changes in the external Git repo, you can pull them back into the KIE-hosted repo so they appear in the Workbench UI.

One approach:

In your local clone (which points to both the KIE Workbench “origin” and the “external” remote), run:
bash
Copy
git pull external master
Then push them to the KIE Workbench’s repo:
bash
Copy
git push origin master
Refresh your Workbench UI. The new files or updates should appear.
Alternatively, you can do merges or rebase as needed. The point is to keep the KIE internal Git and your external Git in sync via your local clone.

Important: KIE Workbench doesn’t automatically know about changes that happen outside of it unless you push them into its internal Git.

<a name="step7"></a>

8. Alternate: Creating a Space from an External Git Repo
If you already have an existing Git repository with your rules, you can import it into KIE Workbench:

In KIE Workbench, go to Design → Spaces.
Click Import Project (or “Add Project”), then Clone repository.
Provide the external Git URL (e.g., https://github.com/myorg/my-rules-project.git).
If the repository contains a valid pom.xml and the required structure, KIE should detect it as a Maven project.
Click OK to import.
KIE Workbench will clone that external repo into its .niogit folder, effectively creating a new space/project from it.

<a name="step8"></a>

9. Notes on Automatic Mirroring
Some older versions of KIE Workbench or custom plugins mention a mirror feature to automatically push changes to an external repo. However:

Official or built-in auto-sync is not fully integrated in recent versions. Usually you must manage Git remotes manually using the above approach.
If you require continuous or trigger-based synchronization, you can set up a CI job or webhook to perform periodic pull/push from the .niogit repository.
<a name="step9"></a>

10. Tips and Best Practices
Keep consistent naming for branches. KIE typically uses master by default.
Use feature branches if your team’s Git workflow requires it. KIE can read from branches, but it can get more complicated.
Always push changes from your local clone to both KIE and external if you want them fully synchronized.
Enable authentication on KIE’s Git server so only authorized users can push to or clone from the .niogit repos.
Backup your .niogit folder if you rely on KIE as the “source of truth.” Alternatively, treat your external Git server as the ultimate reference.
Final Recap
KIE Workbench internally manages rules in a Git repo under .niogit.
To store (or backup) these assets in an external Git repository, clone the KIE repo and push it to your external remote.
Pull changes back into KIE Workbench when external modifications happen.
Or, import an existing external Git repo into KIE Workbench if you already have a repository with rules.
For automation, consider a script or CI job that keeps .niogit and your external Git server in sync.
This way, all your DRL, Guided Decision Tables, BPMN files, etc. are safely version-controlled in your preferred Git environment—while still being editable and executable via KIE Workbench.