package rules;

import com.myorg.Loan;

/*
 * Simple rule: If Loan.amount <= 0, mark status = "REJECTED"
 * Otherwise, mark status = "APPROVED"
 */
rule "Reject if negative or zero amount"
  when
    $loan: Loan( amount <= 0 )
  then
    System.out.println("Rule triggered: Rejecting Loan with ID: " + $loan.loanId());
    $loan.status_$eq("REJECTED"); // Scala uses status_$eq internally for setStatus
end

rule "Approve if positive amount"
  when
    $loan: Loan( amount > 0 )
  then
    System.out.println("Rule triggered: Approving Loan with ID: " + $loan.loanId());
    $loan.status_$eq("APPROVED");
end
----------------

package com.myorg

case class Loan(var loanId: String, var amount: Int) {
  // We keep a status field with a default "NEW"
  var status: String = "NEW"

  // For Drools property-based access,
  // we ensure the following names:
  def getLoanId: String = loanId
  def setLoanId(id: String): Unit = { loanId = id }

  def getAmount: Int = amount
  def setAmount(a: Int): Unit = { amount = a }

  def getStatus: String = status
  def setStatus(s: String): Unit = { status = s }
}
------------------------------------

package com.myorg

import org.apache.spark.sql.SparkSession
import org.kie.api.KieServices
import org.kie.api.builder.{KieFileSystem, Results}
import org.kie.internal.io.ResourceFactory
import scala.collection.JavaConverters._

object DroolsSparkExample {
  def main(args: Array[String]): Unit = {

    // 1) Initialize Spark
    val spark = SparkSession.builder()
      .appName("DroolsSparkExample")
      .master("local[*]")  // For local testing
      .getOrCreate()

    // 2) Build Drools KieBase or KieContainer on driver
    val ks = KieServices.Factory.get()
    val kfs = ks.newKieFileSystem()

    // Load the DRL from resources (e.g. "rules/sample.drl")
    val drlResource = ResourceFactory.newClassPathResource("rules/sample.drl")
    kfs.write(drlResource)

    val kb = ks.newKieBuilder(kfs).buildAll()
    val results: Results = kb.getResults()
    if (results.hasMessages(org.kie.api.builder.Message.Level.ERROR)) {
      println("!!! Drools Error !!! " + results.getMessages)
      throw new RuntimeException("Failed to build KieBase from DRL")
    }

    val kContainer = ks.newKieContainer(ks.getRepository.getDefaultReleaseId)
    val kBase = kContainer.getKieBase()

    // 3) Broadcast the KieBase to executors
    val broadcastKBase = spark.sparkContext.broadcast(kBase)

    // 4) Create an RDD of loans
    val loansRDD = spark.sparkContext.parallelize(Seq(
      Loan("L001", -100),
      Loan("L002", 0),
      Loan("L003", 1000),
      Loan("L004", 500)
    ))

    // 5) Apply Drools rules
    // We'll map each partition, building a new KieSession per partition
    val resultRDD = loansRDD.mapPartitions { partitionIter =>
      // For each partition, create a KieSession
      val localKieBase = broadcastKBase.value
      val kSession = localKieBase.newKieSession()

      // apply the rules to each Loan
      val updatedLoans = partitionIter.map { loan =>
        kSession.insert(loan)
        // We can fireAllRules after each insert or after collecting them all
        kSession.fireAllRules()
        loan
      }.toList

      kSession.dispose()
      updatedLoans.iterator
    }

    // Collect or show the results
    val results = resultRDD.collect()
    results.foreach { l =>
      println(s"LoanId=${l.loanId}, Amount=${l.amount}, Status=${l.status}")
    }

    spark.stop()
  }
}
