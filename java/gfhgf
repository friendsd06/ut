@Service
@RequiredArgsConstructor
@Slf4j
public class NRValidationServiceImpl {

    private static final String MULTI_COL_DELIMITER = "|";

    private final QueryUtil                queryUtil;
    private final OtelService              otelService;
    private final StorageServiceProcessor  storageService;
    private final ConfigurationHelper      config;   // example of other injected helpers

    /**
     * Verifies that every value in {@code validationColumn} exists only once
     * in {@code request.getData()} and is recognised by the reference table.
     *
     * @return {@code true} if all values are valid; {@code false} otherwise
     * @throws ValidationException   for business-rule violations
     * @throws StorageAccessException if the reference-code lookup fails
     */
    public boolean validatePositionCode(NewRecordRequest request,
                                        String validationColumn,
                                        String validationTable)
            throws ValidationException, StorageAccessException {

        // ─── 0.  Start trace ───────────────────────────────────────────────
        otelService.startSpan(request.getRequestId(), "position-code-validation");

        try {
            // ─── 1.  Fast-path exit for AMU ────────────────────────────────
            if ("AMU".equals(request.getRequestType())) {
                return true;
            }

            // ─── 2.  Route to the right strategy ──────────────────────────
            if (isMultiColumn(validationColumn)) {
                return validateMultiColumn(request, validationColumn, validationTable);
            }

            return validateSingleColumn(request, validationColumn, validationTable);
        }
        finally {
            // ─── 3.  Always close the span ────────────────────────────────
            otelService.endSpan();
        }
    }

    // ======================================================================
    //                          ↓↓↓  HELPERS  ↓↓↓
    // ======================================================================

    /** Composite keys like "REGION|COUNTRY" are treated as multi-column. */
    private boolean isMultiColumn(String columnSpec) {
        return columnSpec.contains(MULTI_COL_DELIMITER);
    }

    // ───────────────────────────────────────────────────────────────────────
    //  A. MULTI-COLUMN  (composite key)  VALIDATION
    // ───────────────────────────────────────────────────────────────────────
    private boolean validateMultiColumn(NewRecordRequest request,
                                        String columnSpec,
                                        String validationTable)
            throws ValidationException, StorageAccessException {

        /* 1. Build the composite key for every record once */
        request.getData().stream()
               .filter(rec -> validationTable.equalsIgnoreCase(rec.getEntity()))
               .flatMap(rec -> rec.getAttributeData().stream())
               .forEach(attr -> {
                   if (queryUtil.multiColumnValuesValidation(attr, columnSpec)) {
                       String joined = queryUtil.concatenateMulticolumnValues(attr, columnSpec);
                       attr.put(FRM_MULTI_COLUMN_KEY, joined);
                   }
               });

        /* 2. Check duplicates & existence in reference store */
        return validateMultipleColumnsForDuplicates(request, validationTable, columnSpec);
    }

    // ───────────────────────────────────────────────────────────────────────
    //  B. SINGLE-COLUMN  VALIDATION
    // ───────────────────────────────────────────────────────────────────────
    private boolean validateSingleColumn(NewRecordRequest request,
                                         String columnName,
                                         String validationTable)
            throws ValidationException, StorageAccessException {

        /* 1. Fetch the whitelist once */
        Set<String> validCodes = new HashSet<>(
            getLoanPstnCdFromRequest(request, validationTable, columnName)
        );

        if (validCodes.isEmpty()) {
            // Nothing to validate (rare but possible) – treat as pass
            return true;
        }

        /* 2. Walk every attribute; flag invalid ones */
        boolean allValid = true;

        for (var record : request.getData()) {
            for (var attr : record.getAttributeData()) {

                String value = attr.get(columnName);
                if (validCodes.contains(value)) {
                    // happy path – keep value as-is
                    continue;
                }

                // mark invalid
                String msg = value + LOAN_VALIDATION_DELIMITER + LOAN_VALIDATION_ERROR_MSG;
                attr.put(columnName, msg);
                allValid = false;
            }
        }
        return allValid;
    }
}


=========================

What validateMultiColumn does – step by step
Goal:
Make sure every composite key (a value made by joining several columns with “|”)

is built correctly for every row, and

is unique + recognised by the reference table.

java
Copy
Edit
private boolean validateMultiColumn(NewRecordRequest request,
                                    String columnSpec,
                                    String validationTable)
        throws ValidationException, StorageAccessException {
    /* 1 */                          // (see numbered notes below)
    request.getData().stream()
           .filter(rec -> validationTable.equalsIgnoreCase(rec.getEntity()))
           .flatMap(rec -> rec.getAttributeData().stream())
           .forEach(attr -> {
               if (queryUtil.multiColumnValuesValidation(attr, columnSpec)) {
                   String joined = queryUtil.concatenateMulticolumnValues(attr, columnSpec);
                   attr.put(FRM_MULTI_COLUMN_KEY, joined);
               }
           });

    /* 2 */
    return validateMultipleColumnsForDuplicates(request, validationTable, columnSpec);
}
🧭 Number-by-number walk-through
#	Code fragment	Plain-English explanation
1	request.getData().stream()	Start with every record in the incoming request.
.filter(rec -> validationTable.equalsIgnoreCase(rec.getEntity()))	Keep only the records that belong to the table we’re validating (e.g. “LOAN”).
.flatMap(rec -> rec.getAttributeData().stream())	Dive one level deeper: turn each record’s attribute map into a flat stream so we can touch each column value individually.
.forEach(attr -> { … })	Handle every attribute map one by one.
if (queryUtil.multiColumnValuesValidation(attr, columnSpec))	Check that every piece of the composite key exists and is non-empty.
*(columnSpec is something like `"REGION
String joined = queryUtil.concatenateMulticolumnValues(attr, columnSpec);	Join those pieces into one string (e.g. `"NA
attr.put(FRM_MULTI_COLUMN_KEY, joined);	Store that joined key back into the attribute map under a temporary field so later code can see it.
2	return validateMultipleColumnsForDuplicates(...);	Hand the request off to another helper that:
• looks for duplicates of the joined key across all rows, and
• checks the joined keys against a reference list in the database/cache.

The helper returns true if every composite key is unique and valid.

🖼️ Tiny flow picture
mermaid
Copy
Edit
flowchart LR
    Start -->|stream| Filter[keep only rows for validationTable]
    Filter --> FlatMap[break into attribute maps]
    FlatMap --> ValidatePieces[check every part present]
    ValidatePieces -->|OK| Join[join values -> "FRM_MULTI_COLUMN_KEY"]
    Join --> DuplicateCheck[validateMultipleColumnsForDuplicates]
    DuplicateCheck --> Result((true/false))