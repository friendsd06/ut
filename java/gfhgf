@Service
@RequiredArgsConstructor
@Slf4j
public class NRValidationServiceImpl {

    private static final String MULTI_COL_DELIMITER = "|";

    private final QueryUtil                queryUtil;
    private final OtelService              otelService;
    private final StorageServiceProcessor  storageService;
    private final ConfigurationHelper      config;   // example of other injected helpers

    /**
     * Verifies that every value in {@code validationColumn} exists only once
     * in {@code request.getData()} and is recognised by the reference table.
     *
     * @return {@code true} if all values are valid; {@code false} otherwise
     * @throws ValidationException   for business-rule violations
     * @throws StorageAccessException if the reference-code lookup fails
     */
    public boolean validatePositionCode(NewRecordRequest request,
                                        String validationColumn,
                                        String validationTable)
            throws ValidationException, StorageAccessException {

        // ─── 0.  Start trace ───────────────────────────────────────────────
        otelService.startSpan(request.getRequestId(), "position-code-validation");

        try {
            // ─── 1.  Fast-path exit for AMU ────────────────────────────────
            if ("AMU".equals(request.getRequestType())) {
                return true;
            }

            // ─── 2.  Route to the right strategy ──────────────────────────
            if (isMultiColumn(validationColumn)) {
                return validateMultiColumn(request, validationColumn, validationTable);
            }

            return validateSingleColumn(request, validationColumn, validationTable);
        }
        finally {
            // ─── 3.  Always close the span ────────────────────────────────
            otelService.endSpan();
        }
    }

    // ======================================================================
    //                          ↓↓↓  HELPERS  ↓↓↓
    // ======================================================================

    /** Composite keys like "REGION|COUNTRY" are treated as multi-column. */
    private boolean isMultiColumn(String columnSpec) {
        return columnSpec.contains(MULTI_COL_DELIMITER);
    }

    // ───────────────────────────────────────────────────────────────────────
    //  A. MULTI-COLUMN  (composite key)  VALIDATION
    // ───────────────────────────────────────────────────────────────────────
    private boolean validateMultiColumn(NewRecordRequest request,
                                        String columnSpec,
                                        String validationTable)
            throws ValidationException, StorageAccessException {

        /* 1. Build the composite key for every record once */
        request.getData().stream()
               .filter(rec -> validationTable.equalsIgnoreCase(rec.getEntity()))
               .flatMap(rec -> rec.getAttributeData().stream())
               .forEach(attr -> {
                   if (queryUtil.multiColumnValuesValidation(attr, columnSpec)) {
                       String joined = queryUtil.concatenateMulticolumnValues(attr, columnSpec);
                       attr.put(FRM_MULTI_COLUMN_KEY, joined);
                   }
               });

        /* 2. Check duplicates & existence in reference store */
        return validateMultipleColumnsForDuplicates(request, validationTable, columnSpec);
    }

    // ───────────────────────────────────────────────────────────────────────
    //  B. SINGLE-COLUMN  VALIDATION
    // ───────────────────────────────────────────────────────────────────────
    private boolean validateSingleColumn(NewRecordRequest request,
                                         String columnName,
                                         String validationTable)
            throws ValidationException, StorageAccessException {

        /* 1. Fetch the whitelist once */
        Set<String> validCodes = new HashSet<>(
            getLoanPstnCdFromRequest(request, validationTable, columnName)
        );

        if (validCodes.isEmpty()) {
            // Nothing to validate (rare but possible) – treat as pass
            return true;
        }

        /* 2. Walk every attribute; flag invalid ones */
        boolean allValid = true;

        for (var record : request.getData()) {
            for (var attr : record.getAttributeData()) {

                String value = attr.get(columnName);
                if (validCodes.contains(value)) {
                    // happy path – keep value as-is
                    continue;
                }

                // mark invalid
                String msg = value + LOAN_VALIDATION_DELIMITER + LOAN_VALIDATION_ERROR_MSG;
                attr.put(columnName, msg);
                allValid = false;
            }
        }
        return allValid;
    }
}


=========================

What validateMultiColumn does – step by step
Goal:
Make sure every composite key (a value made by joining several columns with “|”)

is built correctly for every row, and

is unique + recognised by the reference table.

java
Copy
Edit
private boolean validateMultiColumn(NewRecordRequest request,
                                    String columnSpec,
                                    String validationTable)
        throws ValidationException, StorageAccessException {
    /* 1 */                          // (see numbered notes below)
    request.getData().stream()
           .filter(rec -> validationTable.equalsIgnoreCase(rec.getEntity()))
           .flatMap(rec -> rec.getAttributeData().stream())
           .forEach(attr -> {
               if (queryUtil.multiColumnValuesValidation(attr, columnSpec)) {
                   String joined = queryUtil.concatenateMulticolumnValues(attr, columnSpec);
                   attr.put(FRM_MULTI_COLUMN_KEY, joined);
               }
           });

    /* 2 */
    return validateMultipleColumnsForDuplicates(request, validationTable, columnSpec);
}
🧭 Number-by-number walk-through
#	Code fragment	Plain-English explanation
1	request.getData().stream()	Start with every record in the incoming request.
.filter(rec -> validationTable.equalsIgnoreCase(rec.getEntity()))	Keep only the records that belong to the table we’re validating (e.g. “LOAN”).
.flatMap(rec -> rec.getAttributeData().stream())	Dive one level deeper: turn each record’s attribute map into a flat stream so we can touch each column value individually.
.forEach(attr -> { … })	Handle every attribute map one by one.
if (queryUtil.multiColumnValuesValidation(attr, columnSpec))	Check that every piece of the composite key exists and is non-empty.
*(columnSpec is something like `"REGION
String joined = queryUtil.concatenateMulticolumnValues(attr, columnSpec);	Join those pieces into one string (e.g. `"NA
attr.put(FRM_MULTI_COLUMN_KEY, joined);	Store that joined key back into the attribute map under a temporary field so later code can see it.
2	return validateMultipleColumnsForDuplicates(...);	Hand the request off to another helper that:
• looks for duplicates of the joined key across all rows, and
• checks the joined keys against a reference list in the database/cache.

The helper returns true if every composite key is unique and valid.

🖼️ Tiny flow picture
mermaid
Copy
Edit
flowchart LR
    Start -->|stream| Filter[keep only rows for validationTable]
    Filter --> FlatMap[break into attribute maps]
    FlatMap --> ValidatePieces[check every part present]
    ValidatePieces -->|OK| Join[join values -> "FRM_MULTI_COLUMN_KEY"]
    Join --> DuplicateCheck[validateMultipleColumnsForDuplicates]
    DuplicateCheck --> Result((true/false))

 =====================================
 Understanding validateMultiColumn Method
 Method Purpose
 This method validates records that require checking for uniqueness across multiple columns. It:

 Prepares the data by creating concatenated values from multiple columns
 Calls another method to check for duplicates

 Sample Input Data
 Let's assume we have a NewRecordRequest with this structure:
 json{
   "data": [
     {
       "entity": "EMPLOYEES",
       "attributeData": [
         {
           "EMPLOYEE_ID": "EMP001",
           "FIRST_NAME": "John",
           "LAST_NAME": "Doe",
           "DEPARTMENT": "IT",
           "OFFICE_LOCATION": "Seattle"
         },
         {
           "EMPLOYEE_ID": "EMP002",
           "FIRST_NAME": "Jane",
           "LAST_NAME": "Smith",
           "DEPARTMENT": "HR",
           "OFFICE_LOCATION": "Seattle"
         }
       ]
     },
     {
       "entity": "DEPARTMENTS",
       "attributeData": [
         {
           "DEPT_ID": "IT001",
           "DEPT_NAME": "Information Technology"
         }
       ]
     }
   ]
 }
 Method Execution Example
 If we call:
 javavalidateMultiColumn(request, "FIRST_NAME,LAST_NAME", "EMPLOYEES")
 Step-by-Step Execution:

 Filter by Entity:

 Only the "EMPLOYEES" entity record is selected


 FlatMap to Attributes:

 Creates a stream of the two employee attribute maps


 For Each Attribute:

 Check if multi-column validation applies using queryUtil.multiColumnValuesValidation
 If yes, concatenate the values specified in columnSpec ("FIRST_NAME,LAST_NAME")


 Store Concatenated Values:

 For Employee 1: Stores "John,Doe" with key FRM_MULTI_COLUMN_KEY
 For Employee 2: Stores "Jane,Smith" with key FRM_MULTI_COLUMN_KEY


 Check for Duplicates:

 Call validateMultipleColumnsForDuplicates to see if any concatenated values appear multiple times
 In our example, there are no duplicates, so the method would return true



 Duplicate Example
 If we had a third employee with the same name:
 json{
   "EMPLOYEE_ID": "EMP003",
   "FIRST_NAME": "John",
   "LAST_NAME": "Doe",
   "DEPARTMENT": "Finance",
   "OFFICE_LOCATION": "New York"
 }
 Then the method would:

 Find a duplicate concatenated value "John,Doe"
 Return false from validateMultipleColumnsForDuplicates

 Notes

 The method handles detecting duplicate combinations across multiple columns to enforce business rules that require uniqueness across column groupings.
 The FRM_MULTI_COLUMN_KEY is a special key used to store the concatenated values temporarily for duplicate checking.
 The actual duplicate checking logic happens in the validateMultipleColumnsForDuplicates method, which is called at the end.
 This implementation supports dynamic column specifications through the columnSpec parameter, allowing validation against different column combinations.