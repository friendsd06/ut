import java.util.*;

/**
 * MCR Validation Service Implementation
 *
 * This service validates financial records for banking operations.
 * It performs three main types of validation:
 * 1. Position Code Validation - Ensures position codes are valid
 * 2. Balance Parent Class Code Validation - Validates parent-child relationships
 * 3. Duplication Validation - Prevents duplicate records
 */
public class MCRValidationServiceImpl implements MCRValidationService {

    // Constants for error messages
    private static final String LOAN_VALIDATION_DELIMITER = "|";
    private static final String LOAN_VALIDATION_MCR_ERROR_MSG = "MCR_VALIDATION_ERROR";
    private static final String LOAN_908_VALIDATION_ERROR_MSG = "908_VALIDATION_ERROR";
    private static final String DUPLICATE_ERROR_MSG = "DUPLICATE_ERROR";
    private static final String DF_LOAN = "DF_LOAN";
    private static final String CLASS_CODE_908 = "908";

    /**
     * Validates if a position code exists in the approved position codes map
     *
     * Business Rule: Every financial record must have a valid position code
     * that exists in the master position codes list
     *
     * SAMPLE INPUT:
     * attributeRecord = {
     *   "POSITION_CODE": "SAVINGS-001",
     *   "BALANCE": "1000.00",
     *   "CURRENCY": "USD"
     * }
     *
     * positionChildClassCodeMap = {
     *   "SAVINGS-001": BalanceAttributeData{classCode: "ASSET", logicalRecordID: "GROUP-1"},
     *   "CHECKING-001": BalanceAttributeData{classCode: "ASSET", logicalRecordID: "GROUP-1"},
     *   "LOAN-001": BalanceAttributeData{classCode: "LIABILITY", logicalRecordID: "GROUP-2"}
     * }
     *
     * SAMPLE OUTPUT (SUCCESS):
     * Return: true
     * attributeRecord = {
     *   "POSITION_CODE": "SAVINGS-001",    // Unchanged
     *   "BALANCE": "1000.00",
     *   "CURRENCY": "USD"
     * }
     *
     * SAMPLE OUTPUT (FAILURE - if position code was "INVALID-999"):
     * Return: false
     * attributeRecord = {
     *   "POSITION_CODE": "INVALID-999|MCR_VALIDATION_ERROR",  // Error added
     *   "BALANCE": "1000.00",
     *   "CURRENCY": "USD"
     * }
     *
     * @param attributeRecord The financial record being validated
     * @param ncrValidationMetadata Configuration containing field names and rules
     * @param positionChildClassCodeMap Master list of valid position codes
     * @return true if position code is valid, false otherwise
     */
    @Override
    public boolean validatePositionCode(Map<String, String> attributeRecord,
                                      MCRValidationMetadata ncrValidationMetadata,
                                      Map<String, BalanceAttributeData> positionChildClassCodeMap) {

        // Get the field name that contains the position code
        String positionCodeFieldName = ncrValidationMetadata.getPositionTableKeyAttr();

        // Extract the actual position code value from the record
        String positionCodeValue = attributeRecord.get(positionCodeFieldName);

        // Check if this position code exists in our approved list
        boolean isPositionCodeValid = positionChildClassCodeMap.containsKey(positionCodeValue);

        if (isPositionCodeValid) {
            // Position code is valid - no action needed
            System.out.println("‚úÖ Position code validation passed for: " + positionCodeValue);
            return true;
        } else {
            // Position code is invalid - add error message to the record
            String errorMessage = positionCodeValue + LOAN_VALIDATION_DELIMITER + LOAN_VALIDATION_MCR_ERROR_MSG;
            attributeRecord.put(positionCodeFieldName, errorMessage);

            System.out.println("‚ùå Position code validation failed for: " + positionCodeValue);
            return false;
        }
    }

    /**
     * Validates parent-child class code relationships with special handling for loan products
     *
     * Business Rules:
     * 1. Regular records: Parent and child class codes must match
     * 2. DF_LOAN with 908 code: Special validation using stream codes
     *
     * SAMPLE INPUT (Regular Validation):
     * attributeRecord = {
     *   "CLASS_CODE": "ASSET",
     *   "PARENT_CLASS_CODE": "ASSET",
     *   "POSITION_CODE": "POS-001"
     * }
     *
     * positionClassCodeMap = {
     *   "POS-001": BalanceAttributeData{classCode: "ASSET", logicalRecordID: "GROUP-1"}
     * }
     *
     * subProduct = "REGULAR"
     *
     * SAMPLE OUTPUT (Regular Success):
     * Return: true
     * attributeRecord = {
     *   "CLASS_CODE": "ASSET",
     *   "PARENT_CLASS_CODE": "ASSET",     // Matches position's class code
     *   "POSITION_CODE": "POS-001"
     * }
     *
     * SAMPLE INPUT (Special DF_LOAN Validation):
     * attributeRecord = {
     *   "CLASS_CODE": "908",
     *   "STREAM_CODE": "MORTGAGE-STREAM",
     *   "POSITION_CODE": "POS-001"
     * }
     *
     * intfeeClassCodeStreamCodeMap = {
     *   "MORTGAGE-STREAM": BalanceAttributeData{classCode: "908", logicalRecordID: "SPECIAL"},
     *   "PERSONAL-STREAM": BalanceAttributeData{classCode: "908", logicalRecordID: "SPECIAL"}
     * }
     *
     * subProduct = "DF_LOAN"
     *
     * SAMPLE OUTPUT (Special Success):
     * Return: true
     * attributeRecord = {
     *   "CLASS_CODE": "908",
     *   "STREAM_CODE": "MORTGAGE-STREAM",  // Valid stream code found
     *   "POSITION_CODE": "POS-001"
     * }
     *
     * SAMPLE OUTPUT (Failure - invalid stream code):
     * Return: false
     * attributeRecord = {
     *   "CLASS_CODE": "908",
     *   "STREAM_CODE": "INVALID-STREAM|908_VALIDATION_ERROR",  // Error added
     *   "POSITION_CODE": "POS-001"
     * }
     *
     * @param attributeRecord The financial record being validated
     * @param ncrValidationMetadata Configuration containing field names and rules
     * @param positionClassCodeMap Map linking positions to their class codes
     * @param intfeeClassCodeStreamCodeMap Map of valid stream codes for special loans
     * @param subProduct The product type (e.g., "DF_LOAN")
     * @return true if validation passes, false otherwise
     */
    @Override
    public boolean validateBalanceParentClassCode(Map<String, String> attributeRecord,
                                                MCRValidationMetadata ncrValidationMetadata,
                                                Map<String, BalanceAttributeData> positionClassCodeMap,
                                                Map<String, BalanceAttributeData> intfeeClassCodeStreamCodeMap,
                                                String subProduct) {

        // If position map is empty, we cannot validate - return false
        if (positionClassCodeMap.isEmpty()) {
            System.out.println("‚ùå Position class code map is empty - cannot validate");
            return false;
        }

        // Extract required field names from metadata
        String classCodeFieldName = ncrValidationMetadata.getClassCodeAttr();
        String classCode908Value = ncrValidationMetadata.getClassCode908Val();
        String positionCodeFieldName = ncrValidationMetadata.getPositionTableKeyAttr();
        String parentClassCodeFieldName = ncrValidationMetadata.getParentClassCodeAttr();

        // Extract values from the record
        String recordClassCode = attributeRecord.get(classCodeFieldName);
        String positionCodeValue = attributeRecord.get(positionCodeFieldName);

        // Determine which validation logic to use
        boolean isSpecialLoanCase = DF_LOAN.equalsIgnoreCase(subProduct) &&
                                   CLASS_CODE_908.equalsIgnoreCase(recordClassCode);

        if (isSpecialLoanCase) {
            // Special case: DF_LOAN with 908 class code
            return validateSpecialLoanStreamCode(attributeRecord, ncrValidationMetadata,
                                               intfeeClassCodeStreamCodeMap);
        } else {
            // Regular case: Validate parent-child class code relationship
            return validateRegularParentChildClassCode(attributeRecord, ncrValidationMetadata,
                                                     positionClassCodeMap, positionCodeValue);
        }
    }

    /**
     * Validates stream codes for special DF_LOAN products with 908 class code
     *
     * SAMPLE INPUT:
     * attributeRecord = {
     *   "STREAM_CODE": "MORTGAGE-STREAM",
     *   "CLASS_CODE": "908",
     *   "POSITION_CODE": "POS-001"
     * }
     *
     * intfeeClassCodeStreamCodeMap = {
     *   "MORTGAGE-STREAM": BalanceAttributeData{...},
     *   "PERSONAL-STREAM": BalanceAttributeData{...}
     * }
     *
     * SAMPLE OUTPUT (Success):
     * Return: true
     * attributeRecord = unchanged
     *
     * SAMPLE OUTPUT (Failure):
     * Return: false
     * attributeRecord = {
     *   "STREAM_CODE": "INVALID-STREAM|908_VALIDATION_ERROR",  // Error added
     *   "CLASS_CODE": "908",
     *   "POSITION_CODE": "POS-001"
     * }
     */
    private boolean validateSpecialLoanStreamCode(Map<String, String> attributeRecord,
                                                MCRValidationMetadata ncrValidationMetadata,
                                                Map<String, BalanceAttributeData> intfeeClassCodeStreamCodeMap) {

        String streamCodeFieldName = ncrValidationMetadata.getStreamCodeAttr();
        String streamCodeValue = attributeRecord.get(streamCodeFieldName);

        // Check if the stream code exists in the approved list for this loan type
        boolean isStreamCodeValid = intfeeClassCodeStreamCodeMap.containsKey(streamCodeValue);

        if (isStreamCodeValid) {
            System.out.println("‚úÖ Special loan stream code validation passed for: " + streamCodeValue);
            return true;
        } else {
            // Stream code is invalid - add error message
            String errorMessage = streamCodeValue + LOAN_VALIDATION_DELIMITER + LOAN_908_VALIDATION_ERROR_MSG;
            attributeRecord.put(streamCodeFieldName, errorMessage);

            System.out.println("‚ùå Special loan stream code validation failed for: " + streamCodeValue);
            return false;
        }
    }

    /**
     * Validates regular parent-child class code relationships
     *
     * SAMPLE INPUT:
     * attributeRecord = {
     *   "PARENT_CLASS_CODE": "ASSET",
     *   "POSITION_CODE": "POS-001",
     *   "CLASS_CODE": "ASSET"
     * }
     *
     * positionClassCodeMap = {
     *   "POS-001": BalanceAttributeData{classCode: "ASSET", logicalRecordID: "GROUP-1"}
     * }
     *
     * SAMPLE OUTPUT (Success - codes match):
     * Return: true
     * attributeRecord = unchanged
     *
     * SAMPLE OUTPUT (Failure - codes don't match):
     * Return: false
     * attributeRecord = {
     *   "PARENT_CLASS_CODE": "LIABILITY|908_VALIDATION_ERROR",  // Error added
     *   "POSITION_CODE": "POS-001",
     *   "CLASS_CODE": "ASSET"
     * }
     */
    private boolean validateRegularParentChildClassCode(Map<String, String> attributeRecord,
                                                      MCRValidationMetadata ncrValidationMetadata,
                                                      Map<String, BalanceAttributeData> positionClassCodeMap,
                                                      String positionCodeValue) {

        String parentClassCodeFieldName = ncrValidationMetadata.getParentClassCodeAttr();
        String parentClassCodeValue = attributeRecord.get(parentClassCodeFieldName);

        // Get the expected class code for this position
        BalanceAttributeData positionData = positionClassCodeMap.get(positionCodeValue);
        String expectedClassCode = (positionData != null) ? positionData.getClassCode() : "";

        // Check if parent class code matches the expected class code
        boolean isClassCodeMatching = expectedClassCode.equalsIgnoreCase(parentClassCodeValue);

        if (isClassCodeMatching) {
            System.out.println("‚úÖ Parent-child class code validation passed");
            return true;
        } else {
            // Class codes don't match - add error message
            String errorMessage = parentClassCodeValue + LOAN_VALIDATION_DELIMITER + LOAN_908_VALIDATION_ERROR_MSG;
            attributeRecord.put(parentClassCodeFieldName, errorMessage);

            System.out.println("‚ùå Parent-child class code validation failed. Expected: " +
                             expectedClassCode + ", Found: " + parentClassCodeValue);
            return false;
        }
    }

    /**
     * Validates for duplicate records within logical groups
     *
     * Business Rule: Within the same logical group (e.g., same branch),
     * duplicate values are not allowed for specified fields
     *
     * Supports two types of duplicate checking:
     * 1. Single field: Check one field for duplicates
     * 2. Multiple fields: Check combination of fields for duplicates
     *
     * SAMPLE INPUT (Single Field Check):
     * attributeRecord = {
     *   "POSITION_CODE": "POS-001",
     *   "ACCOUNT_ID": "ACC-123",
     *   "BALANCE": "1000.00"
     * }
     *
     * positionClassCodeMap = {
     *   "POS-001": BalanceAttributeData{classCode: "ASSET", logicalRecordID: "BRANCH-NYC"}
     * }
     *
     * logicalRecordAndCdMap = {
     *   "BRANCH-NYC": ["ACC-111", "ACC-222", "ACC-333"],  // Existing account IDs
     *   "BRANCH-LA": ["ACC-444", "ACC-555"]
     * }
     *
     * dupCheckAttrName = "ACCOUNT_ID"
     *
     * SAMPLE OUTPUT (Single Field Success):
     * Return: true
     * attributeRecord = {
     *   "POSITION_CODE": "POS-001",
     *   "ACCOUNT_ID": "ACC-123",          // Not in existing list, so valid
     *   "BALANCE": "1000.00"
     * }
     *
     * SAMPLE OUTPUT (Single Field Failure - if ACCOUNT_ID was "ACC-222"):
     * Return: false
     * attributeRecord = {
     *   "POSITION_CODE": "POS-001",
     *   "ACCOUNT_ID": "ACC-222|DUPLICATE_ERROR",  // Error added - already exists
     *   "BALANCE": "1000.00"
     * }
     *
     * SAMPLE INPUT (Multiple Field Check):
     * attributeRecord = {
     *   "POSITION_CODE": "POS-001",
     *   "ACCOUNT_ID": "ACC-123",
     *   "CURRENCY": "USD",
     *   "BRANCH_CODE": "BR-001"
     * }
     *
     * logicalRecordAndCdMap = {
     *   "BRANCH-NYC": [
     *     "ACC-111~USD~BR-001",           // Existing combinations
     *     "ACC-222~EUR~BR-002",
     *     "ACC-333~USD~BR-003"
     *   ]
     * }
     *
     * dupCheckAttrName = "ACCOUNT_ID|CURRENCY|BRANCH_CODE"
     *
     * SAMPLE OUTPUT (Multiple Field Success):
     * Return: true
     * attributeRecord = {
     *   "POSITION_CODE": "POS-001",
     *   "ACCOUNT_ID": "ACC-123",          // Combination "ACC-123~USD~BR-001"
     *   "CURRENCY": "USD",                // not in existing list, so valid
     *   "BRANCH_CODE": "BR-001"
     * }
     *
     * SAMPLE OUTPUT (Multiple Field Failure - if combination already exists):
     * Return: false
     * attributeRecord = {
     *   "POSITION_CODE": "POS-001",
     *   "ACCOUNT_ID": "ACC-111|DUPLICATE_ERROR",     // All fields marked with error
     *   "CURRENCY": "USD|DUPLICATE_ERROR",
     *   "BRANCH_CODE": "BR-001|DUPLICATE_ERROR"
     * }
     *
     * @param attributeRecord The financial record being validated
     * @param ncrValidationMetadata Configuration containing field names and rules
     * @param logicalRecordAndCdMap Map of logical groups and their existing values
     * @param positionClassCodeMap Map to determine which logical group a record belongs to
     * @param dupCheckAttrName Field name(s) to check for duplicates (use "|" for multiple)
     * @return true if no duplicates found, false otherwise
     */
    @Override
    public boolean validateDuplication(Map<String, String> attributeRecord,
                                     MCRValidationMetadata ncrValidationMetadata,
                                     Map<String, List<String>> logicalRecordAndCdMap,
                                     Map<String, BalanceAttributeData> positionClassCodeMap,
                                     String dupCheckAttrName) throws AdjustmentException {

        // If logical record map is empty, there are no existing records to check against
        if (logicalRecordAndCdMap.isEmpty()) {
            System.out.println("‚ÑπÔ∏è No existing records to check for duplicates - validation passes");
            return true;
        }

        // Determine which logical group this record belongs to
        String positionCodeFieldName = ncrValidationMetadata.getPositionTableKeyAttr();
        String positionCodeValue = attributeRecord.get(positionCodeFieldName);

        BalanceAttributeData positionData = positionClassCodeMap.get(positionCodeValue);
        String logicalRecordID = (positionData != null) ? positionData.getLogicalRecordID() : "";

        // Check if we're validating single field or multiple fields
        boolean isMultipleFieldCheck = dupCheckAttrName.contains("|");

        if (isMultipleFieldCheck) {
            // Multiple fields - combine values and check for duplicates
            return validateMultipleFieldDuplication(attributeRecord, ncrValidationMetadata,
                                                   logicalRecordAndCdMap, logicalRecordID, dupCheckAttrName);
        } else {
            // Single field - check for duplicates
            return validateSingleFieldDuplication(attributeRecord, logicalRecordAndCdMap,
                                                 logicalRecordID, dupCheckAttrName);
        }
    }

    /**
     * Validates duplication for a single field
     *
     * SAMPLE INPUT:
     * attributeRecord = {
     *   "ACCOUNT_ID": "ACC-123",
     *   "POSITION_CODE": "POS-001"
     * }
     *
     * logicalRecordAndCdMap = {
     *   "BRANCH-NYC": ["ACC-111", "ACC-222", "ACC-333"]
     * }
     *
     * fieldName = "ACCOUNT_ID"
     * logicalRecordID = "BRANCH-NYC"
     *
     * SAMPLE OUTPUT (Success - no duplicate):
     * Return: true
     * attributeRecord = unchanged
     *
     * SAMPLE OUTPUT (Failure - duplicate found):
     * Return: false
     * attributeRecord = {
     *   "ACCOUNT_ID": "ACC-222|DUPLICATE_ERROR",  // Error added
     *   "POSITION_CODE": "POS-001"
     * }
     */
    private boolean validateSingleFieldDuplication(Map<String, String> attributeRecord,
                                                  Map<String, List<String>> logicalRecordAndCdMap,
                                                  String logicalRecordID,
                                                  String fieldName) {

        String fieldValue = attributeRecord.get(fieldName);

        // Get the list of existing values for this logical group
        List<String> existingValues = logicalRecordAndCdMap.get(logicalRecordID);

        if (existingValues != null && existingValues.contains(fieldValue)) {
            // Duplicate found - add error message
            String errorMessage = fieldValue + LOAN_VALIDATION_DELIMITER + DUPLICATE_ERROR_MSG;
            attributeRecord.put(fieldName, errorMessage);

            System.out.println("‚ùå Duplicate validation failed for field '" + fieldName +
                             "' with value: " + fieldValue);
            return false;
        } else {
            System.out.println("‚úÖ No duplicate found for field '" + fieldName +
                             "' with value: " + fieldValue);
            return true;
        }
    }

    /**
     * Validates duplication for multiple fields combined
     *
     * SAMPLE INPUT:
     * attributeRecord = {
     *   "ACCOUNT_ID": "ACC-123",
     *   "CURRENCY": "USD",
     *   "BRANCH_CODE": "BR-001",
     *   "POSITION_CODE": "POS-001"
     * }
     *
     * logicalRecordAndCdMap = {
     *   "BRANCH-NYC": [
     *     "ACC-111~USD~BR-001",    // Existing combinations
     *     "ACC-222~EUR~BR-002"
     *   ]
     * }
     *
     * multipleFieldNames = "ACCOUNT_ID|CURRENCY|BRANCH_CODE"
     * logicalRecordID = "BRANCH-NYC"
     *
     * Process: Combines fields to "ACC-123~USD~BR-001"
     *
     * SAMPLE OUTPUT (Success - combination not found):
     * Return: true
     * attributeRecord = unchanged
     *
     * SAMPLE OUTPUT (Failure - combination exists):
     * Return: false
     * attributeRecord = {
     *   "ACCOUNT_ID": "ACC-111|DUPLICATE_ERROR",     // All fields marked
     *   "CURRENCY": "USD|DUPLICATE_ERROR",
     *   "BRANCH_CODE": "BR-001|DUPLICATE_ERROR",
     *   "POSITION_CODE": "POS-001"
     * }
     */
    private boolean validateMultipleFieldDuplication(Map<String, String> attributeRecord,
                                                   MCRValidationMetadata ncrValidationMetadata,
                                                   Map<String, List<String>> logicalRecordAndCdMap,
                                                   String logicalRecordID,
                                                   String multipleFieldNames) throws AdjustmentException {

        try {
            // Split the field names by "|" delimiter
            String[] fieldNames = multipleFieldNames.split("\\|");

            // Build a map of field names to their values
            Map<String, String> fieldValueMap = new HashMap<>();
            for (String fieldName : fieldNames) {
                String fieldValue = attributeRecord.get(fieldName);
                fieldValueMap.put(fieldName, fieldValue);
            }

            // Combine all field values into a single string for comparison
            String combinedValue = buildCombinedValue(fieldValueMap, fieldNames);

            // Check if this combination already exists
            List<String> existingCombinations = logicalRecordAndCdMap.get(logicalRecordID);

            if (existingCombinations != null && existingCombinations.contains(combinedValue)) {
                // Duplicate combination found - mark ALL fields with error
                addErrorToAllFields(attributeRecord, fieldNames);

                System.out.println("‚ùå Duplicate combination found for fields: " +
                                 Arrays.toString(fieldNames) + " with combined value: " + combinedValue);
                return false;
            } else {
                System.out.println("‚úÖ No duplicate combination found for fields: " +
                                 Arrays.toString(fieldNames));
                return true;
            }

        } catch (Exception e) {
            System.err.println("Error during multiple field duplicate validation: " + e.getMessage());
            throw new AdjustmentException("Multiple field duplicate validation failed: " + e.getMessage());
        }
    }

    /**
     * Builds a combined value from multiple fields for duplicate checking
     *
     * SAMPLE INPUT:
     * fieldValueMap = {
     *   "ACCOUNT_ID": "ACC-123",
     *   "CURRENCY": "USD",
     *   "BRANCH_CODE": "BR-001"
     * }
     *
     * fieldNames = ["ACCOUNT_ID", "CURRENCY", "BRANCH_CODE"]
     *
     * SAMPLE OUTPUT:
     * Return: "ACC-123~USD~BR-001"
     *
     * Process: Concatenates values with "~" separator
     */
    private String buildCombinedValue(Map<String, String> fieldValueMap, String[] fieldNames) {
        StringBuilder combinedValue = new StringBuilder();

        for (int i = 0; i < fieldNames.length; i++) {
            String fieldValue = fieldValueMap.get(fieldNames[i]);
            combinedValue.append(fieldValue != null ? fieldValue : "");

            // Add separator between values (except for the last one)
            if (i < fieldNames.length - 1) {
                combinedValue.append("~");
            }
        }

        return combinedValue.toString();
    }

    /**
     * Adds error messages to all specified fields
     *
     * SAMPLE INPUT:
     * attributeRecord = {
     *   "ACCOUNT_ID": "ACC-123",
     *   "CURRENCY": "USD",
     *   "BRANCH_CODE": "BR-001"
     * }
     *
     * fieldNames = ["ACCOUNT_ID", "CURRENCY", "BRANCH_CODE"]
     *
     * SAMPLE OUTPUT:
     * attributeRecord = {
     *   "ACCOUNT_ID": "ACC-123|DUPLICATE_ERROR",
     *   "CURRENCY": "USD|DUPLICATE_ERROR",
     *   "BRANCH_CODE": "BR-001|DUPLICATE_ERROR"
     * }
     *
     * Process: Appends "|DUPLICATE_ERROR" to each field's original value
     */
    private void addErrorToAllFields(Map<String, String> attributeRecord, String[] fieldNames) {
        for (String fieldName : fieldNames) {
            String originalValue = attributeRecord.get(fieldName);
            String errorMessage = originalValue + LOAN_VALIDATION_DELIMITER + DUPLICATE_ERROR_MSG;
            attributeRecord.put(fieldName, errorMessage);
        }
    }

    // ===========================================
    // MAIN METHOD FOR TESTING
    // ===========================================

    public static void main(String[] args) {
        System.out.println("üè¶ Starting MCR Validation Service Tests");
        System.out.println("========================================");

        MCRValidationServiceImpl service = new MCRValidationServiceImpl();

        // Test all validation methods
        testPositionCodeValidation(service);
        testBalanceParentClassCodeValidation(service);
        testDuplicationValidation(service);

        System.out.println("\n‚úÖ All tests completed!");
    }

    /**
     * Test position code validation with sample data
     */
    private static void testPositionCodeValidation(MCRValidationServiceImpl service) {
        System.out.println("\nüìã Testing Position Code Validation");
        System.out.println("-----------------------------------");

        // Create sample metadata
        MCRValidationMetadata metadata = new MCRValidationMetadata();
        metadata.setPositionTableKeyAttr("POSITION_CODE");

        // Create sample valid position codes
        Map<String, BalanceAttributeData> validPositions = new HashMap<>();
        validPositions.put("SAVINGS-001", new BalanceAttributeData("ASSET", "GROUP-1"));
        validPositions.put("CHECKING-001", new BalanceAttributeData("ASSET", "GROUP-1"));
        validPositions.put("LOAN-001", new BalanceAttributeData("LIABILITY", "GROUP-2"));

        // Test Case 1: Valid position code
        Map<String, String> record1 = new HashMap<>();
        record1.put("POSITION_CODE", "SAVINGS-001");
        record1.put("BALANCE", "1000.00");

        boolean result1 = service.validatePositionCode(record1, metadata, validPositions);
        System.out.println("Test 1 - Valid position code: " + (result1 ? "PASS" : "FAIL"));
        System.out.println("Record after validation: " + record1);

        // Test Case 2: Invalid position code
        Map<String, String> record2 = new HashMap<>();
        record2.put("POSITION_CODE", "INVALID-999");
        record2.put("BALANCE", "2000.00");

        boolean result2 = service.validatePositionCode(record2, metadata, validPositions);
        System.out.println("\nTest 2 - Invalid position code: " + (!result2 ? "PASS" : "FAIL"));
        System.out.println("Record after validation: " + record2);
    }

    /**
     * Test balance parent class code validation with sample data
     */
    private static void testBalanceParentClassCodeValidation(MCRValidationServiceImpl service) {
        System.out.println("\nüë®‚Äçüë©‚Äçüëß‚Äçüë¶ Testing Balance Parent Class Code Validation");
        System.out.println("---------------------------------------------");

        // Create sample metadata
        MCRValidationMetadata metadata = new MCRValidationMetadata();
        metadata.setClassCodeAttr("CLASS_CODE");
        metadata.setClassCode908Val("908");
        metadata.setPositionTableKeyAttr("POSITION_CODE");
        metadata.setParentClassCodeAttr("PARENT_CLASS_CODE");
        metadata.setStreamCodeAttr("STREAM_CODE");

        // Create sample position mappings
        Map<String, BalanceAttributeData> positionMap = new HashMap<>();
        positionMap.put("POS-001", new BalanceAttributeData("ASSET", "GROUP-1"));
        positionMap.put("POS-002", new BalanceAttributeData("LIABILITY", "GROUP-2"));

        // Create sample stream code mappings for special loans
        Map<String, BalanceAttributeData> streamMap = new HashMap<>();
        streamMap.put("MORTGAGE-STREAM", new BalanceAttributeData("908", "SPECIAL"));
        streamMap.put("PERSONAL-STREAM", new BalanceAttributeData("908", "SPECIAL"));

        // Test Case 1: Regular validation - matching class codes
        Map<String, String> record1 = new HashMap<>();
        record1.put("CLASS_CODE", "ASSET");
        record1.put("POSITION_CODE", "POS-001");
        record1.put("PARENT_CLASS_CODE", "ASSET");

        boolean result1 = service.validateBalanceParentClassCode(record1, metadata, positionMap,
                                                               streamMap, "REGULAR");
        System.out.println("Test 1 - Regular validation (matching): " + (result1 ? "PASS" : "FAIL"));
        System.out.println("Record after validation: " + record1);

        // Test Case 2: Special DF_LOAN validation with valid stream code
        Map<String, String> record2 = new HashMap<>();
        record2.put("CLASS_CODE", "908");
        record2.put("STREAM_CODE", "MORTGAGE-STREAM");
        record2.put("POSITION_CODE", "POS-001");

        boolean result2 = service.validateBalanceParentClassCode(record2, metadata, positionMap,
                                                               streamMap, "DF_LOAN");
        System.out.println("\nTest 2 - DF_LOAN validation (valid stream): " + (result2 ? "PASS" : "FAIL"));
        System.out.println("Record after validation: " + record2);

        // Test Case 3: Special DF_LOAN validation with invalid stream code
        Map<String, String> record3 = new HashMap<>();
        record3.put("CLASS_CODE", "908");
        record3.put("STREAM_CODE", "INVALID-STREAM");
        record3.put("POSITION_CODE", "POS-001");

        boolean result3 = service.validateBalanceParentClassCode(record3, metadata, positionMap,
                                                               streamMap, "DF_LOAN");
        System.out.println("\nTest 3 - DF_LOAN validation (invalid stream): " + (!result3 ? "PASS" : "FAIL"));
        System.out.println("Record after validation: " + record3);
    }

    /**
     * Test duplication validation with sample data
     */
    private static void testDuplicationValidation(MCRValidationServiceImpl service) {
        System.out.println("\nüîç Testing Duplication Validation");
        System.out.println("---------------------------------");

        // Create sample metadata
        MCRValidationMetadata metadata = new MCRValidationMetadata();
        metadata.setPositionTableKeyAttr("POSITION_CODE");

        // Create sample position mappings
        Map<String, BalanceAttributeData> positionMap = new HashMap<>();
        positionMap.put("POS-001", new BalanceAttributeData("ASSET", "BRANCH-NYC"));
        positionMap.put("POS-002", new BalanceAttributeData("LIABILITY", "BRANCH-NYC"));

        // Create sample existing records by logical group
        Map<String, List<String>> existingRecords = new HashMap<>();
        existingRecords.put("BRANCH-NYC", Arrays.asList("ACC-111", "ACC-222", "ACC-333"));
        existingRecords.put("BRANCH-LA", Arrays.asList("ACC-444", "ACC-555"));

        // Test Case 1: Single field - no duplicate
        Map<String, String> record1 = new HashMap<>();
        record1.put("POSITION_CODE", "POS-001");
        record1.put("ACCOUNT_ID", "ACC-999");

        try {
            boolean result1 = service.validateDuplication(record1, metadata, existingRecords,
                                                         positionMap, "ACCOUNT_ID");
            System.out.println("Test 1 - Single field (no duplicate): " + (result1 ? "PASS" : "FAIL"));
            System.out.println("Record after validation: " + record1);
        } catch (AdjustmentException e) {
            System.out.println("Test 1 failed with exception: " + e.getMessage());
        }

        // Test Case 2: Single field - duplicate found
        Map<String, String> record2 = new HashMap<>();
        record2.put("POSITION_CODE", "POS-001");
        record2.put("ACCOUNT_ID", "ACC-222"); // This exists in BRANCH-NYC

        try {
            boolean result2 = service.validateDuplication(record2, metadata, existingRecords,
                                                         positionMap, "ACCOUNT_ID");
            System.out.println("\nTest 2 - Single field (duplicate found): " + (!result2 ? "PASS" : "FAIL"));
            System.out.println("Record after validation: " + record2);
        } catch (AdjustmentException e) {
            System.out.println("Test 2 failed with exception: " + e.getMessage());
        }

        // Test Case 3: Multiple fields - prepare existing combinations
        Map<String, List<String>> existingCombinations = new HashMap<>();
        existingCombinations.put("BRANCH-NYC", Arrays.asList("ACC-111~USD~BR-001", "ACC-222~EUR~BR-002"));

        Map<String, String> record3 = new HashMap<>();
        record3.put("POSITION_CODE", "POS-001");
        record3.put("ACCOUNT_ID", "ACC-333");
        record3.put("CURRENCY", "USD");
        record3.put("BRANCH_CODE", "BR-003");

        try {
            boolean result3 = service.validateDuplication(record3, metadata, existingCombinations,
                                                         positionMap, "ACCOUNT_ID|CURRENCY|BRANCH_CODE");
            System.out.println("\nTest 3 - Multiple fields (no duplicate): " + (result3 ? "PASS" : "FAIL"));
            System.out.println("Record after validation: " + record3);
        } catch (AdjustmentException e) {
            System.out.println("Test 3 failed with exception: " + e.getMessage());
        }

        // Test Case 4: Multiple fields - duplicate combination
        Map<String, String> record4 = new HashMap<>();
        record4.put("POSITION_CODE", "POS-001");
        record4.put("ACCOUNT_ID", "ACC-111");
        record4.put("CURRENCY", "USD");
        record4.put("BRANCH_CODE", "BR-001");

        try {
            boolean result4 = service.validateDuplication(record4, metadata, existingCombinations,
                                                         positionMap, "ACCOUNT_ID|CURRENCY|BRANCH_CODE");
            System.out.println("\nTest 4 - Multiple fields (duplicate found): " + (!result4 ? "PASS" : "FAIL"));
            System.out.println("Record after validation: " + record4);
        } catch (AdjustmentException e) {
            System.out.println("Test 4 failed with exception: " + e.getMessage());
        }
    }
}

// ===========================================
// SUPPORTING CLASSES AND INTERFACES
// ===========================================

/**
 * Interface for MCR Validation Service
 */
interface MCRValidationService {
    boolean validatePositionCode(Map<String, String> attributeRecord,
                               MCRValidationMetadata ncrValidationMetadata,
                               Map<String, BalanceAttributeData> positionChildClassCodeMap);

    boolean validateBalanceParentClassCode(Map<String, String> attributeRecord,
                                         MCRValidationMetadata ncrValidationMetadata,
                                         Map<String, BalanceAttributeData> positionClassCodeMap,
                                         Map<String, BalanceAttributeData> intfeeClassCodeStreamCodeMap,
                                         String subProduct);

    boolean validateDuplication(Map<String, String> attributeRecord,
                              MCRValidationMetadata ncrValidationMetadata,
                              Map<String, List<String>> logicalRecordAndCdMap,
                              Map<String, BalanceAttributeData> positionClassCodeMap,
                              String dupCheckAttrName) throws AdjustmentException;
}

/**
 * Metadata class containing field names and validation rules
 */
class MCRValidationMetadata {
    private String positionTableKeyAttr;
    private String classCodeAttr;
    private String classCode908Val;
    private String parentClassCodeAttr;
    private String streamCodeAttr;

    // Getters and setters
    public String getPositionTableKeyAttr() { return positionTableKeyAttr; }
    public void setPositionTableKeyAttr(String positionTableKeyAttr) { this.positionTableKeyAttr = positionTableKeyAttr; }

    public String getClassCodeAttr() { return classCodeAttr; }
    public void setClassCodeAttr(String classCodeAttr) { this.classCodeAttr = classCodeAttr; }

    public String getClassCode908Val() { return classCode908Val; }
    public void setClassCode908Val(String classCode908Val) { this.classCode908Val = classCode908Val; }

    public String getParentClassCodeAttr() { return parentClassCodeAttr; }
    public void setParentClassCodeAttr(String parentClassCodeAttr) { this.parentClassCodeAttr = parentClassCodeAttr; }

    public String getStreamCodeAttr() { return streamCodeAttr; }
    public void setStreamCodeAttr(String streamCodeAttr) { this.streamCodeAttr = streamCodeAttr; }
}

/**
 * Data class representing balance attribute information
 */
class BalanceAttributeData {
    private String classCode;
    private String logicalRecordID;

    public BalanceAttributeData(String classCode, String logicalRecordID) {
        this.classCode = classCode;
        this.logicalRecordID = logicalRecordID;
    }

    // Getters and setters
    public String getClassCode() { return classCode; }
    public void setClassCode(String classCode) { this.classCode = classCode; }

    public String getLogicalRecordID() { return logicalRecordID; }
    public void setLogicalRecordID(String logicalRecordID) { this.logicalRecordID = logicalRecordID; }
}

/**
 * Custom exception for validation errors
 */
class AdjustmentException extends Exception {
    public AdjustmentException(String message) {
        super(message);
    }
}